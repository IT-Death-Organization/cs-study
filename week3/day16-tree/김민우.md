# Day 16: 트리(Tree) 기본 개념
> 📅 2025.02.28 | 📁 Week 3
---
## 🧠 학습 질문
- [x] 트리에서 사이클이 없어야 하는 이유는?
- [x] 완전 이진 트리를 배열로 표현할 수 있는 이유는?
- [x] 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?
- [x] 전위/중위/후위 순회는 각각 언제 사용하는가?
- [x] 레벨 순회(Level-order)는 어떻게 구현하는가?
- [x] 편향 트리(Skewed Tree)의 문제점은?
---

# 1. 트리에서 사이클이 없어야 하는 이유

## 정의 관점

트리(Tree)의 수학적 정의:

> 사이클이 없는 연결 그래프 (Acyclic Connected Graph)

사이클이 존재하면 더 이상 트리가 아니라 일반 그래프이다.

---

## 왜 사이클이 있으면 안 되는가?

### 1) 부모가 하나라는 트리 성질이 깨짐

트리의 핵심 특성:

* 루트 제외 모든 노드는 부모가 정확히 1개
* 두 노드 사이의 경로는 유일

사이클 예:

```
A → B → C → A
```

문제점:

* 부모가 2개 이상 존재 가능
* 경로가 여러 개 존재
* 계층 구조 붕괴

---

### 2) 순회 시 무한 루프 발생

DFS 또는 재귀 순회 시:

```
A → B → C → A → B → C ...
```

종료 조건 없이 반복된다.

따라서 트리는 반드시 cycle-free 구조여야 한다.

---

# 2. 완전 이진 트리를 배열로 표현할 수 있는 이유

## 핵심 이유

완전 이진 트리는:

> 왼쪽부터 빈 공간 없이 채워지는 구조

즉, 노드가 레벨 순서대로 연속 배치 가능하다.

예시:

```
        1
      2   3
     4 5 6 7
```

배열 표현:

```
[1, 2, 3, 4, 5, 6, 7]
```

특징:

* 공백이 없음
* 인덱스 계산 가능
* 구조가 자동 결정됨

---

## 왜 일반 트리는 배열 표현이 비효율적인가?

예시:

```
    1
      3
```

배열로 표현하면 중간에 빈칸 필요.

문제점:

* 공간 낭비
* 인덱스 계산 복잡

따라서 완전 이진 트리만 배열 표현이 효율적이다.

대표 예: Heap

---

# 3. 배열로 표현된 트리의 인덱스 공식

## 0번 인덱스 기준

부모:

```
parent(i) = (i - 1) / 2
```

왼쪽 자식:

```
left(i) = 2i + 1
```

오른쪽 자식:

```
right(i) = 2i + 2
```

---

## 1번 인덱스 기준

```
parent(i) = i / 2
left(i) = 2i
right(i) = 2i + 1
```

면접에서는 보통 0-index 기준을 묻는다.

---

# 4. 전위 / 중위 / 후위 순회 사용 목적

## 1) 전위 순회 (Preorder)

순서:

```
루트 → 왼쪽 → 오른쪽
```

사용 용도:

* 트리 복사
* 트리 구조 저장
* 직렬화(Serialization)

예:

```
[1, 2, 4, 5, 3, 6, 7]
```

---

## 2) 중위 순회 (Inorder)

순서:

```
왼쪽 → 루트 → 오른쪽
```

사용 용도:

* 이진 탐색 트리(BST)에서 정렬 결과 획득

BST에서 중위 순회하면 오름차순 정렬 결과가 나온다.

---

## 3) 후위 순회 (Postorder)

순서:

```
왼쪽 → 오른쪽 → 루트
```

사용 용도:

* 트리 삭제
* 수식 트리 계산
* 자식 먼저 처리해야 하는 경우

예: 파일 시스템 삭제 (하위 디렉토리부터 삭제)

---

# 5. 레벨 순회(Level-order) 구현 방법

레벨 순회는 BFS 방식으로 구현한다.

자료구조: Queue 사용

## 알고리즘 예시 (Java)

```java
Queue<Node> q = new LinkedList<>();
q.add(root);

while(!q.isEmpty()) {
    Node cur = q.poll();
    System.out.println(cur.value);

    if(cur.left != null) q.add(cur.left);
    if(cur.right != null) q.add(cur.right);
}
```

---

## 시간복잡도

```
O(n)
```

모든 노드를 한 번씩 방문한다.

---

## 사용 사례

* 트리 높이 계산
* 최단 거리 계산
* 완전 이진 트리 여부 판단

---

# 6. 편향 트리(Skewed Tree)의 문제점

## 정의

모든 노드가 한쪽으로만 치우친 트리.

예시:

```
1
 \
  2
   \
    3
     \
      4
```

---

## 문제점

### 1) 높이 = n

균형 트리:

```
높이 = log n
```

편향 트리:

```
높이 = n
```

---

### 2) 탐색 시간 복잡도 증가

균형 트리:

```
O(log n)
```

편향 트리:

```
O(n)
```

사실상 연결 리스트와 동일한 성능이 된다.

---

### 3) 재귀 호출 시 스택 오버플로우 위험

트리 깊이가 n까지 증가할 수 있다.

---

## 그래서 필요한 구조

* AVL Tree
* Red-Black Tree
* B-Tree

균형 유지 트리가 등장한 이유는 탐색을 O(log n)으로 유지하기 위함이다.


## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

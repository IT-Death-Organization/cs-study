# Day 16: 트리(Tree) 기본 개념
> 📅 2025.02.28 | 📁 Week 3
---
## 🧠 학습 질문
- [ ] 트리에서 사이클이 없어야 하는 이유는?
- [ ] 완전 이진 트리를 배열로 표현할 수 있는 이유는?
- [ ] 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?
- [ ] 전위/중위/후위 순회는 각각 언제 사용하는가?
- [ ] 레벨 순회(Level-order)는 어떻게 구현하는가?
- [ ] 편향 트리(Skewed Tree)의 문제점은?
---

### 📌 [Q1] 트리에서 사이클이 없어야 하는 이유는?

- 트리의 정의 자체가 **사이클이 없는 연결 그래프**이기 때문이다. 
트리는 계층 구조를 표현하는 자료 구조로, **부모-자식**이라는 위계가 있다. 만약 여기서 사이클이 생기게 된다면 (ex. A -> B -> C -> A) 누가 부모고 자식인지 애매해지고, 루트에서 시작해서 내려가는 구조가 깨지게 된다.

- 또한 트리의 중요한 성질은, **임의의 두 노드 사이에는 경로가 정확히 하나만 존재**하는 것이다. 그런데 사이클이 생기게 되면 순환 구조가 되어 두 노드 사이에 여러 경로가 생겨 트리의 핵심 성질이 깨지게 된다. (노드가 n개면 간선은 항상 n-1개)

**정리** <br>
트리는 계층 구조를 표현하기 위한 자료구조이기 때문에 사이클이 존재하면 부모-자식 관계가 모호해지고, 두 노드 사이의 유일한 경로 성질이 깨집니다. 따라서 트리는 정의상 사이클이 없는 연결 그래프입니다.

### 📌 [Q2] 완전 이진 트리를 배열로 표현할 수 있는 이유는?

**이진 트리(binary tree)란?**
- 트리 중에서도 **각 노드가 최대 2개의 자식노드를 가지는 트리**이다. (최대 2개이기 때문에 자식이 없을 수도 있고, 한 개만 있을 수도 있음)
- 이때 자식노드는 각각 왼쪽 자식노드, 오른쪽 자식노드로 표현한다.
- 따라서 두 개의 트리가 같은 루트에 같은 자식노드 하나를 가지고 있어도, 이 자식노드의 위치가 각각 왼쪽과 오른쪽으로 다르다면 그 두 트리는 서로 다른 트리가 된다.

**완전 이진 트리(complete binary tree)란?**
- **마지막 레벨을 제외하고 모든 노드가 채워져있는 트리**이다.
- **노드는 왼쪽에서 오른쪽 방향으로 채워져야 한다.** (따라서 어느 노드에 오른쪽 자식이 존재한다면 왼쪽 자식도 가지고 있어야 완전 이진 트리이다.)

```
        A
      /   \
     B     C
    / \   /
   D   E F
```

**배열로 표현할 수 있는 이유**
위 완전이진트리를 배열로 표현하면 [A, B, C, D, E, F]이다.
이렇게 배열로 표현할 수 있는 이유는 다음과 같다.
- 완전이진트리에는 **인덱스 규칙이 성립**한다. (i는 현재 노드의 배열 인덱스)
  - 왼쪽 자식의 인덱스: 2i + 1
  - 오른쪽 자식의 인덱스: 2i + 2
  - 부모: (i-1) / 2
ex)
```
Index:  0  1  2  3  4  5
Value: [A, B, C, D, E, F]
```

이 인덱스 규칙이 깨지지 않는 이유는 완전이진트리에는 빈칸이 없기 때문이다. 

```
        A
      /   
     B     
      \
       C
```

만약 위와 같은 트리를 배열로 표현하려고 한다면 중간이 비어있어 [A, B, ?, ?, C] 이렇게 된다. 이렇게 되면 빈칸이 많아져 공간이 낭비되고 인덱스의 규칙도 깨지게 된다.
이러한 특성 때문에 힙, 우선순위 큐와 같은 자료구조는 배열로 구현한다.

**정리** <br>
완전 이진 트리는 마지막 레벨을 제외하고는 모두 채워져 있고, 마지막 레벨도 왼쪽부터 채워지기 때문에 노드 사이에 빈 공간이 없습니다. 따라서 배열 인덱스만으로 부모-자식 관계를 계산할 수 있어 배열로 효율적으로 표현할 수 있습니다.

### 📌 [Q3] 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?

배열로 표현된 트리는 완전 이진 트리이고, 인덱스 계산 공식은 아래와 같다. (배열의 인덱스가 0부터 시작한다고 가정)
- 왼쪽 자식 → 2i + 1
- 오른쪽 자식 → 2i + 2
- 부모 → (i - 1) / 2 (정수 나눗셈)

```
Index:  0  1  2  3  4  5
Value: [A, B, C, D, E, F]
```
예를 들어 i = 2 (C):
- 왼쪽 자식 → 2*2 + 1 = 5 → F
- 오른쪽 자식 → 6 (범위 밖이면 없음)
- 부모 → (2 - 1) / 2 = 0 → A

### 📌 [Q4] 전위/중위/후위 순회는 각각 언제 사용하는가?

**전위 순회(Preorder)**
- 루트 -> 왼쪽 -> 오른쪽
- 트리 복사 or 저장 시 사용 (부모 노드를 먼저 방문하기 때문에 트리 구조를 그대로 저장하기 좋음)
- 표현식 트리에서 Prefix 표현식 만들 때 사용 (전위 -> + 3 4)
- 폴더 구조 출력 시 사용 (상위 디렉토리 먼저 출력 -> 그 안의 하위 항목 출력)

**중위 순회(Inorder)**
- 왼쪽 -> 루트 -> 오른쪽
- 이진 탐색 트리(BST)에서 정렬된 결과 얻을 때 사용
  - 이진 탐색 트리는 `왼쪽 서브트리 값 < 루트 값 < 오른쪽 서브트리 값`이기 때문에, 중위 순회하면 **오름차순 정렬 결과가 나옴**

**후위 순회(Postorder)**
- 왼쪽 -> 오른쪽 -> 루트
- 트리 삭제 시 사용 (자식을 먼저 지운 뒤에 부모를 삭제해야 안전)
- 표현식 트리에서 Postfix 표현식 만들 때 사용 (후위 -> 3 4 +)
- 하위 계산 후 상위 계산해야 할 때 사용 (디렉토리 용량 계산, 서브트리 값 합산)

**정리** <br>
전위 순회는 부모를 먼저 방문하기 때문에 트리 구조를 저장하거나 Prefix 표현식을 만들 때 사용합니다. 중위 순회는 이진 탐색 트리에서 정렬된 결과를 얻을 때 사용됩니다. 후위 순회는 자식을 먼저 처리한 뒤 부모를 처리하기 때문에 트리 삭제나 Postfix 표현식 생성에 사용됩니다.

### 📌 [Q5] 레벨 순회(Level-order)는 어떻게 구현하는가?

**레벨 순회란?**
- 루트부터 시작해서 위 -> 아래, 왼쪽 -> 오른쪽 순서로 탐색하는 방식

```
        A
      /   \
     B     C
    / \   /
   D   E F
```
위 트리 레벨 순회 결과: A → B → C → D → E → F

**레벨 순회 구현 방법**
: **큐를 사용한 BFS(너비 우선 탐색) 방식**
1. 루트를 큐에 넣는다.
2. 큐에서 하나 꺼낸다.
3. 그 노드의 왼쪽, 오른쪽 자식을 큐에 넣는다.
4. 큐가 빌 때까지 반복한다.

ex)
1. 초기 상태
`Queue: [A]`

2. A 꺼냄 → B, C 넣음
`Queue: [B, C]`

3. B 꺼냄 → D, E 넣음
`Queue: [C, D, E]`

4. C 꺼냄 → F 넣음
`Queue: [D, E, F]`

~반복~

레벨 순회는 모든 노드를 한 번씩 방문하기 때문에 O(n)의 시간 복잡도를 갖는다. 

### 📌 [Q6] 편향 트리(Skewed Tree)의 문제점은?

**편향 트리란?**
한쪽으로만 계속 치우친 트리이다.

ex 1) 왼쪽 편향
```
    A
   /
  B
 /
C
/
D
```

ex 2) 오른쪽 편향
```
A
 \
  B
   \
    C
     \
      D
```

**편향 트리의 문제점**
- 트리가 아니라 사실상 **연결 리스트**가 된다.
  - 트리의 장점은 높이가 낮아서 빠르게 탐색이 가능하다는 것이다. 그런데 **편향되면 높이 = 노드 개수 n이 되고, 구조가 선형이 되어 트리의 장점이 사라진다.**
- 시간복잡도가 악화된다.
  - 균형 잡힌 이진 트리라면
    - 탐색/삽입/삭제 -> O(log n)
  - 편향 트리라면
    - 탐색/삽입/삭제 -> O(n)
    - 이진 탐색 트리에서 특히 치명적
- 재귀 호출의 깊이가 증가한다.
  - 트리 높이가 n이므로 DFS 재귀 깊이도 n이 되고, 스택 오버플로우 위험도 증가한다.
- 공간 비효율이 발생한다.
  - 균형 트리는 레벨을 효율적으로 사용하지만 편향 트리는 레벨을 거의 활용하지 못하고 한 줄로 늘어져있다.

**정리** <br>
편향 트리는 한쪽으로만 치우쳐 높이가 n이 되기 때문에 이진 탐색 트리의 장점인 O(log n) 성능을 잃고, 탐색·삽입·삭제가 O(n)으로 악화됩니다. 즉, 사실상 연결 리스트와 유사한 구조가 됩니다.

---
## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
https://rosweet-ai.tistory.com/55#google_vignette

---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 16: 트리(Tree) 기본 개념

> 📅 2025.02.28 | 📁 Week 3

---

## 🧠 학습 질문

-   [x] 트리에서 사이클이 없어야 하는 이유는?
-   [x] 완전 이진 트리를 배열로 표현할 수 있는 이유는?
-   [x] 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?
-   [x] 전위/중위/후위 순회는 각각 언제 사용하는가?
-   [x] 레벨 순회(Level-order)는 어떻게 구현하는가?
-   [x] 편향 트리(Skewed Tree)의 문제점은?

# 1. 트리에서 사이클이 없어야 하는 이유

## 1) 트리의 정의 관점

트리는 다음 성질을 만족하는 **연결 그래프(connected graph)**다.

-   사이클이 없다 (acyclic)
-   노드가 N개라면 간선은 N-1개

만약 사이클이 존재하면:

-   어떤 노드에서 다른 노드로 가는 경로가 **두 개 이상** 존재
-   이는 **트리의 유일 경로(unique path)** 성질을 깨뜨림
-   결국 일반 그래프가 됨

## 2) 자료구조 관점

트리는 보통 계층 구조(hierarchy)를 표현한다.

예:

-   파일 시스템
-   조직도
-   DOM 트리
-   BST

사이클이 생기면:

-   부모 → 자식 → 다시 부모로 연결
-   무한 재귀 발생 가능
-   DFS/BFS 시 방문 제어 없으면 infinite loop

즉, **트리는 DAG보다 더 강한 구조(acyclic + connected)**다.

---

# 2. 완전 이진 트리를 배열로 표현할 수 있는 이유

## 핵심 이유: 노드가 빈 공간 없이 "왼쪽부터 채워진 구조"이기 때문

완전 이진 트리(Complete Binary Tree)는:

-   마지막 레벨을 제외한 모든 레벨이 꽉 차 있음
-   마지막 레벨도 왼쪽부터 채워짐

이 특성 때문에:

-   레벨 순서대로 저장하면
-   인덱스만으로 부모/자식 위치를 계산 가능
-   포인터가 필요 없음

대표 예시:

-   힙(Heap)
-   우선순위 큐

---

# 3. 배열 기반 트리의 인덱스 계산 공식

배열 인덱스를 0부터 시작한다고 가정

### 어떤 노드가 i일 때:

### 부모 노드

```
parent = (i - 1) / 2
```

### 왼쪽 자식

```
left = 2i + 1
```

### 오른쪽 자식

```
right = 2i + 2
```

---

## 만약 1부터 시작하면:

### 부모

```
parent = i / 2
```

### 왼쪽 자식

```
left = 2i
```

### 오른쪽 자식

```
right = 2i + 1
```

---

# 4. 전위 / 중위 / 후위 순회는 언제 사용하는가?

## 1) 전위 순회 (Preorder)

```
Root → Left → Right
```

### 사용 목적

-   트리 구조를 그대로 복사
-   Expression tree에서 prefix 표현식 생성
-   트리 직렬화

---

## 2) 중위 순회 (Inorder)

```
Left → Root → Right
```

### 사용 목적

-   BST에서 오름차순 정렬 결과 생성
-   수식 트리에서 infix 표현

BST에서 중위 순회 결과는 항상 sorted.

---

## 3) 후위 순회 (Postorder)

```
Left → Right → Root
```

### 사용 목적

-   트리 삭제 (자식부터 제거)
-   Expression tree에서 postfix 계산
-   서브트리 계산 후 루트 처리해야 할 때

---

# 5. 레벨 순회(Level-order)는 어떻게 구현하는가?

레벨 순회는 BFS 기반이다.

## 구현 방법: Queue 사용

### 알고리즘

1. 루트를 큐에 삽입
2. 큐가 빌 때까지 반복

    - 하나 꺼냄
    - 방문
    - 왼쪽 자식 enqueue
    - 오른쪽 자식 enqueue

### 시간복잡도

```
O(N)
```

### 공간복잡도

```
최대 O(N) (완전 이진 트리 마지막 레벨)
```

실무 예:

-   힙 구성
-   레벨 단위 출력
-   최소 깊이 탐색

---

# 6. 편향 트리(Skewed Tree)의 문제점

## 정의

모든 노드가 한쪽으로만 자식이 존재하는 트리

-   Left Skewed
-   Right Skewed

즉, 사실상 **연결 리스트와 동일**

---

## 문제점

### 1) 높이(height)가 N이 된다

균형 트리:

```
height ≈ logN
```

편향 트리:

```
height = N
```

---

### 2) 탐색 성능 저하

BST 기준:

-   평균: O(logN)
-   편향 시: O(N)

이건 Linked List와 동일 성능.

---

### 3) 재귀 깊이 증가

-   Stack overflow 위험
-   재귀 DFS 시 call stack O(N)

---

### 4) 캐시 효율 저하

균형 트리는 상위 노드가 자주 접근됨.
편향 트리는 탐색 경로가 길어 cache locality 나빠짐.

---

# 정리

| 개념           | 핵심 포인트                           |
| -------------- | ------------------------------------- |
| 트리           | 사이클이 없어야 유일 경로 유지        |
| 완전 이진 트리 | 배열 인덱스로 부모/자식 계산 가능     |
| 인덱스 공식    | parent=(i-1)/2, left=2i+1, right=2i+2 |
| 전위           | 구조 복사 / prefix                    |
| 중위           | BST 정렬                              |
| 후위           | 삭제 / postfix                        |
| 레벨순회       | Queue 기반 BFS                        |
| 편향 트리      | 높이=N → O(N) 성능                    |

---

## 📎 참고 자료

## <!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

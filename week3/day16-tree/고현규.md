# Day 16: 트리(Tree) 기본 개념
> 📅 2025.02.28 | 📁 Week 3
---
## 🧠 학습 질문
- [ ] 트리에서 사이클이 없어야 하는 이유는?
- [ ] 완전 이진 트리를 배열로 표현할 수 있는 이유는?
- [ ] 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?
- [ ] 전위/중위/후위 순회는 각각 언제 사용하는가?
- [ ] 레벨 순회(Level-order)는 어떻게 구현하는가?
- [ ] 편향 트리(Skewed Tree)의 문제점은?
---
<br>

# 1. 트리에서 사이클이 없어야 하는 이유는?

> 트리의 수학적 정의는 "사이클이 없는 연결 그래프(Acyclic Connected Graph)"입니다. 만약 사이클이 있다면 더 이상 트리가 아니라 일반적인 그래프가 됩니다.

### 사이클이 없어야 하는 이유
1. 계층적 구조 유지
    * 트리의 핵심은 부모-자식 관계입니다. 사이클이 생기는 순간 후손이 조상이 되는 모순이 발생합니다.
2. 경로의 유일성 보장
    * 트리 내의 임의의 두 노드 사이에는 오직 하나의 경로만 존재해야 합니다. 그런데 사이클이 생기는 순간 두 노드 사이의 경로는 여러 개가 될 수 있습니다.
3. 순회(Traversal)의 안정성
    * 트리의 탐색에서 주로 재귀(Recursion)를 사용하는데, 사이클이 있다면 종료 조건에 도달하지 못하고 무한 루프에 빠질 수 있습니다.
    * 사이클이 없어야 모든 노드를 한 번씩 안전하게 방문하고 탐색을 끝낼 수 있습니다.

<br>

# 2. 완전 이진 트리를 배열로 표현할 수 있는 이유는?

> 완전 이진 트리(Complete Binary Tree)는 그 구조적 특성 때문에 연결 리스트가 아닌 배열 만으로도 완벽하게 표현할 수 있습니다.

완전 이진 트리는 노드가 빈틈없이 왼쪽부터 차례대로 채워지는 성질을 가지고 있어서 배열의 인덱스와 노드 번호를 1:1로 매칭할 수 있습니다.

트리를 위에서 아래로, 왼쪽에서 오른쪽으로 번호를 매겼을 때 중간에 비는 번호가 단 하나도 없습니다.

또한 배열을 사용하기 때문에 메모리 효율성또한 챙길 수 있습니다.

<br>

# 3. 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?

알고리즘 구현에서 계산의 직관성을 위해 배열의 0번 칸을 비워두고 1번부터 루트를 저장하는 것이 일반적입니다.

* 왼쪽 자식의 인덱스
    * $i \times 2$
* 오른쪽 자식의 인덱스
    * $(i \times 2) + 1$
* 부모의 인덱스
    * $i / 2$
    * (소수점은 버림)

### 참고
컴퓨터 공학적으로 봤을 때 자식을 찾기 위해 2를 곱하거나 나누는 연산은 비트 시프트(Bit Shift) 연산으로 대체할 수 있습니다.

`i << 1` : $i \times 2$

`i >> 1` : $i / 2$

<br>

# 4. 전위/중위/후위 순회는 각각 언제 사용하는가?

> 전위, 중위, 후위 순회는 부모와 왼쪽 자식, 오른쪽 자식의 방문 순서에 따라 정의되는 트리 순회 방법입니다.

### 1) 전위 순회 (Pre-order: Root -> Left -> Right)

트리 복사를 할 때 사용합니다. 부모를 먼저 만들어야 자식을 붙일 수 있기 때문입니다.

구조를 파악하는 경우 계층 구조를 위에서부터 아래로 출력하여 전체적인 흐름을 파악하기 좋습니다. (ex: 디렉토리 구조)

### 2) 중위 순회 (In-order: Left -> Root -> Right)

이진 탐색 트리(BST)에서 노드를 오름차순으로 정렬된 순서로 출력할 때 사용합니다.

### 3) 후위 순회 (Post-order: Left -> Right -> Root)

트리를 삭제할 때 사용합니다. 자식을 먼저 삭제해야 부모를 삭제할 수 있기 때문입니다.

수식 트리(Expression Tree)에서 연산자(부모)를 피연산자(자식) 뒤에 배치하는 후위 표기법(Postfix Notation)을 얻을 때 사용하며, 컴퓨터가 수식을 계산하기 가장 편한 형태가 됩니다.

<br>

# 5. 레벨 순회(Level-order)는 어떻게 구현하는가?

> 4번에서 살펴본 순회들이 Stack을 사용한 DFS(깊이 우선 탐색) 방식이었다면, 레벨 순회는 Queue를 사용한 BFS(너비 우선 탐색)의 트리 버전입니다.

레벨 순화는 방문할 노드들을 차례대로 Queue(FIFO)에 넣고, 순서대로 꺼내며 처리합니다.

### 구현 로직
1. 초기화: 비어있는 큐를 생성하고 루트 노드를 큐에 넣습니다.
2. 반복: 큐가 빌 때까지 다음을 반복합니다.
    ```
    1. 큐에서 노드를 하나 꺼냅니다.
    2. 해당 노드의 값을 처리합니다.
    3. 해당 노드의 왼쪽 자식이 있다면 큐에 넣습니다.
    4. 해당 노드의 오른쪽 자식이 있다면 큐에 넣습니다.
    ```
3. 종료: 큐가 비면 탐색을 종료합니다.

---
### 참고 (메모리 사용량의 차이)

DFS의 메모리 사용량은 트리의 높이에 비례하는 반면, BFS의 메모리 사용량은 트리의 최대 너비에 비례합니다.

뚱뚱한 트리에 BFS를 사용하면 메모리 부하가 생길 수 있습니다. 반대로 깊은 트리에 BFS를 사용하면 메모리 면에서 더 유리할 수 있습니다.

실무에서는 트리의 형태에 따라 어떤 방식이 더 효율적일지 고민이 필요합니다.

<br>

# 6. 편향 트리(Skewed Tree)의 문제점은?

> 편향 트리(Skewed Tree)는 한쪽으로 치우친 트리로, 마치 연결 리스트와 같은 형태를 가집니다.

트리의 이상적인 형태는 좌우 균형이 잘 잡힌 트리입니다. 하지만 실제 데이터를 넣다보면 한쪽으로 길게 늘어지는 편향 트리(Skewed Tree)가 만들어질 수 있습니다.

### 1) 탐색 속도 저하
이진 트리를 사용하는 가장 큰 이유는 탐색 속도를 $O(logN)$으로 유지하기 위해서입니다. 하지만 편향 트리는 그 높이가 데이터의 개수($N$)와 동일해져 탐색 속도가 $O(N)$으로 느려집니다.

### 2) 스택 오버플로우(Stack Overflow)
트리 순회는 주로 재귀(Recursion)를 사용합니다. 이때 트리의 높이만큼 재귀 호출 스택이 쌓이게 됩니다. 균형 잡힌 트리라면 100만개의 데이터도 약 20번 정도의 호출로 끝나지만, 편향 트리는 100만번의 호출이 발생하여 스택 오버플로우가 발생할 수 있습니다.

### 3) 메모리 낭비
2번에서 완전 이진 트리는 배열로 효율적인 관리가 가능하다고 했지만, 편향 트리를 배열로 표현한다면 실제 데이터는 몇 개 없어도 트리의 높이에 해당하는 인덱스를 모두 확보해야 하므로 대부분이 `Null`로 채워져 메모리 낭비가 심합니다.

---
트리의 핵심은 '얼마나 잘 퍼져 있는가'입니다. 

데이터가 들어오는 순서에 따라 편향 트리가 되는 것은 자연스러운 현상이기 때문에, 실무에서는 이를 방지하기 위해 스스로 균형을 잡는 AVL 트리나 Red-Black 트리 같은 자가 균형 이진 탐색 트리를 주로 사용합니다. 

우리가 흔히 쓰는 Java의 TreeMap이나 HashMap의 내부 구조도 최악의 경우를 대비해 이런 균형 트리 기법을 활용하고 있습니다.
# Day 16: 트리(Tree) 기본 개념
> 📅 2025.02.28 | 📁 Week 3

---

## 🧠 학습 질문
- [x] 트리에서 사이클이 없어야 하는 이유는?
- [x] 완전 이진 트리를 배열로 표현할 수 있는 이유는?
- [x] 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?
- [x] 전위/중위/후위 순회는 각각 언제 사용하는가?
- [x] 레벨 순회(Level-order)는 어떻게 구현하는가?
- [x] 편향 트리(Skewed Tree)의 문제점은?

---

## Q1. 트리에서 사이클이 없어야 하는 이유는?

[답변]
* 트리의 정의: 연결 그래프 + 사이클 X
  - 성질: 임의의 두 노드 사이 단순 경로가 정확히 한 개
  - 노드가 n개인 트리는 간선이 n-1개
* 사이클 존재 시, 어떤 노드를 루트에서 따라갈 때 경로가 무한히 반복
  - 부모/자식 관계 모호
  - 계층 구조 표현하기 어려움

---

## Q2. 완전 이진 트리를 배열로 표현할 수 있는 이유는?

[답변]
* 완전 이진 트리: 레벨 순서대로 왼쪽부터 빈칸 없이 채워짐
  - 인덱스로 위치 관계 규칙적으로 계산 가능

---

## Q3. 배열로 표현된 트리에서 부모/자식 인덱스를 계산하는 공식은?

[답변]
* 0-based 인덱스(배열 첫 칸이 0) 기준
  - 인덱스 i인 노드의 
    - 부모: parent(i) = i-1//2  (단, i>0)
    - 왼쪽 자식: left(i) = 2i + 1
	  - 오른쪽 자식: right(i) = 2i + 2
* 1-based 인덱스(배열 첫 칸이 1) 기준
  - 인덱스 i인 노드의 
    - 부모: parent(i) = i//2
	  - 왼쪽 자식: left(i) = 2i
    - 오른쪽 자식: right(i) = 2i + 1

---

## Q4. 전위/중위/후위 순회는 각각 언제 사용하는가?

[답변]
* 전위(Preorder: Root -> Left -> Right)
  - 트리를 '루트부터' 처리
  - ex. 트리 복사/직렬화(루트 먼저 기록), 디렉터리 구조 출력(상위 폴더 먼저 출력)
* 중위(Inorder: Left -> Root -> Right)
  - 이진 탐색 트리에서 중위 순회를 하면 오름차순 정렬 결과를 얻음
  - ex. BST의 모든 값을 정렬된 순서로 출력/검증
* 후위(Postorder: Left -> Right -> Root)
  - 자식 처리가 끝난 뒤 부모 처리
  - ex. 트리 삭제(리프부터 지워야 안전), 수식 트리 평가(피연산자 처리 후 연산)

---

## Q5. 레벨 순회(Level-order)는 어떻게 구현하는가?

[답변]
* 레벨 순회==BFS => Queue로 구헌
* 구현
  - 루트 -> 큐에 push
  - 큐가 빌 때까지 반복:
    - 큐에서 하나 pop, 방문
    - pop한 노드의 왼쪽/오른쪽 자식이 있으면 큐에 push

---

## Q6. 편향 트리(Skewed Tree)의 문제점은?

[답변]
* 한쪽 자식으로만 계속 이어짐 -> 사실상 연결 리스트
* 트리 높이: O(n)
* 탐색/삽입/삭제 연산 -> 균형 트리의 O(logn) 대비 최악인 O(n)
* 재귀 기반 순회/연산할 경우 깊이가 매우 커져 스택 오버플로우 위험 증가
* 해결/완화: 균형 이진 탐색 트리(AVL, Red-Black Tree), 입력 랜덤화, 재균형 전략 적용 등

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

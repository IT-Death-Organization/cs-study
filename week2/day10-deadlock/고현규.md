# Day 10: 동기화와 교착상태(Deadlock)
> 📅 2025.02.22 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 경쟁 상태(Race Condition)는 왜 발생하는가?
- [ ] 임계 영역(Critical Section) 문제의 세 가지 조건은?
- [ ] Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?
- [ ] Binary Semaphore와 Mutex의 차이는?
- [ ] Counting Semaphore는 언제 사용하는가?
- [ ] 교착상태의 4가지 필요조건은?
- [ ] 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?
- [ ] Banker's Algorithm은 어떻게 동작하는가?
---
<br>

# 1. 경쟁 상태(Race Condition)는 왜 발생하는가?

경쟁 상태는 여러 프로세스나 스레드가 동시에 공유 자원에 접근하고, 그 실행 순서에 따라 결과 값이 달라지는 현상을 말합니다.

### 발생 원인
커널 모드에서 데이터를 수정하던 중 인터럽트가 발생하거나, 멀티 스레드 환경에서 여러 스레드가 하나의 변수를 동시에 수정할 때 발생합니다.

예를 들어, 스레드 A가 값을 읽어갔고(Read), A가 이어서 수정(Write)하려 했는데, 그 전에 스레드 B가 먼저 값을 수정해버리면 데이터의 정합성이 깨지게 됩니다.

<br>

# 2. 임계 영역(Critical Section) 문제의 세 가지 조건은?

공유 데이터에 접근하는 코드 영역인 "임계 영역"에서 문제가 생기지 않으려면 다음 세 가지가 반드시 지켜져야 합니다.

1. 상호 배제 (Mutual Exclusion)
    * 한 프로세스가 임계 영역에서 실행 중이면 다른 프로세스는 들어올 수 없습니다.
2. 진행 (Progress)
    * 임계 영역에 아무도 없는데 들어가고 싶어 하는 프로세스가 있다면, 지체 없이 들여보내 줘야 합니다.
3. 한정 대기 (Bounded Waiting)
    * 들어오려고 기다리는 프로세스에게 무한정 기다리게 해서는 안 됩니다. (기아 상태 방지)

<br>

# 3. Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?

> 뮤텍스는 Mutual Exclusion의 약자입니다. 두 메커니즘 모두 동기화를 위한 도구입니다.

| 구분 | Mutex (뮤텍스) | Semaphore (세마포어) |
| :--- | :--- | :--- |
| **개념** | 소유권이 있는 Locking | 개수를 관리하는 Signaling |
| **소유권** | 열쇠를 가진 자만 해제 가능 (Owner 존재) | 소유권 없음 (누구나 신호를 줄 수 있음) |
| **허용 개수** | 오직 1개 (0 또는 1) | 1개 이상 가능 (n개) |
| **사용 상황** | 한 번에 한 명만 접근해야 하는 자원 | 여러 명이 접근 가능한 자원 |

<br>

# 4. Binary Semaphore와 Mutex의 차이는?

둘 다 값이 0과 1만 가질 수 있어 겉보기엔 같아 보이지만, '소유권(Ownership)' 유무가 가장 결정적인 차이입니다.

* Mutex
    * Lock을 건 스레드만이 그 Lock을 풀 수 있습니다.
    * 책임과 권한이 명확합니다.
* Binary Semaphore
    * Lock을 건 스레드와 해제하는 스레드가 달라도 됩니다.
    * 신호를 주고받는 용도에 더 가깝습니다.

<br>

# 5. Counting Semaphore는 언제 사용하는가?

세마포어의 값이 1보다 큰 경우로, 유한한 자원을 여러 프로세스가 나누어 써야 할 때 사용합니다.

### 사용 예시
* 데이터베이스 커넥션 풀(Connection Pool) 관리
    * 만약 커넥션이 10개라면 세마포어 값을 10으로 설정합니다.
    * 10명이 다 쓰면 11번째 사람은 누군가 반납할 때까지 기다리게 됩니다.

<br>

# 6. 교착상태의 4가지 필요조건은?

교착상태는 다음 4가지 조건이 동시에 만족될 때 발생합니다. 하나라도 깨뜨리면 데드락은 발생하지 않습니다.

1. **상호 배제 (Mutual Exclusion):** 자원은 한 번에 한 프로세스만 사용 가능함.
2. **점유와 대기 (Hold and Wait):** 자원을 가진 상태에서 다른 자원을 기다림.
3. **비선점 (No Preemption):** 남이 가진 자원을 강제로 뺏어올 수 없음.
4. **순환 대기 (Circular Wait):** 대기 순서가 원형(Cycle)을 이룸.

친구 둘이서 딱 한칸 남아있는 화장실 앞에서 서로 "너 가면 감" 이라고 말하는 느낌이라고 생각하면 됩니다.

<br>

# 7. 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?

| 방식 | 설명 | 특징 |
| :--- | :--- | :--- |
| **예방 (Prevention)** | 4가지 조건 중 하나를 원천 차단함 | 가장 확실하지만 자원 낭비가 심함 |
| **회피 (Avoidance)** | 데드락 가능성을 검토하여 안전한 경우만 할당 | "은행원 알고리즘"이 대표적 |
| **탐지 (Detection)** | 일단 할당해주고 데드락이 생겼는지 감시함 | 주기적인 체크 오버헤드 발생 |
| **복구 (Recovery)** | 데드락 발견 시 프로세스 종료나 자원 선점 수행 | 희생양 프로세스를 선정해야 함 |

<br>

# 8. Banker's Algorithm은 어떻게 동작하는가?

> 은행원 알고리즘이라고 불리는 이유는 은행이 모든 고객에게 대출을 해줄 때, 최악의 상황(모든 고객이 한꺼번에 최대 대출금을 요구함)을 가정해도 최소 한 명에게는 대출금을 끝까지 지급할 수 있는 상태를 유지하는 원리에서 따왔기 때문입니다.

쉽게 설명하면 어떤 프로세스가 자원을 요청할 때, 자원을 할당해준 후에도 시스템이 여전히 안전한지 미리 시뮬레이션 해보는 것입니다.

이를 통해 안전 상태인지, 불안전 상태인지를 판단합니다.

만약 불안전 상태라면 당장 할당해줄 자원이 있더라도 할당을 거부합니다.

### 동작 방식

* 알고리즘에 필요한 변수
    * **Max**: 각 프로세스가 최대로 요구할 수 있는 자원의 수
    * **Allocation**: 현재 각 프로세스가 보유한 자원의 수
    * **Need**: 각 프로세스가 추가로 요구할 수 있는 자원의 수 (Need = Max - Allocation)
    * **Available**: 현재 시스템에 남아있는 자원의 수

* 안전 상태 판단 로직
    1. **Work** 변수를 **Available**과 동일하게 초기화합니다.
    2. **Finish** 배열을 모두 **False**로 초기화합니다.
    3. **Need**가 **Work**보다 작거나 같은 프로세스를 찾습니다.
    4. 해당 프로세스가 있다면 **Work**에 **Allocation**을 더하고, **Finish**를 **True**로 변경합니다. (끝난 프로세스가 점유하던 자원은 다시 Work로 반환)
    5. 3~4번 과정을 반복합니다.
    6. 모든 프로세스의 **Finish**가 **True**이면 안전 상태, 하나라도 **False**이면 불안전 상태입니다.

하지만 이 알고리즘에 단점이 있습니다.
* 프로세스가 요구하는 최대 자원의 양(Max)을 미리 알아야 하지만, 현대 OS에선 불가능에 가깝습니다.
* 프로세스 수가 가변적이면 적용이 어렵습니다.
* 자원 할당 시 매번 계산을 해야하므로 오버헤드가 큽니다.

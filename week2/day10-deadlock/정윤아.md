# Day 10: 동기화와 교착상태(Deadlock)
> 📅 2025.02.22 | 📁 Week 2

---

## 🧠 학습 질문
- [x] 경쟁 상태(Race Condition)는 왜 발생하는가?
- [x] 임계 영역(Critical Section) 문제의 세 가지 조건은?
- [x] Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?
- [x] Binary Semaphore와 Mutex의 차이는?
- [x] Counting Semaphore는 언제 사용하는가?
- [x] 교착상태의 4가지 필요조건은?
- [x] 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?
- [x] Banker's Algorithm은 어떻게 동작하는가?

---

## Q1. 경쟁 상태(Race Condition)는 왜 발생하는가?

[답변]
* 경쟁 상태: 여러 스레드/프로세스가 공유 자원에 접근할 때, 실행 순서에 따라 결과가 달라질 수 있는 상태
* 읽기/쓰기의 변경 단위랑 실제 실행 단위가 달라서, 각각의 프로세스의 변경이 하나의 단위로 보장되지 않을 때, 다른 프로세스에 의해 그 실행이 덮어씌워질 수 있기 때문에 발생한다. 즉, read-modify-write의 구간이 한 덩어리로 보호되지 않을 때 발생

[보완]
* 예방: 임계 영역으로 묶고 상호배제 적용

---

## Q2. 임계 영역(Critical Section) 문제의 세 가지 조건은?

[답변]
* 임계 영역 문제: 여러 스레드/프로세스가 공유 자원을 동시에 접근할 때, 데이터의 일관성과 정확성을 보장하도록 접근을 제어하는 문제
* 조건
  1. 상호배제(Mutual Exclusion): 한 프로세스가 임계 영역에 들어가면, 다른 프로세스는 들어갈 수 없음
  2. 진행(Progress): 임계 영역이 비어있다면, 임계 영역에 들어갈 프로세스를 정하는 결정이 유한 시간 내 이루어져야 함
  3. 한정 대기(Bounded Waiting): 임계 영역 진입 요청 후 '기아' 상태가 발생하면 안 됨 => 대기 횟수/시간에 상한이 존재해야 함
 
[보완]
* 임계 영역 보호
  - Mutex/Lock: 임계 영역에 한 번에 한 스레드/프로세스만 접근
  - Semaphore: 카운터 기반 동기화 -> 동시 통가 가능 개수 / 신호
  - Monitor: 공유 자원과 그 자원을 다루는 메서드들을 하나의 '동기화된 객체'로 묶음
  - Condition Variable: 특정 조건이 만족될 때까지 잠들었다가 조건이 만족되면 깨움 -> 대기/신호 메커니즘
  - 원자적 연산(atomic): 동시 실행 중에도 중간 상태가 보이지 않도록 하나의 끊김 없는 연산처럼 보장되는 연산

---

## Q3. Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?

[답변]
* Mutex
  - 공유 자원에 대한 상호배제(락) 목적
  - 한 번에 하나만 소유 가능
  - owner 개념이 있어, 락을 건 스레드만 해제 가능
  - 임계 영역 보호
* Semaphore
  - 카운터 기반 동기화 도구
  - 단순 상호배제 뿐 아니라 더 일반적인 동기화(자원 개수 제한, 생산자-소비자, 이벤트/순서 제어)에 사용
  - 동시성 제한 / 이벤트 동기화

[보완]
* 동작
  - 뮤텍스
    1. 스레드가 lock() 호출
    2. 잠금 상태(lock flag/state)를 원자적 연산(CAS, test-and-set 등)으로 unlocked -> locked 시도
    3. 성공: 스레드가 뮤텍스를 '소유' -> 임계 영역 진입
    4. 실패: spin으로 잠깐 반복 시도(스핀락/하이브리드) 또는 커널의 도움으로 대기 큐에 들어가 sleep
    5. 소유 스레드가 unlock() 호출
    6. 잠금 상태를 locked -> unlocked
    7. 대기 큐에 스레드가 있으면 하나를 깨워 다음 소유권 경쟁 진행
  - 세마포어
    (1) wait() / P() / acquire()
      1. 스레드가 wait() 호출
      2. 세마포어 카운터 S를 원자적으로 감소 시도
      3. 감소 결과가 S >= 0: 사용 가능 자원 존재 -> 통과
      4. 감소 결과가 S < 0: 자원 없음 -> 해당 스레드를 대기 큐에 넣고 블록
    (2) signal() / V() / release()
      1. 스레드가 signal() 호출
      2. 카운터가 S를 원자적으로 증가
      3. 증가 후에도 대기자가 존재하는 상태면
         - 대기 큐에서 스레드 하나 꺼내 깨움(wakeup)
         - 깨워진 스레드는 wait()에서 빠져나와 진행

---

## Q4. Binary Semaphore와 Mutex의 차이는?

[답변]
* Binary Semaphore(이진 세마포어)
  - 값이 0/1인 세마포어
  - 한 번에 1개만 허용해서 Mutex처럼 보일 수 있으나, Mutex와 달리 다른 스레드가 값을 변경할 수 있음
  - 획득 스레드와 해제 스레드가 다를 수 있어 신호/이벤트 전달에 사용
* Mutex
  - 락의 '소유자' 개념이 존재해 락을 획득한 스레드만 해제 가능
  - 우선순위 상속같은 메커니즘을 제공

---

## Q5. Counting Semaphore는 언제 사용하는가?

[답변]
* Counting Semaphore
  - 카운터 값 S: '현재 사용 가능한 자원 개수'
  - wait/acquire -> S를 1 감소
    - S==0이면 스레드 대기(블록)
  - signal/release -> S를 1 증가
    - 대기 중인 스레드가 있으면 깨워서 진행
* 사용하는 경우
  - 동시 접근 가능한 자원 인스턴스가 여러 개일 때 사용
  - 대표 사례
    - 커넥션 풀
    - 버퍼/큐 슬롯 수 제한
    - 동시 작업 수 제한

---

## Q6. 교착상태의 4가지 필요조건은?

[답변]
* 프로세스/스레드의 교착 상태(Deadlock) 발생의 4가지 조건
1. 상호배제(Mutual Exclusion): 자원을 한 번에 한 스레드/프로세스만 사용할 수 있음
2. 점유와 대기(Hold and Wait): 이미 자원을 점유한 상태에서, 추가적으로 자원을 요청 및 대기
3. 비선점(No Preemption): 할당된 자원을 강제로 빼앗을 수 없음(자발적 해제만 가능)
4. 순환 대기(Circular Wait): 프로세스들이 원형으로 서로가 가진 자원을 기다림
=> 4가지 모두 만족해야 교착 상태 발생

[의문]
* 다 쓴 자원을 놓아주고 다른 자원을 요청하면 교착상태가 발생할 일이 없지 않나? 왜 자원을 점유한 상태에서 다른 자원을 요청해야 하는가?
  - 점유하던 자원을 다 쓰지 않은 상태에서 추가적으로 자원을 요구할 수 있음

---

## Q7. 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?

[답변]
* 예방(Prevention): 교착상태 4가지 조건 중 하나 이상이 절대 성립하지 않도록 시스템 설계
  - 장점: 교착 상태가 원천적으로 발생하지 않음
  - 단점: 자원 활용률/동시성이 떨어질 수 있고 제약이 큼
    1. 점유와 대기 제거: 한 번에 다 요청하거나 없으면 아무 것도 잡지 마라 / 점유한 자원이 있으면 추가 요청 금지
    2. 비선점 깨기: 강제로 뺏기 -> 롤백/복구 메커니즘 필요 -> 비용 발생
    3. 순환 대기 제거: 락/자원 획득 순서 강제 -> 순서 강제로 인해 필요하지도 않은 낮은 순서 자원 기다림
    4. 상호배제 깨기: 공유를 없애거나 동시에 사용 -> 적용 범위가 제한적, 시스템 구조에 큰 제약
* 회피(Avoidance): 실행 중 자원 할당 시 시스템이 안전 상태(safe state)를 유지하는 할당만 허용(대표: Banker’s Algorithm)
  - 장점: 예방보다 보통 자원 활용이 좋음
  - 단점: 프로세스의 최대 요구량 같은 사전 정보가 필요하고, 판단 비용이 듦
  - '안전 상태': '안전 순서'가 존재하는 상태 => 특정 순서로 프로세스를 선택했을 때, 각 단계에서 그 프로세스의 Need가 현재 Available한 자원으로 충족되고, 해당 자원을 반납해서 다음 프로세스도 같은 방식으로 완료할 수 있는 상태
* 탐지(Detection): 교착상태가 '발생할 수 있음'을 허용하되, 주기적으로 교착상태를 탐지
  - 장점: 제약이 적고 활용률이 높을 수 있음
  - 단점: 탐지 오버헤드가 있고, 발견 후 처리 필요
* 복구(Recovery): 탐지 후 교착상태를 해소(프로세스 종료, 롤백, 자원 선점 등)
  - 장점: 교착상태를 실제로 풀어냄
  - 단점: 작업 손실, 롤백 비용, 사용자 영향 가능

---

## Q8. Banker's Algorithm은 어떻게 동작하는가?

[답변]
* Banker's Algorithm
  - 자원 할당 요청이 들어올 때마다 “지금 이 요청을 승인해도 시스템이 안전 상태로 남는가?”를 검사
  - 안전하면 승인, 아니면 보류
* 동작
  1. 각 프로세스에 대해 최대 요구량(Max)을 알고 있다고 가정
  2. 현재 할당량(Allocation), 남은 필요량(Need = Max - Allocation), 가용 자원(Available)을 관리
  3. 어떤 요청(Request)이 들어오면, 일단 가상으로 자원을 할당해 본 뒤, 안전성 검사(Safety Check)를 수행
  4. 안전성 검사에서 “모든 프로세스가 어떤 순서로든 최종 완료될 수 있는 순서(안전 순서, safe sequence)가 존재”하면 승인, 없으면 요청을 대기

[보완]
* 안정성 검사
  1. Work = Available로 복사
  2. 모든 i에 대해 Finish[i] = false로 초기화
  3. 다음을 반복
     - 아직 Finish[i] = false인 프로세스 중 Need[i] <= Work를 만족하는 i 탐색
     - 그런 i가 존재하면 지금 가진 Work로 끝낼 수 있다고 가정:
       - Work = Work + Allocation[i] (i가 끝나며 자원을 반납한다고 가정)
       - Finish[i] = true
     - 그런 i가 존재하지 않으면 반복 중단
  4. 최종적으로 모든 i에 대해 Finish[i] = true 면 안전 순서가 존재 -> 안전 상태
     - 하나라도 false면 불안전 상태

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

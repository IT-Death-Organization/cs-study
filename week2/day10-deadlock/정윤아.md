# Day 10: 동기화와 교착상태(Deadlock)
> 📅 2025.02.22 | 📁 Week 2

---

## 🧠 학습 질문
- [x] 경쟁 상태(Race Condition)는 왜 발생하는가?
- [x] 임계 영역(Critical Section) 문제의 세 가지 조건은?
- [x] Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?
- [x] Binary Semaphore와 Mutex의 차이는?
- [x] Counting Semaphore는 언제 사용하는가?
- [x] 교착상태의 4가지 필요조건은?
- [x] 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?
- [x] Banker's Algorithm은 어떻게 동작하는가?

---

## Q1. 경쟁 상태(Race Condition)는 왜 발생하는가?

[답변]
* 경쟁 상태: 여러 스레드/프로세스가 공유 자원에 접근할 때, 실행 순서에 따라 결과가 달라질 수 있는 상태
* 읽기/쓰기의 변경 단위랑 실제 실행 단위가 달라서, 각각의 프로세스의 변경이 하나의 단위로 보장되지 않을 때, 다른 프로세스에 의해 그 실행이 덮어씌워질 수 있기 때문에 발생한다. 즉, read-modify-write의 구간이 한 덩어리로 보호되지 않을 때 발생

[보완]
* 예방: 임계 영역으로 묶고 상호배제 적용

---

## Q2. 임계 영역(Critical Section) 문제의 세 가지 조건은?

[답변]
* 임계 영역 문제: 여러 스레드/프로세스가 공유 자원을 동시에 접근할 때, 데이터의 일관성과 정확성을 보장하도록 접근을 제어하는 문제
* 조건
  1. 상호배제(Mutual Exclusion): 한 프로세스가 임계 영역에 들어가면, 다른 프로세스는 들어갈 수 없음
  2. 진행(Progress): 임계 영역이 비어있다면, 임계 영역에 들어갈 프로세스를 정하는 결정이 유한 시간 내 이루어져야 함
  3. 한정 대기(Bounded Waiting): 임계 영역 진입 요청 후 '기아' 상태가 발생하면 안 됨 => 대기 횟수/시간에 상한이 존재해야 함

---

## Q3. Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?

[답변]
* Mutex
  - 공유 자원에 대한 상호배제(락) 목적
  - 한 번에 하나만 소유 가능
  - owner 개념이 있어, 락을 건 스레드만 해제 가능
  - 임계 영역 보호
* Semaphore
  - 카운터 기반 동기화 도구
  - 단순 상호배제 뿐 아니라 더 일반적인 동기화(자원 개수 제한, 생산자-소비자, 이벤트/순서 제어)에 사용
  - 동시성 제한 / 이벤트 동기화

[보완]
* 구현
  - 뮤텍스
    - 공유 잠금 상태를 원자적 CAS(Compare-And-Swap) 같은 연산으로 획득
    - 경합 시 대기 큐에 넣어 한 스레드만 통과
  - 세마포어
    - 정수 카운터를 원자적으로 감소/증가 (wait/signal)
    - 값이 부족하면 대기 큐에서 블록
    - 반환 시 대기자를 깨움

---

## Q4. Binary Semaphore와 Mutex의 차이는?

[답변]
* Binary Semaphore(이진 세마포어)
  - 값이 0/1인 세마포어
  - 한 번에 1개만 허용해서 Mutex처럼 보일 수 있으나, Mutex와 달리 다른 스레드가 값을 변경할 수 있음
  - 획득 스레드와 해제 스레드가 다를 수 있어 신호/이벤트 전달에 사용
* Mutex
  - 락의 '소유자' 개념이 존재해 락을 획득한 스레드만 해제 가능
  - 우선순위 상속같은 메커니즘을 제공

---

## Q5. Counting Semaphore는 언제 사용하는가?

[답변]
* Counting Semaphore
  - 카운터 값 S: '현재 사용 가능한 자원 개수'
  - wait/acquire -> S를 1 감소
    - S==0이면 스레드 대기(블록)
  - signal/release -> S를 1 증가
    - 대기 중인 스레드가 있으면 깨워서 진행
* 사용하는 경우
  - 동시 접근 가능한 자원 인스턴스가 여러 개일 때 사용
  - 대표 사례
    - 커넥션 풀
    - 버퍼/큐 슬롯 수 제한
    - 동시 작업 수 제한

---

## Q6. 교착상태의 4가지 필요조건은?

[답변]
* 프로세스/스레드의 교착 상태(Deadlock) 발생의 4가지 조건
1. 상호배제(Mutual Exclusion): 자원을 한 번에 한 스레드/프로세스만 사용할 수 있음
2. 점유와 대기(Hold and Wait): 이미 자원을 점유한 상태에서, 추가적으로 자원을 요청 및 대기
3. 비선점(No Preemption): 할당된 자원을 강제로 빼앗을 수 없음(자발적 해제만 가능)
4. 순환 대기(Circular Wait): 프로세스들이 원형으로 서로가 가진 자원을 기다림
=> 4가지 모두 만족해야 교착 상태 발생

---

## Q7. 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?

[답변]
* 예방(Prevention): 교착상태 4가지 조건 중 하나 이상이 절대 성립하지 않도록 시스템 설계
  - 장점: 교착 상태가 원천적으로 발생하지 않음
  - 단점: 자원 활용률/동시성이 떨어질 수 있고 제약이 큼(예: 자원 요청 순서 강제)
* 회피(Avoidance): 실행 중 자원 할당 시 시스템이 안전 상태(safe state)를 유지하는 할당만 허용(대표: Banker’s Algorithm)
  - 장점: 예방보다 보통 자원 활용이 좋음
  - 단점: 프로세스의 최대 요구량 같은 사전 정보가 필요하고, 판단 비용이 듦
* 탐지(Detection): 교착상태가 '발생할 수 있음'을 허용하되, 주기적으로 교착상태를 탐지
  - 장점: 제약이 적고 활용률이 높을 수 있음
  - 단점: 탐지 오버헤드가 있고, 발견 후 처리 필요
* 복구(Recovery): 탐지 후 교착상태를 해소(프로세스 종료, 롤백, 자원 선점 등)
  - 장점: 교착상태를 실제로 풀어냄
  - 단점: 작업 손실, 롤백 비용, 사용자 영향 가능

---

## Q8. Banker's Algorithm은 어떻게 동작하는가?

[답변]
* Banker's Algorithm
  - 자원 할당 요청이 들어올 때마다 “지금 이 요청을 승인해도 시스템이 안전 상태로 남는가?”를 검사
  - 안전하면 승인, 아니면 보류
* 동작
  1. 각 프로세스에 대해 최대 요구량(Max)을 알고 있다고 가정
  2. 현재 할당량(Allocation), 남은 필요량(Need = Max - Allocation), 가용 자원(Available)을 관리
  3. 어떤 요청(Request)이 들어오면, 일단 가상으로 자원을 할당해 본 뒤, 안전성 검사(Safety Check)를 수행
  4. 안전성 검사에서 “모든 프로세스가 어떤 순서로든 최종 완료될 수 있는 순서(안전 순서, safe sequence)가 존재”하면 승인, 없으면 요청을 대기

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

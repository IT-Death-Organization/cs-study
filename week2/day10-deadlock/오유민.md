# Day 10: 동기화와 교착상태(Deadlock)

> 📅 2025.02.22 | 📁 Week 2

---

## 🧠 학습 질문

- [x] 경쟁 상태(Race Condition)는 왜 발생하는가?
- [x] 임계 영역(Critical Section) 문제의 세 가지 조건은?
- [x] Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?
- [x] Binary Semaphore와 Mutex의 차이는?
- [x] Counting Semaphore는 언제 사용하는가?
- [x] 교착상태의 4가지 필요조건은?
- [x] 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?
- [x] Banker's Algorithm은 어떻게 동작하는가?

---

### 📌 [Q1] 경쟁 상태(Race Condition)는 왜 발생하는가?

경쟁 상태는 여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 실행 순서에 따라 결과가 달라지는 상황을 말한다. (공유 자원을 동기화 없이 동시에 수정)
즉, 누가 먼저 실행되느냐에 따라 실행 결과가 매번 바뀌어 예측 불가능한 상태가 되는 것이다.

경쟁 상태는 보통 다음 3가지 조건이 겹칠 때 발생한다.
**1. 공유 자원이 있을 때**

- 여러 스레드/프로세스가 같은 데이터(메모리 공간, 변수, 파일 등)를 함께 사용

**2. 연산이 atomic하지 않을 때**

- 우리가 작성하는 한 줄의 코드(ex. count++)가 실제 CPU에서는 여러 단계의 명령어로 나뉘어 실행된다.
  - 1. 메모리에서 count 값을 읽어옴 (read)
  - 2. 값을 1 증가시킴 (modify)
  - 3. 결과를 메모리에 다시 저장 (write)
- 이 여러 단계들 사이에 다른 스레드가 끼어들 수 있다.

**3. 선점형 스케줄링 (동기화 x)**

- OS가 한 스레드의 작업을 도중에 멈추고, 다른 스레드로 CPU 제어권을 넘기는 context switching이 언제든 일어날 수 있다. (멀티 스레드 환경에서는 OS가 CPU를 번갈아가면서 할당)

### 📌 [Q2] 임계 영역(Critical Section) 문제의 세 가지 조건은?

임계 영역은 **공유 자원에 접근하거나 수정하는 코드 영역**으로, **여러 스레드/프로세스가 동시에 실행될 때, 동시에 실행되면 안 되는 위험한 코드 부분**이다.

임계 영역 문제를 해결하고 데이터의 일관성을 보장하기 위해서는 반드시 다음 세 가지 조건을 모두 충족해야 한다.

**1. 상호 배제 (Mutual Exclusion)**
: 한 번에 하나의 프로세스/스레드만 임계 영역에 들어갈 수 있어야 한다.

- 어떤 프로세스가 자신의 임계 영역 내에서 실행 중이라면, 다른 프로세스들은 이 임계 영역에 진입할 수 없어야 한다.
- 한 번에 하나의 프로세스만 공유 자원을 사용할 수 있도록 lock을 거는 개념
  -> 데이터 손상을 방지

**2. 진행 (Progress)**
: 임계 영역에서 실행 중인 프로세스가 없고, 들어가려는 프로세스들만 있다면 이들 중 누군가는 반드시 들어갈 수 있어야 한다. (어떤 프로세스가 진입할지 결정하지 못하면 안 된다.)

- "들어가도 되는데 아무도 못 들어가는 상황"이 발생하면 안 됨
- 시스템이 멈추지 않고 계속 작동하는지를 보장하는 개념 (활성성)
  -> 불필요한 대기를 방지

**3. 한정 대기 (Bounded Waiting)**
: 어떤 프로세스가 임계 영역 진입을 요청한 후 ~ 그 요청이 허용될 때까지, 무한히 기다리면 안 된다.

- 기아 상태(starvation)를 방지하기 위한 조건
- 요청 후에는 유한한 횟수 내에 반드시 임계 영역에 진입해야 함
  -> 기아 상태를 방지

### 📌 [Q3] Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?

뮤텍스와 세마포어는 모두 임계 영역 문제를 해결하기 위한 동기화 도구이다.
이 둘은 "누가 자원을 소유할 수 있는가"와 "동시 접근 허용 범위가 어디까지인가"에서 큰 차이가 있다.

**Mutex**

- Binary Lock (0 또는 1)
- 오직 1개의 프로세스/스레드만 임계 영역 진입 가능
- lock을 건 스레드만 unlock 가능 (소유권 있음) -> lock을 획득한 스레드가 반드시 그 lock을 해제해야 함!
- **상호 배제**를 목적으로 사용
- 사용하는 경우
  - 공유 변수 수정 시 (여러 스레드가 동시에 하나의 변수를 수정할 때, 데이터 오염을 막기 위해)
  - 단일 자원 보호
  - 임계 영역 보호
  - 한 번에 하나만 실행되어야 할 때
  - 데이터 무결성이 중요할 때

```
lock();
critical section
unlock();
```

**Semaphore**

- Signaling (카운트 기반)
- N개의 프로세스/스레드 동시 접속 가능
- 소유권 개념 없음, 누구나 signal을 보내 해제 가능 (A가 락을 걸고 B가 해제할 수도 있음)
- 세마포어 카운트(S)가 0보다 크면 자원을 할당하고, 0이면 대기
- 자원 개수 관리 목적
- 사용하는 경우
  - 한정된 자원 관리 (DB 커넥션 풀처럼 동시에 접속 가능한 연결 수를 제한해야 할 때)
  - 실행 순서 제어/동기화 (A가 끝나고 B가 시작되어야 한다는 signal을 주고받을 때)
  - 동시 접근 허용 개수가 있을 때
  - 자원의 개수 제한하고 싶을 때

```
wait();   // P 연산
critical section
signal(); // V 연산
```

**정리** <br>
Mutex는 한 번에 하나의 스레드만 임계 영역에 진입하도록 하는 상호 배제 도구이며, Lock을 건 스레드만 해제할 수 있는 소유권 개념이 있습니다.
Semaphore는 정수 값을 기반으로 여러 스레드의 동시 접근을 제어하며, 자원의 개수를 관리할 때 사용됩니다.

### 📌 [Q4] Binary Semaphore와 Mutex의 차이는?

이진 세마포어와 뮤텍스는 **값으로 0 또는 1만을 가지고 한 번에 하나만 접근 가능하다는 공통점이 있지만, 소유권 여부에서 차이가 있다.**

**이진 세마포어**

- 동기화 도구로, signaling을 사용한다.
- **소유권 개념이 없어 누구나 해제(signal)가 가능**하다.
  - 스레드 A가 Wait(P)를 호출해 자원을 점유했어도, 스레드 B가 Signal(V)를 호출해 자원을 해제할 수 있다. (wait()한 스레드와 signal()한 스레드가 달라도 됨)
- 우선순위 역전 문제 해결이 불가능하다. (우선순위 상속 불가)
- 실행 순서 제어를 위해 사용한다. (준비되면 알려줘!)

**뮤텍스**

- Locking 매커니즘이다. (자원 점유)
- 소유권이 있어 lock을 건 스레드만 해제 가능하다.
- **상속을 지원해 우선순위 역전 문제 해결이 가능하다.**
- 상호 배제를 위해 사용한다. (한 명만 들어와!)

**우선순위 역전(Priority Inversion) 문제란?**

- **뮤텍스**는 소유권 개념이 있기 때문에 **우선순위 상속** 기법을 사용할 수 있다.
  - 낮은 우선순위의 스레드가 뮤텍스를 가진 상태에서 높은 우선순위의 스레드가 대기 -> OS는 낮은 우선순위 스레드의 등급을 잠시 높여 작업을 빨리 끝내게 도움
- 반면, **이진 세마포어**는 소유권 개념이 없으므로 누가 자원을 빨리 놓아줘야 하는지 알 수 없어 우선순위 역전 문제를 해결하기 어려움

### 📌 [Q5] Counting Semaphore는 언제 사용하는가?

**0 이상의 정수 값을 가지는 세마포어로, 동시에 접근 가능한 자원의 개수를 관리**하는 도구이다. (초기값 = 사용 가능한 자원의 개수)

카운팅 세마포어는 다음과 같은 경우에 사용한다.
**1. 한정된 자원 풀 관리**
: 정해진 개수의 자원이 있고, 여러 프로세스가 이를 나누어 써야 할 때 사용 (동시에 N개까지 허용해야 하는 경우)

- DB 커넥션 풀 (동시에 DB에 연결할 수 있는 프로세스 수를 제한)
- HTTP 커넥션 풀
- API 요청 제한
- 예약 시스템 (도서관/강의실 등)

```
semaphore = 3  // 자원 3개까지만 동시 접근 가능

wait()   // 자원 하나 사용
signal() // 자원 하나 반납
```

**2. 생산자-소비자 문제 (Producer-Consumber Problem)**
: 버퍼의 크기가 여러 개(n)인 환경에서 생산자와 소비자 간의 속도 차이를 조절하기 위해 사용 (empty = N, full = 0)

- Full 세마포어: 현재 버퍼에 차 있는 데이터의 개수 (소비자가 사용)
- Empty 세마포어: 현재 비어 있는 버퍼의 공간 개수 (생산자가 사용)
  -> 이를 통해 버퍼가 가득 찼을 때 생산자가 더 이상 생산하지 못하게 하거나, 버퍼가 비었을 때 소비자가 기다리도록 조절함

**3. 동시 실행 제어 (throttling)**
: 시스템의 과부하를 막기 위해 특정 작업의 동시 실행 횟수를 제한할 때

### 📌 [Q6] 교착상태의 4가지 필요조건은?

**교착 상태 = Deadlock**
데드락이 발생하기 위해서는 4가지 조건이 충족되어야 한다.

**1. 상호 배제 (Mutual Exclusion)**

- 자원은 한 번에 한 프로세스만 사용 가능해야 함, 공유 불가 (만약 다른 프로세스가 그 자원을 사용하려고 한다면, 자원이 해제될 때까지 대기해야 하는 상태)
- ex) 파일 쓰기, mutex lock

**2. 점유와 대기 (Hold and Wait)**

- 이미 자원을 하나 이상 점유한 상태에서 다른 자원을 추가로 기다리는 상태 (다른 프로세스에 할당되어 있는 자원을 점유하기 위해 대기하는 프로세스가 있어야 함)
- ex) 왼손에 포크를 든 채로, 다른 사람이 든 나이프가 날 때까지 기다림

**3. 비선점 (No Preemption)**

- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없음
- 자원을 사용 중인 프로세스가 자발적으로 반환해야만 다른 프로세스가 사용 가능 (OS가 강제로 뺏지 못함)

**4. 순환 대기 (Circular Wait)**

- 대기 중인 프로세스들은 원형(순환) 구조로 서로의 자원을 기다려야 함
  - A → B의 자원 기다림
  - B → C의 자원 기다림
  - C → A의 자원 기다림

### 📌 [Q7] 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?

**1. 예방**

- 데드락이 절대 발생하지 않도록 구조적으로 차단 (보수적)
- 데드락의 4가지 필요조건 중 하나라도 발생하지 않도록 설계를 변경
  - 순환 대기 제거 → 자원 요청 순서 강제
  - 점유 대기 제거 → 자원 한 번에 모두 요청
  - 비선점 제거 → 자원 강제 회수
- 데드락 절대 발생하지 않도록 보장하지만, 자원 낭비 심함 & 시스템 성능(처리량) 떨어짐 & 기아 상태 발생 가능

**2. 회피**

- 시스템이 자원을 할당할 때마다 "이 자원을 줬을 때, 나중에 데드락이 생길 가능성이 있는가?"를 동적으로 체크하고, 안전 상태(Safe State)를 유지할 수 있을 때만 자원 할당
- 대표 알고리즘: **은행가 알고리즘 (Banker's Algorithm)** -> 자원 종류가 여러 개일 때 사용
- 예방보다는 덜 엄격하고 자원 효율성이 높지만, 프로세스가 사용할 최대 자원량 미리 알아야 함 (계산 비용이 큼)

**3. 탐지**

- 데드락 발생을 허용하되, 데드락이 발생했는지 주기적으로 검사
- 방법: 자원 할당 그래프를 분석해 cycle이 형성되었는지 확인
- 자원 요청 시 아무런 제한을 두지 않아 성능 저하 적음 (구현 단순) but 탐지 알고리즘을 실행하는 데 오버헤드 발생(탐지 비용) & 데드락 발생 가능

**4. 복구**

- 탐지를 통해 데드락을 발견한 후, 이를 해결하는 단계
- 방법
  - 1. 프로세스 강제 종료 (데드락에 빠진 프로세스를 모두 죽이거나, 하나씩 죽여보며 해결되는지 확인)
  - 2. 자원 선점 (데드락에 빠진 프로세스가 가진 자원을 강제로 회수해 다른 프로세스에게 할당 -> 이때 희생될 프로세스를 선정하는 "희생자 선택" 문제 발생)

### 📌 [Q8] Banker's Algorithm은 어떻게 동작하는가?

Banker's Algorithm은 다익스트라가 제안한 **데드락 회피의 대표적인 알고리즘**으로, 자원을 빌려주는 은행처럼 **안전한 경우(Safe State)에만 자원을 할당**하는 알고리즘이다.

**1. 기본 가정**

- 각 프로세스는 최대 자원 요구랑을 미리 알려야 한다.
  - Available: 각 종류별 가용한 자원의 개수 (벡터)
  - Max: 각 프로세스가 실행을 위해 최대로 필요로 하는 자원의 개수 (행렬)
  - Allocation: 현재 각 프로세스에 할당된 자원의 개수 (행렬)
  - Need: 각 프로세스가 작업을 끝내기 위해 추가로 필요한 자원의 개수 (행렬) / 앞으로 필요한 자원 -> $Need = Max - Allocation$
- 안전 상태 (Safe State): 어떤 순서로든 모든 프로세스가 자원을 받고 정상 종료할 수 있는 상태 (안전 순서(Safe Sequence)가 존재하면 안전 상태)

**2. 동작 과정**
어떤 프로세스가 자원을 요청하면

1. 요청이 Need보다 작은지 확인 (초과 요청이면 거절)
2. 요청이 현재 Available보다 작은지 확인 (자원이 없으면 대기)
3. 일단 자원을 준다고 가정하고 안정성 검사 (Available 감소, Allocation 증가, Need 감소)
4. 그 다음 알고리즘 실행

- 변수 Work = Available
- Finish[i] = false (모든 프로세스)
- Need ≤ Work 인 프로세스를 찾음 (즉, 아직 완료되지 않았고 현재 가용 자원으로 해결 가능한 프로세스를 찾음)
- 찾으면:
  - Work += Allocation (그 프로세스가 작업 끝냈다고 가정하고 점유 중이던 자원을 모두 반납받음)
  - Finish[i] = true (Finish: 모든 프로세스의 완료 여부, 해당 프로세스 완료 처리)
- 모든 프로세스가 Finish=true 되면 안전
  👉 하나라도 못 끝내면 불안전 상태 (Unsafe State)

---

## 📎 참고 자료

## <!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 10: 동기화와 교착상태(Deadlock)
> 📅 2025.02.22 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 경쟁 상태(Race Condition)는 왜 발생하는가?
- [x] 임계 영역(Critical Section) 문제의 세 가지 조건은?
- [x] Mutex와 Semaphore의 차이는? 각각 언제 사용하는가?
- [x] Binary Semaphore와 Mutex의 차이는?
- [x] Counting Semaphore는 언제 사용하는가?
- [x] 교착상태의 4가지 필요조건은?
- [x] 교착상태 해결 방법(예방, 회피, 탐지, 복구)의 차이는?
- [x] Banker's Algorithm은 어떻게 동작하는가?
---
# 운영체제 동기화 & 교착상태 정리

---

## 1. 경쟁 상태 (Race Condition)

### 정의
여러 스레드/프로세스가 공유 자원(shared resource)에 동시에 접근하고, 실행 순서에 따라 결과가 달라지는 상황.

### 발생 원인
- 공유 변수 존재
- 원자적(atomic)이지 않은 연산 수행
- 동기화 부재

### 예시
`count++` 연산은 실제로 3단계로 분리된다.

```
load  count
add   1
store count
```

두 스레드가 동시에 실행하면 값이 꼬이는 문제가 발생한다.

> **본질:** 공유 자원 + 비원자적 연산 + 동시 실행

---

## 2. 임계 영역 (Critical Section) 문제의 3가지 조건

**임계 영역이란:** 공유 자원에 접근하는 코드 영역.  
올바르게 설계하려면 아래 3가지 조건을 만족해야 한다.

### 1) Mutual Exclusion (상호 배제)
한 번에 하나의 프로세스만 임계 영역에 진입 가능.

### 2) Progress (진행)
임계 영역에 아무도 없으면, 진입을 원하는 프로세스 중 하나는 반드시 선택되어야 함. 무한 대기 금지.

### 3) Bounded Waiting (한정 대기)
어떤 프로세스도 무한정 기다리면 안 됨. 기아(starvation) 방지.

---

## 3. Mutex vs Semaphore

| 구분 | Mutex | Semaphore |
|------|-------|-----------|
| 개념 | 상호 배제용 락 | 동기화용 카운터 |
| 값 | 0 / 1 | 0 이상 정수 |
| 소유권 | 있음 (owner 존재) | 없음 |
| 사용 목적 | 임계 영역 보호 | 자원 개수 제어 |

### Mutex를 사용하는 경우
- 하나의 공유 자원 보호
- 스레드 동기화, 락 소유 개념이 필요한 경우

```
lock();
  // critical section
unlock();
```

### Semaphore를 사용하는 경우
- 여러 개의 동일 자원 관리
- Producer-Consumer 패턴
- 자원 개수 제한

---

## 4. Binary Semaphore vs Mutex

겉보기엔 둘 다 0/1이지만 본질적으로 다르다.

| 구분 | Mutex | Binary Semaphore |
|------|-------|-----------------|
| 소유권 | 있음 | 없음 |
| 해제 가능 주체 | 락을 획득한 스레드만 | 아무나 |
| 목적 | 상호 배제 | 동기화 |

> **결론:** Mutex는 락(lock), Binary Semaphore는 신호기(signal)

---

## 5. Counting Semaphore

값이 0 이상의 정수이며, 자원 개수를 제한할 때 사용한다.

### 사용 예
- 프린터 3대 관리
- DB 커넥션 풀 10개 제한
- 스레드 풀 제한

```
wait();    // 자원 요청 (값 감소)
signal();  // 자원 반환 (값 증가)
```

---

## 6. 교착상태 (Deadlock)의 4가지 필요조건

4가지가 **모두** 만족되어야 Deadlock이 발생 가능하다.

### 1) Mutual Exclusion (상호 배제)
자원은 한 번에 하나의 프로세스만 사용 가능.

### 2) Hold and Wait (점유 대기)
자원을 가진 상태에서 다른 자원을 기다림.

### 3) No Preemption (비선점)
자원을 강제로 빼앗을 수 없음.

### 4) Circular Wait (순환 대기)
자원 요청이 원형 구조로 연결됨.

```
P1 → R1 → P2 → R2 → P1
```

> **4가지 중 하나라도 깨지면 Deadlock은 발생하지 않는다.**

---

## 7. 교착상태 해결 방법

### 1) 예방 (Prevention)
4가지 조건 중 하나를 원천 차단.  
예: 자원 선점 허용.  
단점: 자원 활용도가 낮아짐.

### 2) 회피 (Avoidance)
안전 상태(safe state)를 항상 유지.  
Banker's Algorithm 사용.  
단점: 계산 비용이 큼.

### 3) 탐지 (Detection)
Deadlock 발생을 허용하고, 주기적으로 검사.

### 4) 복구 (Recovery)
Deadlock 탐지 후 프로세스를 종료하거나 자원을 회수.

---

## 8. Banker's Algorithm

### 목적
시스템이 항상 **Safe State**를 유지하도록 자원을 할당.

### 핵심 개념

```
Need       = Max - Allocation
Available  = 현재 남은 자원
```

### 동작 단계

1. 프로세스가 자원을 요청
2. 요청을 가상으로 할당
3. Safe Sequence가 존재하는지 검사

### Safe Sequence란?
모든 프로세스를 순서대로 종료시킬 수 있는 실행 순서.

### 검사 방법

```
Work     = Available
Finish[] = false

반복:
  Need[i] <= Work 인 프로세스 i를 찾는다
  Work    += Allocation[i]
  Finish[i] = true

모든 Finish[i] = true 이면 → Safe State
```

> **본질:** "이 요청을 허용해도 시스템이 교착 상태에 빠지지 않는가?"
## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

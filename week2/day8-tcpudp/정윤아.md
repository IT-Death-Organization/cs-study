# Day 8: TCP vs UDP
> 📅 2025.02.20 | 📁 Week 2

---

## 🧠 학습 질문
- [x] TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?
- [x] TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)
- [x] 3-way handshake의 동작 과정과 존재 이유는?
- [x] 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?
- [x] 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?
- [x] Sliding Window는 어떻게 동작하는가?
- [x] UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)

---

## Q1. TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?

[답변]
* TCP(Transform Control Protocol)
  - 연결 지향: 통신 전에 연결을 수립
  - 신뢰성 보장: 손실/중복/순서 제어 -> 정확한 전달
  - 흐름/혼잡 제어 제공: 수신자 처리 능력, 네트워크 혼잡도 고려 -> 전송 속도 조절
  - 사용 상황: 데이터의 신뢰성이 중요한 경우
    - HTTP/HTTPS
    - FTP/SFTP
    - SMTP/IMAP/POP3
    - DB 통신
* UDP(User Datagram Protocol)
  - 비연결: 연결 수립 없이 즉시 전송
    - '즉시': 애플리케이션의 send 호출과 동시에 데이터그램 생성 -> IP 계층 전달 (연결 절차 X)
  - 신뢰성 기능 제공 X: 손실/중복/순서를 프로토콜 자체에서 책임 X. 필요 시 애플리케이션에서 구현
  - 오버헤드, 지연 적음: 빠른 통신에 유리
  - 사용 상황
    - 지연이 중요하거나, 약간의 손실 허용하는 경우: 실시간 스트리밍/게임/VolP
    - 질의-응답이 가볍고 빠른 경우: DNS 등

[보완]
* DNS를 UDP로 수행하는 이유
  - DNS는 매우 빈번하고, 질의-응답이 보통 작고 1회성 -> 연결 수립의 부담이 크고 비효율적
  - 손실 발생 시: DNS 프로토콜/구현 상에서 재시도
  - 응답이 크거나 영역 전송인 경우 TCP로 수행
* 리졸버
  - DNS에서 도메인 이름 -> IP 주소 변환을 위한 질의 전송과 응답 수신을 담당
  - 스텁 리졸버: 간단한 DNS 클라이언트. 질의를 재귀 리졸버에 전달하고, 결과를 받아 애플리케이션에 전달
  - 재귀 리졸버: 사용자를 대신해 경로(루트 -> TLD -> 권한 서버)를 따라가며 조회 -> 최종 정답 반환. 캐시 보유

---

## Q2. TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)

[답변]
* 시퀀스 번호: 바이트의 순서 식별
* ACK: 수신자가 수신한 패킷에 대한 정보 반환
* 재전송: 손실 감지(timeout 등) 시 재전송
* 순서 보장: 순서가 바뀐 도착 패킷을 정렬 -> 상위로 전달

[보완]
* 동작
  1. 송신자: 데이터에 시퀀스 번호 부여 -> 전송
  2. 수신자: 받은 데이터의 시퀀스 번호가 연속되는 구간 확인 -> 기대 번호를 ACK로 회신
  3. 송신자: 일정 시간 내 ACK를 못 받거나(타임아웃) 손실 징후 보일 시 재전송
    - 손실 징후: 중복 ACK, SACK를 통한 누락 확인
  4. 수신자: 순서가 바뀐 세그먼트가 오면 버퍼링, 빠진 구간 채워지면 순서대로 상위에 전달

---

## Q3. 3-way handshake의 동작 과정과 존재 이유는?

[답변]
* 동작 과정
  1. Client -> Server: SYN(ISN = x)
     - 연결 시작
     - connect() 호출 및 SYN 전송
     - 초기 시퀀스 번호(ISN) 제안
     - Client: CLOSED -> SYN_SENT
  2. Server -> Client: SYN(ISN = y) + ACK(x+1)
     - 연결 수락(ACK)
     - 연결 시작(SYN): 연결을 '반쯤' 준비(초기 상태/자원 할당, 큐 적재 등)
     - 서버의 ISN 전달
     - Server: LISTEN -> SYN_RECEIVED
  3. Client -> Server: ACK(y+1)
     - 서버의 ISN에 대한 ACK 전송
     - 연결 성립
     - Client: SYN_SENT -> ESTABLISED
     - Server: SYN_RECEIVED -> ESTABLISHED(ACK 수신 시)
* 존재 이유
  - 양방향 준비 상태 확인: 클라이언트와 서버 모두 준비되었음을 상호 확인
  - 초기 시퀀스 번호 동기화: 데이터 순서/ACK 처리를 위해 시작 번호 합의
  - 지연된 연결 요청의 혼선 방지: 과거의 SYN이 지연된 상황에서 잘못된 연결의 성립을 줄임
 
[보완]
* SYN: TCP 헤더의 제어 비트의 하나. TCP 연결 시작 의사 전달 및 초기 시퀀스 번호 제안
* 실패하는 경우
  1. 패킷 유실/지연으로 인한 타임아웃
     - 1단계 SYN 유실: 서버가 아예 모름. 클라이언트의 재전송 및 실패
     - 2단계 SYN+ACK 유실: 클라이언트의 응답 미수신 및 재전송. 서버는 SYN-RECEIVED 상태
     - 3단계 ACK 유실: 서버의 연결 성립 미확정 및 재전송/타임아웃
  2. 서버 자원 부족
     - 서버는 SYN을 수신하면 '반쯤 열린 연결'을 큐에 넣음
     - 해당 큐가 꽉 차면 새로운 SYN을 드롭하거나 RST(Reset)으로 거절
     - 클라이언트는 응답을 못 받거나 즉시 거절 -> 연결 실패
  3. 보안에 의한 차단
     - 서버 앞단 방화벽이 해당 포트의 SYN을 막거나, 중간 장비가 SYN+ACK 차단
     - 클라이언트의 타임아웃으로 연결 실패
    
* Half-open: 반쪽 연결
  - 마지막 ACK가 서버에 도달하지 않아, 클라이언트는 연결 확정, 서버는 미확정인 상태
---

## Q4. 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?

[답변]
* 동작 과정
  1. Client -> Server: FIN(seq = u)
     - 연결 종료 시작
     - close() 호출 및 FIN 전송
     - 더 이상 보낼 데이터 없음(송신 방향 종료 의사)
     - Client: ESTABLISHED -> FIN_WAIT_1
  2. Server -> Client: ACK(u+1)
     - Client의 FIN 수신 확인(ACK)
     - Server는 아직 보낼 데이터가 남아 있을 수 있음(반대 방향 유지)
     - Server: ESTABLISHED -> CLOSE_WAIT
     - Client: FIN_WAIT_1 -> FIN_WAIT_2(ACK 수신 시)
  3. Server -> Client: FIN(seq = v)
     - Server도 종료 시작
     - close() 호출 및 FIN 전송
     - 더 이상 보낼 데이터 없음(송신 방향 종료 의사)
     - Server: CLOSE_WAIT -> LAST_ACK
  4. Client -> Server: ACK(v+1)
     - Server의 FIN에 대한 ACK 전송
     - 연결 종료 완료(클라이언트 관점)
     - Client: FIN_WAIT_2 -> TIME_WAIT -> CLOSED
     - Server: LAST_ACK -> CLOSED(ACK 수신 시)

* TIME_WAIT가 필요한 이유
  - 마지막 ACK 유실 대비: 4단계에서 Client가 보낸 마지막 ACK가 유실되면, Server가 FIN 재전송할 수 있어야 함
  - Client가 TIME_WAIT로 잠시 대기 -> 재전송된 FIN에 대해 다시 ACK 전송
  - 지연된 패킷 소거
  - 일반적으로 기간은 2MSL(Maximum Segment Lifetime의 2배)

[보완]
* Half-close: FIN은 '연결 전체 종료'보다는 '해당 방향 송신 스트림 종료'의 의미가 강함. '양방향 종료'에 FIN이 2번 등장(그래서 4-way임)

---

## Q5. 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?

[답변]
* 흐름 제어
  - 목적: 수신자의 처리/버퍼 능력을 넘는 전송 방지. '수신자 보호'
  - 주체: 송신자가 수신자가 광고한 상태를 보고 조절
  - 대표 기법: 수신 윈도우(rwnd) 기반 조절
  - 동작
    1. 수신자: 자신의 수신 버퍼 여유를 윈도우 크기(rwnd)로 송신자에게 알림
    2. 송신자: 미확인 데이터가 rwnd를 넘지 않도록 전송량 제한
* 혼잡 제어
  - 목적: 네트워크(라우터/링크) 혼잡으로 인한 손실/지연 폭증 완화. '네트워크 보호'
  - 주체: 송신자가 네트워크 상태(손실/지연 신호)를 추정해 조절
  - 대표 개념: 혼잡 윈도우(cwnd), 슬로 스타트/혼잡 회피 등
  - 동작
    1. 초기에 cwnd를 작게 시작해 점진적으로 늘림(슬로 스타트)
    2. 손실(타임아웃/중복 ACK 등)이 감지되면 cwnd 줄임 -> 혼잡 완화
    3. 이후 완만하게 증가 -> 적정 전송률 탐색(혼잡 회피)

[보완]
* 실제 전송 가능량: 송신자가 동시에 보낼 수 있는 양은 min(rwnd, cwnd)
* rwnd: Receiver Window. 수신자가 현재 받아서 처리할 수 있는 여유(수신 버퍼 여유량)
  - 소신 버퍼: 네트워크로 들어온 데이터를 애플리케이션이 읽어갈 때까지 임시로 쌓아두는 메모리 공간
* cwnd: Congestion Window. 송신자가 네트워크 혼잡 정도를 추정해 스스로 정하는 '네트워크에 동시에 떠 있을 수 있는 데이터 양'의 상한
  - in-flight 데이터: 송신자가 이미 보냈지만 아직 ACK를 못 받은 데이터(네트워크 상에 “떠 있는” 데이터)

---

## Q6. Sliding Window는 어떻게 동작하는가?

[답변]
* Sliding Window
  - 한 번에 1개씩 보내고 확인받는 방식(Stop-and-Wait)이 아닌, 윈도우 크기만큼 연속으로 전송 -> ACK를 받으면서 창(window)을 앞으로 “미끄러지듯” 이동시키는 방식

* 동작(송신 측)
  1. 송신 윈도우 범위([L,R]) 내에서는 ACK를 기다리지 않고 전송
  2. 수신 ACK가 도착하면, 확인된 구간만큼 L,R을 앞으로 이동
  3. 일부 손실 발생 -> 누락된 구간을 기준으로 재전송
* 동작(수신 측)
  1. 순서대로 도착: 누적 ACK 갱신
  2. 순서 바뀜: 버퍼링 후 빠진 데이터 채워지면 상위에 전달

---

## Q7. UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)

[답변]
* 실시간 스트리밍/VoIP/화상회의
  - 약간의 손실보다 지연이 더 치명적인 경우
  - 품질 보완 필요 시 애플리케이션 레벨에서 보완
* 온라인 게임
  - 위치/상태 업데이트는 '최신 정보'가 매우 중요
  - 일부 패킷 손실이 있어도 다음 업데이트로 덮음
* DNS
  - 질의/응답이 비교적 작고 빠른 왕복이 중요
* DHCP
  - 초기 네트워크 설정 단계에서 브로드캐스트/간단 메시지 교환이 필요해 UDP를 사용
 
[보완]
* DHCP: Dynamic Host Configuration Protocol. 네트워크에 접속한 장치가 통신에 필요한 설정을 자동으로 할당받는 프로토콜

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 8: TCP vs UDP
> 📅 2025.02.20 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?
- [ ] TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)
- [ ] 3-way handshake의 동작 과정과 존재 이유는?
- [ ] 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?
- [ ] 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?
- [ ] Sliding Window는 어떻게 동작하는가?
- [ ] UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)
---

### 1. TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?
TCP와 UDP는 전송 계층의 프로토콜이다. 프로토콜은 클라이언트와 서버가 정보를 교환할 수 있도록 하는 **메세지 형식에 대한 규칙**이다. 즉, 전송 받은 메세지를 이해하려면 설계된 규칙에 따라 작성된 데이터 형식이어야 한다는 뜻이다. (TCP/UDP 외에도 HTTP와 IP 프로토콜이 있다.)
- **TCP(Transmission Control Protocol)**는 인터넷에서 **데이터를 신뢰성 있게** 보내기 위한 프로토콜이다. TCP는 연결형으로, 데이터를 보내기 전에 반드시 연결 설정을 하여 신뢰성(순서, 오류제어 등)을 보장하지만 상대적으로 속도가 느리다.
    - 데이터를 순서대로, 빠짐없이, 중복없이, 에러없이 전달.
- **UDP(User Datagram Protocol)**는 속도와 단순성을 위해 신뢰성을 포기한 프로토콜이다. UDP는 비연결형으로 속도와 효율성을 중시하여 데이터 손실 가능성이 있지만 속도가 빠르다.
    - 그냥 보낸다. 확인 안한다. 재전송 안한다.

---

### 2. TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)
1. ACK(Acknowledgement): 도착 확인 매커니즘
TCP는 데이터를 보내면 반드시 확인 응답(ACK)을 기다린다. 송신자가 데이터를 보내면, 수신자가 정상적으로 수신을 완료했다는 확인 바이트를 보낸다는 뜻이다. 
```text
송신자 → [SEQ=1000, 길이=500] → 수신자
송신자 ← [ACK=1500] ← 수신자
```
ACK=1500 의미: "1000~1499 바이트까지 정상 수신 완료"
TCP는 누적 ACK 방식을 사용하여, 중간에 빠지면 그 이후는 인정하지 않는다.

2. 재전송
TCP는 두가지 방식으로 재전송을 수행한다.
    1) 타임아웃 기반 재전송
        - 일정 시간 안에 ACK가 오지 않으면 재전송
        ```text
        send -> ACK 대기 -> 시간초과 -> 재전송
        ```
    2) Fast 재전송
        - 같은 ACK가 3번 오면 즉시 재전송
        ```text
        ACK = 1500
        ACK = 1500
        ACK = 1500
        ```
        -> "1500 이후가 문제이구나"라고 이해하고 즉시 해당 세그먼트 재전송한다. 이때는 타임아웃을 기다리지 않는다.

3. 순서 보장
TCP는 데이터 패킷에 **순서 번호(sequence number)**를 부여하여 수신자가 패킷을 올바른 순서대로 **재조립**할 수 있도록 한다. 만약 순서대로 도착하지 않으면, 누락된 패킷이 도착할때까지 대기하고 그 후에 패킷을 순서대로 재조립하여 애플리케이션에 전달한다.

정리하자면, TCP는 데이터를 전송하고
-> Sequence number 부여
-> 수신자가 ACK 반환
-> ACK 없으면 재전송
-> 중복 ACK 3회이면 Fast 재전송
-> 수신자는 번호 기준 정렬
구조를 따른다. 신뢰성이란, 데이터 유실 시 복구, 순서 정렬, 중복 제거, 데이터 손상 검출을 보장하므로 TCP는 위와 같은 방법들로 신뢰성을 보장하는 프로토콜이다.

---

### 3. 3-way handshake의 동작 과정과 존재 이유는?
TCP에서 데이터를 전송하기 전에 **양쪽에 서로 통신 준비가 되었음을 확인하는 연결 설정 과정**이다. TCP는 연결지향(connection-oriented) 프로토콜이기 때문에 데이터 전송 전에 반드시 이 과정을 수행해야 한다.

1) Client -> SYN
    클라이언트가 서버에게 연결 요청을 한다. 이때 클라이언트는 시작번호 x를 설정한다.
    ```text
    Client → SYN (SEQ = x) → Server
    ```
        - SYN: 연결 요청 신호
        - SEQ = x: 클라이언트의 초기 시퀀스 번호
    
2) Server -> SYN + ACK
서버가 준비 되었다고 클라이언트에게 전달한다. 이때 서버도 자신의 시작번호 y를 설정한다.
```text
Server -> SYN (SEQ = y), ACK (ACK = x+1) -> Client
```
    - ACK = x+1: 클라이언트의 SYN을 정상 수신했음을 의미

3) Client -> ACK
클라이언트가 서버의 준비 상태를 확인했다고 서버에게 알린다. 연결이 완료된다.
```text
Client -> ACK (ACK = y+1) -> Server
```
    - 서버의 SYN 수신 확인
    ACK = y+1 전송
    
이렇게 세번이나 주고받는 이유는 양방향 통신 확인을 하기 위함이다. TCP는 Full-Duplex(양방향 통신)이다. 

    - 클라이언트 -> 서버 방향 확인
    - 서버 -> 클라이언트 방향 확인
위처럼 두번만 확인하게 되면 준비 여부를 확실히 알 수 있다. 

또한, 3-way handshake는 양쪽의 시작 번호를 서로 공유하고, ACK가 없어서 연결이 완성되지 않는 문제를 방지한다.

---

### 4. 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?
4-way handshake는 TCP 연결을 정상적으로 종료하기 위한 과정이다. TCP는 앞서 언급했듯 양방향 통신이므로 **각 방향을 독립적으로 종료**해야한다. 그래서 세번이 아닌, 네번의 메세지가 필요하다.
1) 한쪽의 종료(FIN)
    ```text
    Client → FIN (SEQ = x) → Server
    ```
2) 그에 대한 확인(ACK)
    ```text
    Server → ACK (ACK = x+1) → Client
    ```
3) 반대 방향 종료(FIN)
    ```text
    Server → FIN (SEQ = y) → Client
    ```
4) 그에 대한 확인(ACK)
    ```text
    Client → ACK (ACK = y+1) → Server
    ```

TIME_WAIT란, 연결 종료 후 Client는 바로 closed로 가지 않고 일정 시간 대기할때의 상태를 의미한다. 마지막 ACK 보장과 지연 패킷 제거를 위한 안전 장치와 같다. 

---

### 5. 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?
1) **흐름 제어(flow control)**이란, **수신자**가 감당할 수 있는 만큼만 데이터를 보내도록 조절하는 것.
예를 들어, 송신자는 엄청 빠르고, 수신자는 느리다면, 수신 버퍼가 가득 차서 데이터 손실이 발생할 수 있다. 이때는 재전송을 해 비효율적이다. 즉, 수신자는 "나 지금 이만큼만 받을 수 있어"라고 전달해야 한다. 
흐름제어는 window size로 인해 결정된다. TCP 헤더에 window size(rwnd)라는 필드가 있어 수신자가 지정한 윈도우 범위 내에서만 데이터를 보낸다. 만약 수신 버퍼가 꽉 찬다면, 송신자는 전송을 중단하고 잠시 후 다시 확인한다.

2) **혼잡 제어(congestion control)**이란, **네트워크**가 감당할 수 있는 만큼만 데이터를 보내도록 조절하는 것.
모든 송신자가 마음대로 보내면, 라우터 버퍼가 가득 차게 된다. 이때 패킷 드롭이 발생해 재전송이 폭증하는 문제가 발생한다. 이로 인해 네트워크가 마비되는 congestion collapse가 야기된다. 따라서 TCP는 "네트워크 상태를 추정해서 속도를 조절한다."
혼잔하다고 판단하는 기준은 다음과 같다.
    - 네트워크 혼잡: 패킷 손실 발생
    - 심각한 혼잡: 타임아웃 발생
    - 일부 혼잡: 중복 ACK 3회
TCP는 congestion window(cwnd)라는 값을 유지한다. 이 값을 통해 혼잡도를 조절한다.

정리하자면, 흐름제어는 수신자를 보호하기 위함이고, 수신 버퍼 크기를 기준으로 삼는다. 반면, 혼잡제어는 네트워크를 보호하고, 패킷 손실을 기준으로 삼는다.

---

### 6. Sliding Window는 어떻게 동작하는가?
Sliding Window는 TCP에서 흐름 제어와 신뢰성 보장을 동시에 구현하는 핵심 메커니즘이다.
즉, “ACK를 기다리지 않고, 일정 범위(window)까지 연속으로 데이터를 보낼 수 있게 하자.”가 목적이다.

송신자는 한 번에 보낼 수 있는 전송 범위(Window)를 가진다.

예시:

- 현재 마지막 ACK 수신 위치: 1000
- 윈도우 크기: 3000

```text
전송 가능 범위: 1000 ~ 3999
```
이 범위 안의 데이터는 ACK를 기다리지 않고 전송 가능하다.
이후, 수신자가 ACK = 2000이라고 응답하면, 1000~1999 바이트까지 정상 수신 완료했다는 뜻이므로, 윈도우를 오른쪽으로 이동한다. 
```text
기존 window: [1000~3999]
이동 후 window: [2000~4999]

이처럼 ACK에 따라 window가 앞으로 이동하는 것을 sliding이라고 한다.
```
---

### 7. UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)
UDP는 다음과 같은 특성을 가진다.
- 연결 설정 없음
- 재전송 없음
- 순서 보장 없음
- 지연 최소화
따라서, 속도와 실시간정이 중요한 상황에서 사용된다.

예를 들어, 영상/음성 통화와 같은 실시간 스트리밍에서는 최신 데이터를 받는 것이 중요하다.
DNS(도메인 -> IP 주소 변환 시스템) 요청 시, 데이터가 유실될 경우, 애플리케이션 레벨에서 재요청 할 수 있다. DHCP는 broadcast 기반으로 동작하여 연결 기반인 TCP는 사용이 불가하므로 UDP를 사용해야 한다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90

https://velog.io/@narcoker/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCP-%EC%97%90%EC%84%9C-%EC%8B%A0%EB%A2%B0%EC%84%B1%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

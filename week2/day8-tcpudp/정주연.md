# TCP vs UDP

> 📅 2025.02.20 | 📁 Week 2
> 

---

## 🧠 학습 질문

- [x]  TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?
- [x]  TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)
- [x]  3-way handshake의 동작 과정과 존재 이유는?
- [x]  4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?
- [x]  흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?
- [x]  Sliding Window는 어떻게 동작하는가?
- [x]  UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)

## TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?

### TCP(Transmission Control Protocol)란?

- OSI 7계층과 TCP/IP 4계층에서 모두 **전송 계층**(Transport Layer)에 속한다. 즉, 종단간(end-to-end) 통신을 담당한다. 애플리케이션에서 생성된 데이터를 세그먼트(TCP) 또는 데이터그램(UDP)로 분할하고 재조립하는 역을 수행한다.
- 16bit 포트번호를 사용하여 특정 애플리케이션이나 프로세스를 식별한다.
- **연결 지향 (Connection-oriented):** 데이터를 보내기 전에 송신측과 수신측이 서로 연결을 확인하는 **3-way Handshake** 과정을 거친다.
- 데이터가 중간에 유실되면 다시 보내주고(재전송), 순서가 바뀌면 원래대로 맞춰준다. (신뢰성 보장)
- 수신측의 처리 속도나 네트워크 상황에 맞춰 데이터 전송량을 조절한다.
- 1:1 통신(Unicast)

### UDP(User Datagram Protocol)란?

- **비연결 지향 (Connectionless):** 연결 확인 과정 없이 데이터를 바로 보낸다.
- 데이터가 잘 도착했는지, 순서가 맞는지 신경 쓰지 않습니다. (Best-effort delivery) (신뢰성 낮음)
- 확인 절차(Handshake, ACK 등)가 없으므로 헤더가 가볍고 전송 속도가 매우 빠르다.
- 1:1뿐만 아니라 1:N(Broadcast), M:N(Multicast) 통신도 가능

| **구분** | **TCP** | **UDP** |
| --- | --- | --- |
| **연결 방식** | 연결 지향 (3-way handshake) | 비연결 지향 |
| **신뢰성** | 높음 (데이터 유실 시 재전송) | 낮음 (유실 가능성 있음) |
| **순서 보장** | 보장함 | 보장하지 않음 |
| **전송 속도** | 상대적으로 느림 | **매우 빠름** |
| **헤더 크기** | 20 ~ 60 바이트 (무거움) | 8 바이트 (가벼움) |
| **데이터 단위** | 세그먼트 (Segment) | 데이터그램 (Datagram) |

## TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)

### 응답 확인 (ACK)과 재전송 (ARQ)

- 송신측은 데이터를 보낸 후 수신측으로부터 잘 받았다는 "확인 도장"을 기다린다.
- **ACK (Acknowledgement)**
    - 수신측은 데이터를 성공적으로 받으면 다음으로 받고 싶은 바이트의 번호를 ACK 메시지에 담아 보냄. (예: "100번까지 잘 받았으니 101번을 줘")
- **타이머와 재전송 (Retransmission)**
    - 송신측은 패킷을 보낼 때마다 타이머를 작동시킴. 일정 시간(RTO, Retransmission TimeOut) 내에 ACK가 오지 않으면 패킷이 유실된 것으로 간주하고 다시 보냄
- **빠른 재전송 (Fast Retransmit)**
    - 타이머가 만료되기 전이라도, 수신측으로부터 동일한 번호의 ACK를 3번 연속 받으면(3 Duplicate ACKs) 해당 패킷이 손실되었다고 판단하고 즉시 재전송

### 흐름 제어 (Flow Control): 슬라이딩 윈도우

- **원리:** 수신측의 처리 속도보다 송신측이 데이터를 보내는 속도가 빠르면 수신측 버퍼가 넘쳐 데이터가 손실됨.
- **방법:** 수신측은 자신이 한 번에 받아들일 수 있는 데이터 양(Window Size)을 송신측에 계속 알려줌. 송신측은 이 범위 내에서만 ACK 없이 데이터를 연속해서 보낼 수 있음.

### 혼잡 제어 (Congestion Control)

- **원리:** 송신측과 수신측 사이의 네트워크 통로 자체가 막히는 것을 방지함.
- **방법:** 네트워크가 혼잡하다고 판단되면(패킷 손실 발생 등) 전송 속도를 강제로 줄임. 초기에는 조금씩 보내다가 속도를 올리는 **Slow Start** 방식을 사용하며, 혼잡이 감지되면 전송량을 조절해 전체 네트워크의 붕괴를 막음.

### 체크섬 (Checksum)

- **원리:** 전송되는 세그먼트의 헤더와 데이터 내용을 바탕으로 계산된 수치값을 포함함.
- **방법:** 수신측은 데이터를 받은 후 직접 체크섬을 다시 계산하여, 송신측이 보낸 값과 대조함. 이를 통해 전송 과정에서 데이터 비트가 오염되었는지(무결성)를 검사함.

## 3-way handshake의 동작 과정과 존재 이유는?

양쪽 모두 데이터를 보낼 준비와 받을 준비가 되었음을 보장하기 위해 존재함. 만약 2단계만 거친다면, 서버는 응답을 보냈으나 클라이언트가 이를 제대로 받았는지 확인할 길이 없어 신뢰성을 확보할 수 없음.

- **SYN:** 클라이언트가 서버에 접속을 요청하는 패킷을 보냄. (e.g. 내 번호는 x야, 통신하자)
- **SYN + ACK:** 서버가 요청을 수락하고 클라이언트에게도 접속 요청 패킷을 보냄. (e.g. ㅇㅋ. 내 번호는 y야. 너의 x+1번을 기다릴게)
- **ACK:** 클라이언트가 서버의 요청에 응답함. (e.g. ㅇㅋ. 너의 y+1번을 기다릴게)

## 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?

- **FIN:** 클라이언트가 연결을 끊고 싶다는 메시지를 보냄.
- **ACK:** 서버가 확인 메시지를 보내고, 남은 데이터를 모두 전송할 때까지 기다림. (CLOSE_WAIT)
- **FIN:** 서버가 남은 데이터를 다 보냈다면 자신도 종료 준비가 됐다는 메시지를 보냄.
- **ACK:** 클라이언트가 최종 확인 메시지를 보냄.

**TIME_WAIT의 필요성**

- **지연 패킷 처리:** 마지막 ACK가 손실되어 서버가 FIN을 재전송할 경우를 대비함. 또한, 뒤늦게 도착한 패킷이 새로운 연결과 섞여 데이터 오류를 일으키는 것을 방지함.
- **완전한 종료 확인:** 수신측이 마지막 ACK를 받아야만 세션이 정상적으로 종료된 것으로 간주하기 때문임.

## 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?

- **흐름 제어 (Flow Control)**
    - **송신측과 수신측** 사이의 속도 차이를 조절함.
    - 수신측의 버퍼가 넘치지 않도록 송신측의 데이터 양을 제어함. (Sliding Window 방식 사용)
- **혼잡 제어 (Congestion Control)**
    - 네트워크 통로(라우터 등)의 과부하를 조절함.
    - 네트워크가 감당할 수 있는 양보다 많은 데이터가 유입되어 패킷이 유실되는 것을 방지함. (Slow Start, Congestion Avoidance 등 사용)

## Sliding Window는 어떻게 동작하는가?

- 흐름 제어의 핵심 기법
- 수신측에서 설정한 '윈도우 크기'만큼 송신측이 ACK 없이 데이터를 연속해서 보낼 수 있게 함.
- **동작원리**
    - 수신측이 "지금은 5개까지 받을 수 있어"라고 알려주면(Window Size), 송신측은 5개를 보냄. 이후 1번에 대한 ACK가 오면 윈도우를 옆으로 한 칸 밀어서(Slide) 다음 데이터(6번)를 보낼 수 있는 공간을 확보함.
- **효과**
    - 매 패킷마다 ACK를 기다릴 필요가 없어 전송 효율이 비약적으로 상승함.

## UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)

- **실시간 스트리밍 & VoIP**
    - 패킷 한두 개가 유실되어 화면이 조금 깨지는 것보다, 영상이나 음성이 끊기지 않고 계속 이어지는 것이 더 중요하기 때문임.
- **DNS (Domain Name System)**
    - 아주 짧은 요청과 응답만 오가면 됨.
    - TCP의 3-way handshake를 매번 수행하는 것은 오버헤드가 너무 커서 비효율적임.
- **DHCP**
    - 자신의 IP 주소도 모르는 초기 상태에서 불특정 다수(Broadcast)에게 "나 IP 좀 줘"라고 외쳐야 하므로, 1:1 연결 지향인 TCP보다 UDP가 적합함.

---

## 📎 참고 자료

## <!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->
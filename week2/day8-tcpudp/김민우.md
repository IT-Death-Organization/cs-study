# Day 8: TCP vs UDP
> 📅 2025.02.20 | 📁 Week 2
---
## 🧠 학습 질문
- [x] TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?
- [x] TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)
- [x] 3-way handshake의 동작 과정과 존재 이유는?
- [x] 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?
- [x] 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?
- [x] Sliding Window는 어떻게 동작하는가?
- [x] UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)
---
# TCP vs UDP 네트워크 핵심 개념 정리

---

## 1. TCP와 UDP의 차이

| 항목 | TCP | UDP |
|------|-----|-----|
| 연결 방식 | 연결 지향 (Connection-oriented) | 비연결 (Connectionless) |
| 신뢰성 | 보장 (ACK, 재전송) | 보장 안 함 |
| 순서 보장 | O | X |
| 속도 | 상대적으로 느림 | 빠름 |
| 오버헤드 | 높음 | 낮음 |
| 흐름/혼잡 제어 | O | X |

### 사용 상황
- **TCP**: 데이터 정확성이 중요한 경우 → HTTP/HTTPS, FTP, SSH, 이메일(SMTP), 파일 전송
- **UDP**: 속도와 실시간성이 중요한 경우 → DNS, DHCP, 실시간 스트리밍, VoIP, 온라인 게임

---

## 2. TCP의 신뢰성 보장 메커니즘

### ACK (Acknowledgement)
- 수신자는 데이터를 받으면 **ACK 번호**를 응답으로 전송
- ACK 번호 = 다음으로 받기를 기대하는 바이트 번호 (누적 확인)

### 재전송 (Retransmission)
- 송신자는 **타이머**를 설정하고, 타임아웃 내 ACK가 오지 않으면 재전송
- **RTO (Retransmission Timeout)**: RTT(왕복 시간)를 기반으로 동적 계산
- **중복 ACK 3회** 수신 시 → 빠른 재전송(Fast Retransmit) 수행

### 순서 보장 (Sequence Number)
- 각 세그먼트에 **시퀀스 번호** 부여
- 수신 측에서 순서가 맞지 않으면 **재정렬(Reordering)** 후 상위 계층에 전달
- 중복 세그먼트는 자동으로 제거

---

## 3. 3-Way Handshake

### 동작 과정

```
Client                          Server
  |                               |
  |  --- SYN (seq=x) ---------->  |  (1) 연결 요청
  |                               |
  |  <-- SYN+ACK (seq=y, ack=x+1) |  (2) 연결 수락
  |                               |
  |  --- ACK (ack=y+1) -------->  |  (3) 확인
  |                               |
  |        [연결 성립]             |
```

1. **SYN**: 클라이언트가 서버에 연결 요청 (초기 시퀀스 번호 x 전송)
2. **SYN+ACK**: 서버가 요청 수락, 자신의 시퀀스 번호 y와 함께 ACK 응답
3. **ACK**: 클라이언트가 서버의 SYN을 확인

### 존재 이유
- 양쪽 모두 **송수신 가능 여부**를 확인하기 위해 필요
- 초기 시퀀스 번호(ISN)를 **양방향으로 동기화**
- 2-Way로는 서버→클라이언트 방향의 신뢰성을 보장할 수 없음

---

## 4. 4-Way Handshake

### 동작 과정

```
Client                          Server
  |                               |
  |  --- FIN ------------------>  |  (1) 연결 종료 요청
  |                               |
  |  <-- ACK ------------------   |  (2) 수신 확인
  |                               |
  |  <-- FIN ------------------   |  (3) 서버도 종료 준비 완료
  |                               |
  |  --- ACK ------------------>  |  (4) 최종 확인
  |                               |
  |     [TIME_WAIT 상태]           |
```

> FIN과 ACK가 별도로 분리되는 이유: 서버는 ACK 후에도 남은 데이터를 전송할 수 있기 때문 (Half-Close)

### TIME_WAIT 상태가 필요한 이유

TIME_WAIT는 클라이언트가 마지막 ACK를 보낸 후, **일정 시간(2 × MSL)** 동안 대기하는 상태.

1. **마지막 ACK 유실 대비**: ACK가 손실되면 서버는 FIN을 재전송하는데, TIME_WAIT 없이 소켓이 닫히면 응답 불가
2. **지연 패킷 처리**: 네트워크 상에 떠돌던 이전 연결의 패킷이 새 연결에 영향을 주지 않도록 차단

---

## 5. 흐름 제어 vs 혼잡 제어

| 항목 | 흐름 제어 (Flow Control) | 혼잡 제어 (Congestion Control) |
|------|------------------------|-------------------------------|
| 목적 | 수신자 버퍼 보호 | 네트워크 과부하 방지 |
| 주체 | 송신자 ↔ 수신자 (End-to-End) | 송신자 ↔ 네트워크 전체 |
| 방법 | 수신 윈도우(rwnd) 크기 조절 | 혼잡 윈도우(cwnd) 크기 조절 |

### 흐름 제어 동작
- 수신자가 자신의 **버퍼 여유 공간(rwnd)** 을 ACK에 포함하여 전달
- 송신자는 rwnd 이하로만 데이터 전송
- 수신 버퍼가 가득 차면 rwnd=0 통보 → 송신 중단 → 주기적 probe로 재개

### 혼잡 제어 동작 (4단계)

1. **Slow Start**: cwnd를 1 MSS부터 시작, ACK마다 지수적으로 증가
2. **Congestion Avoidance**: ssthresh 도달 후 선형 증가 (RTT당 +1 MSS)
3. **Fast Retransmit**: 3 duplicate ACK → 타임아웃 전에 즉시 재전송
4. **Fast Recovery**: 3 dup ACK 후 ssthresh = cwnd/2, cwnd = ssthresh + 3

```
cwnd
 ^
 |      /
 |     /  ← Congestion Avoidance (선형)
 |    /
 |   * ← ssthresh
 |  /
 | /  ← Slow Start (지수)
 |/
 +-------------------> 시간
```

---

## 6. Sliding Window

### 동작 원리

```
[전송 완료 + ACK] | [전송 완료, 미ACK] | [전송 가능] | [전송 불가]
        ↑                  ↑                ↑
    window 왼쪽          window 범위      window 오른쪽
```

- 수신자의 ACK가 올 때마다 윈도우가 **오른쪽으로 슬라이딩**
- ACK를 기다리는 동안에도 윈도우 내의 다음 데이터를 계속 전송 가능 → **파이프라이닝**
- 실제 전송 가능한 크기: `min(cwnd, rwnd)`

### 핵심 개념
- **송신 윈도우**: 확인 응답 없이 보낼 수 있는 최대 데이터 양
- **수신 윈도우**: 수신 버퍼의 여유 공간

---

## 7. UDP를 사용하는 이유와 주요 사례

UDP는 오버헤드 없이 빠른 전송이 필요하거나, 응용 계층에서 신뢰성을 직접 처리할 때 사용.

| 사례 | 이유 |
|------|------|
| **DNS** | 요청/응답이 단순, 재전송은 앱 레벨에서 처리 |
| **DHCP** | IP 없는 상태에서 브로드캐스트로 통신, TCP 연결 불가 |
| **실시간 스트리밍 (RTP)** | 지연이 낮아야 함, 일부 패킷 손실 허용 |
| **VoIP** | 끊김보다 지연이 더 큰 문제 |
| **온라인 게임** | 낮은 레이턴시 필수, 오래된 패킷은 불필요 |
| **QUIC (HTTP/3)** | UDP 위에서 신뢰성/암호화를 앱 레벨로 구현 |

> 💡 **QUIC**: Google이 개발한 UDP 기반 전송 프로토콜. TCP의 HOL Blocking 문제를 해결하고, TLS 협상과 연결 수립을 동시에 처리하여 HTTP/3의 기반이 됨.

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 8: TCP vs UDP
> 📅 2025.02.20 | 📁 Week 2
---
## 🧠 학습 질문
- [x] TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?
- [x] TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)
- [x] 3-way handshake의 동작 과정과 존재 이유는?
- [x] 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?
- [x] 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?
- [x] Sliding Window는 어떻게 동작하는가?
- [x] UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)

<br>

# 1. TCP와 UDP의 차이는? 각각 어떤 상황에서 사용하는가?

> 두 프로토콜은 전송 계층(L4)에서 데이터 전송을 담당하지만, '신뢰성'과 '속도' 중 무엇을 우선하느냐에 따라 설계 방식이 완전히 다릅니다.

### TCP (Transmission Control Protocol)
* 특징
    * 연결 지향형 프로토콜로, 가상 회선을 설정하여 패킷의 전송 순서를 보장하고 오류를 제어합니다.
* 사용 상황
    * 데이터의 유실이 절대 있어서는 안 되는 경우에 사용합니다. (웹 브라우징(HTTP), 이메일, 파일 전송 등)

### UDP (User Datagram Protocol)
* 특징
    * 비연결형 프로토콜로, 데이터를 보내기만 할 뿐 수신 여부를 확인하지 않습니다. 헤더가 가볍고 오버헤드가 적어 속도가 매우 빠릅니다.
* 사용 상황
    * 데이터가 조금 유실되더라도 실시간성이 중요한 서비스에 사용합니다. (동영상 스트리밍, 온라인 게임, VoIP 등)

<br>

# 2. TCP는 어떻게 신뢰성을 보장하는가? (ACK, 재전송, 순서 보장)

> TCP를 신뢰할 수 있는 이유는 데이터 유실을 방지하는 여러 장치를 갖추고 있기 때문입니다.

### 시퀀스 번호 (Sequence Number)
송신측에서 보내는 패킷에 순서대로 번호를 부여합니다. 수신측은 이 번호를 보고 흩어져서 도착한 패킷을 원래 순서대로 조립하며, 중간에 빠진 번호가 있는지 확인합니다.

### 확인 응답 (Acknowledgment, ACK)
수신측이 패킷을 잘 받았다면 송신측에 "N번까지 잘 받았으니, 다음엔 N+1번을 보내줘"라고 알립니다.

### 재전송 메커니즘 (Retransmission)
송신측은 패킷을 보낸 후 일정 시간(Timeout) 동안 ACK를 받지 못하면, 해당 패킷이 유실되었다고 판단하여 다시 전송합니다. 이를 통해 네트워크 장애 상황에서도 데이터 전달을 보장합니다.

<br>

# 3. 3-way handshake의 동작 과정과 존재 이유는?

> TCP는 데이터를 주고받기 전, 양쪽 장치가 대화할 준비가 되었는지 확인하는 과정을 거칩니다.

### 동작 과정
1. Client -> Server (SYN)
    * 클라이언트가 서버에 연결 요청 메시지를 보냅니다.
2. Server -> Client (SYN + ACK)
    * 서버는 요청을 수락하며, 자신도 통신할 준비가 되었음을 알립니다.
3. Client -> Server (ACK)
    * 클라이언트가 최종적으로 확인 메시지를 보내며 연결이 확립(Established)됩니다.

### 존재 이유
단순히 연결을 알리는 것뿐만 아니라, 양방향 통신을 위한 초기 시퀀스 번호(ISN)를 서로 동기화하고, 상대방이 데이터를 받을 준비가 된 실제 살아있는 상태인지 확인하기 위해 반드시 필요한 과정입니다.

<br>

# 4. 4-way handshake의 동작 과정은? TIME_WAIT 상태는 왜 필요한가?

> 연결을 맺을 때보다 끊을 때가 더 조심스럽습니다. 남아있는 데이터를 안전하게 처리해야 하기 때문입니다.

### 동작 과정
1. Client -> Server (FIN)
    * 클라이언트가 연결을 종료하겠다는 메시지를 보냅니다.
2. Server -> Client (ACK)
    * 서버는 확인했다는 답을 보내고, 남은 데이터를 마저 전송합니다 (Close Wait).
3. Server -> Client (FIN)
    * 서버도 보낼 데이터가 끝나면 종료 메시지를 보냅니다.
4. Client -> Server (ACK)
    * 클라이언트가 마지막 확인 답장을 보내고 연결을 해제합니다.

### TIME_WAIT의 필요성
클라이언트가 마지막 ACK를 보낸 후 즉시 소켓을 닫지 않고 일정 시간 기다리는 상태입니다. 

네트워크에선 패킷이 가끔 길을 잃거나 먼 길을 돌아오기도 하는데, 이때 기존 연결이 종료되고 새로운 연결이 열린 후 이전 그 패킷이 도착한다면 문제가 발생할 수 있습니다. 이를 위해 연결을 종료한 후에도 최대 패킷 생존 시간의 2배만큼 기다려줍니다.

* 지연 패킷 처리
    * 뒤늦게 도착한 패킷이 새로 열린 연결에 섞여 들어가는 데이터 오염을 막기 위함입니다.
* 최종 ACK 재전송
    * 클라이언트가 FIN을 제대로 받고 ACK를 보냈지만, 만약 마지막 ACK가 유실되어 서버가 자신이 보낸 FIN이 제대로 도착을 못했다고 판단해서 FIN을 다시 보냈을 때, 클라이언트 쪽에서 일정 기간 기다려 줌으로써 언제든 다시 ACK를 보낼 수 있도록 합니다.

<br>

# 5. 흐름 제어와 혼잡 제어의 차이는? 각각 어떻게 동작하는가?

> 두 제어 방식 모두 패킷 전송량을 조절하지만, 누구의 사정을 봐주느냐가 다릅니다.

### 흐름 제어 (Flow Control)
* 대상: 수신자(Receiver)
* 목적: 수신자의 데이터 처리 속도보다 송신자가 데이터를 보내는 속도가 빠를 때, 수신자의 버퍼가 넘치는(Overflow) 것을 방지합니다. Stop and Wait이나 Sliding Window 기법을 사용합니다.

### 혼잡 제어 (Congestion Control)
* 대상: 네트워크(Network)
* 목적: 네트워크가 처리할 수 있는 양보다 많은 데이터가 몰려 정체가 발생하는 것을 방지합니다. Slow Start나 Congestion Avoidance 기법을 통해 전송량을 점진적으로 조절합니다.

<br>

# 6. Sliding Window는 어떻게 동작하는가?

> Sliding Window는 하나 보내고 하나 응답을 기다리는 비효율을 해결하기 위해 등장했습니다.

* 원리
    * 수신 측에서 허용하는 범위(Window Size)만큼 ACK 없이도 데이터를 연속해서 보낼 수 있게 합니다.
* 동작
    * 수신 측에서 성공적으로 데이터를 받아 ACK를 보내면, 윈도우(보낼 수 있는 범위)가 옆으로 한 칸씩 이동(Sliding)하면서 다음 데이터를 전송합니다. 
* 이점
    * 네트워크의 대역폭을 효율적으로 사용하여 전송 속도를 크게 높일 수 있습니다.

<br>

# 7. UDP는 언제 사용하는가? (실시간 스트리밍, DNS, DHCP 등)

> UDP는 신뢰성을 포기한 대신 지연 시간(Latency) 최소화에 집중합니다.

### 실시간 스트리밍 및 VoIP
영상이나 음성 데이터는 아주 짧은 순간의 데이터 유실(화면 깨짐)보다, 데이터가 늦게 도착해서 화면이 멈추는 것이 더 치명적입니다. 따라서 재전송을 하지 않는 UDP가 유리합니다.

### DNS (Domain Name System)
DNS 요청은 매우 짧은 단발성 통신입니다. 연결을 맺고 끊는 3-way handshake 과정 자체가 실제 데이터 전송보다 더 큰 오버헤드가 되기 때문에 UDP를 사용합니다.

### DHCP
IP 주소가 할당되기 전에는 서버와 연결을 맺을 수 없으므로, 불특정 다수에게 뿌리는 브로드캐스트 방식의 UDP를 사용합니다.
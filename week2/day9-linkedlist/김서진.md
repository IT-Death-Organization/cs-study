# Day 9: 연결 리스트(Linked List)
> 📅 2025.02.21 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 연결 리스트의 중간 삽입이 O(1)이라는 말의 전제 조건은?
- [ ] 실제로 중간 위치를 찾으려면 O(n)이 걸리는데 왜 O(1)이라고 하는가?
- [ ] 이중 연결 리스트가 단일 연결 리스트보다 유리한 점과 단점은?
- [ ] 연결 리스트에서 사이클을 탐지하는 방법은? (Floyd's Cycle Detection)
- [ ] Runner 기법(Fast & Slow Pointer)은 어떻게 동작하는가?
- [ ] 연결 리스트를 뒤집는(reverse) 알고리즘을 설명하면?
---
### 1. 연결 리스트의 중간 삽입이 O(1)이라는 말의 전제 조건은?
결론부터 설명하자면, 삽일할 "위치의 노드 포인터를 이미 알고 있어야 한다"는 뜻이다. 
즉, 이미 원하는 위치를 잡아 두었을 경우여야 한다.

---

### 2. 실제로 중간 위치를 찾으려면 O(n)이 걸리는데 왜 O(1)이라고 하는가?
연결리스트는 노드 구조체로 데이터와 다음 노트를 가리키는 포인터로 구성되어 있다. 이렇기에 삽일할 위치를 찾기 위해 head부터 순차 탐색을 하여 원하는 위치까지 이동해야 하기 때문에  중간 위치를 찾으려면 탐색은 O(n)이다. 위치를 찾는 과정을 포함하면 탐색 O(n) + 삽입 O(1) = O(n)이다. 하지만, 이미 위치를 알고 있는 경우는 O(1) 시간복잡도를 갖는다.

이러한 연결리스트 A -> B -> C가 있다고 가정하자. B 뒤에 새 노드 X를 끼워 넣고 싶다면, 
1. X가 C를 가리키게 한다.
2. B가 X를 가리키게 한다.

즉, 이 두 단계를 B 노드를 기준으로 코드로 정리한다면,
Node* newNode = new Npde{25, nullptr};
Node* prev = B;
newNode->next = prev->next; //1단계: 새 노드가 C를 가리키게 함
prev->next = newNode; //2단계: B가 새 노드를 가리키게 함

이 순서는 중요한데, 항상 새 노드를 먼저 연결하고, 그 다음 기존 연결을 바꾼다.

시간복잡도가 O(1)인 이유는 연산 횟수와 상관없이 위 마지막 두 줄만 실행되기 때문이다. 즉, 위치를 이미 알고 있기 때문에 이 상태에서 삽입만 따시는 것은 O(1)이다.

---

### 3. 이중 연결 리스트가 단일 연결 리스트보다 유리한 점과 단점은?
이중 연결 리스트는 나를 기준으로 앞/뒤 노드를 가리킨다. 즉, 양방향 이동이 가능한 구조이다.
1. 이중 연결리스트의 장점:
- 앞으로 이동 가능
A -> B -> C인 단일 연결리스트에서는 C에서 B로 이동하지 못한다. 하지만 이중 연결 리스트에서는 A<->B<->C 구조이므로 C -> B로 이동이 가능하다.

- 삭제가 더 단순
단일 연결리스트에서는 내 노드를 기준으로 앞의 노드를 알고 있어야 삭제가 가능했다. 앞의 노드를 알아야, 내가 삭제되고 앞의 노드와 다음 노드를 연결해주기 때문이다. 하지만, 이중 연결 리스트에서는 내가 이미 앞의 노드 주소를 가지고 있기 때문에 prev를 따로 들고 다닐 필요가 없어 삭제가 더 간단해진다.

2. 이중 연결리스트의 단점:
- 메모리 사용량 증가
단일: data + next
이중: data + prev + next
    -> 포인터 1개 추가되므로 노드 1개당 메모리 2배 가까이 증가된다.

- 구현 복잡도 증가
삽입 시 포인터 4개를 수정해야 한다. 

newNode->next = cur;
newNode->prev = cur->prev;
cur->prev->next = newNode;
cur->prev = newNode;

따라서 실수 가능성이 증가한다.

---

### 4. 연결 리스트에서 사이클을 탐지하는 방법은? (Floyd's Cycle Detection)
연결리스트 사이클 탐지의 정석이 바로 Floyd's Cycle Detection이다.
이는 단순히 "사이클 찾기"가 아닌, 그래프에서 루프를 감지하는 일반적 패턴이다. 즉, slow와 fast 포인터 두개를 사용해 fast가 slow보다 빠르므로 원형 트랙에서 추월을 한다. 

이는 무한 루프를 방지하고 공간을 쓰지 않는 효율적 사이클 탐지를 위해 사용한다. 

---

### 5. Runner 기법(Fast & Slow Pointer)은 어떻게 동작하는가?
Runner 기법이란 같은 자료구조를 속도가 다른 두 포인터로 동시에 순회하는 기법이다.
slow -> 1칸씩 이동하고,
fast -> 2칸씩 이동한다. 

즉, 
slow = slow->next;
fast = fast->next->next;
이며 핵심은 속도 차이다. 

예를 들어, 1 -> 2 -> 3 -> 4 ->5 라면, 
fast가 1 -> 3 -> 5 순서로 탐색하여 마지막인 5에 도달할때, slow는 1부터 순차적으로 탐색하여 정확히 중간인 3에 도달한다. 왜냐하면 fast는 slow의 두배 속도로 움직이기 때문이다.

다른 예시로 사이클이 있다면, slow == fast인 경우가 생긴다. 이는 fast가 slow보다 1칸씩 더 전진하기 때문이다. 

시간복잡도는 O(n) 이며, 공간복잡도는 O(1)이다.

정리하자면, 속도 차이를 이용해 구조적 성질을 드러낸다. 끝을 빠르게 감지하고, 중간을 찾고, 순환을 잡아낸다. 

---

### 6. 연결 리스트를 뒤집는(reverse) 알고리즘을 설명하면?
원래 리스트인 1 -> 2-> 3 -> 4 -> Null이다.
반면, 이를 뒤집으면 4 -> 3 -> 2 -> 1이 된다.

이는 각 노드의 next 방향을 반대로 바꾸면 된다. 이때 필요한 포인터는 3개이다. 
prev: 이전 노드
cur: 현재 노드
next: 다음 노드 임시 저장

다음은 알고리즘 동작 과정이다. 
next = cur->next;   // 다음 노드 저장
cur->next = prev;   // 방향 뒤집기
prev = cur;         // prev 이동
cur = next;         // cur 이동

즉, 뒤집는 시간복잡도는 O(n)이고, 공간복잡도는 O(1)이다. 

연결리스트 reverse는 각 노드의 next를 이전 노드로 바꾸면서 한번 순회하면 된다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 9: 연결 리스트(Linked List)
> 📅 2025.02.21 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 연결 리스트의 중간 삽입이 O(1)이라는 말의 전제 조건은?
- [x] 실제로 중간 위치를 찾으려면 O(n)이 걸리는데 왜 O(1)이라고 하는가?
- [x] 이중 연결 리스트가 단일 연결 리스트보다 유리한 점과 단점은?
- [x] 연결 리스트에서 사이클을 탐지하는 방법은? (Floyd's Cycle Detection)
- [x] Runner 기법(Fast & Slow Pointer)은 어떻게 동작하는가?
- [x] 연결 리스트를 뒤집는(reverse) 알고리즘을 설명하면?
---

<br>

# 1. 연결 리스트의 중간 삽입이 O(1)이라는 말의 전제 조건은?

"연결 리스트의 중간 삽입이 O(1)이다"라는 말은 딱 "삽입"이라는 과정만 보고 이야기하는 것입니다.

즉, 이미 삽입할 위치의 이전 노드(또는 해당 위치)의 주소를 이미 알고 있다는 전제 조건이 깔려 있습니다.

<br>

# 2. 실제로 중간 위치를 찾으려면 O(n)이 걸리는데 왜 O(1)이라고 하는가?

알고리즘의 효율성을 논할 때, 우리는 각 기능의 순수한 비용만 측정합니다.

연결 리스트의 중간 삽입 과정에서 시간 복잡도를 분석할 때 탐색과 수정 작업을 분리해서 생각합니다. 

그래서 삽입 작업 자체의 비용만 고려하여 $O(1)$이라고 합니다.

### VS 배열

배열과 연결 리스트를 비교했을 때 배열에서는 삽입 과정만 보더라도 그 뒤의 데이터를 한 칸씩 밀어내는 Shift 작업 때문에 $O(n)$의 비용이 듭니다.

때문에 연결 리스트는 "삽입"의 관점에서 배열보다 상대적 우위에 있고, 이를 강조하기 위해 $O(1)$이라고 말한다고 생각할 수 있습니다.

<br>

# 3. 이중 연결 리스트가 단일 연결 리스트보다 유리한 점과 단점은?

단방향으로만 연결된 연결 리스트의 답답함을 해열하기 위해 등장한 것이 이중 연결 리스트(Doubly Linked List)입니다.

다음 노드의 주소만 저장하는 단일 연결 리스트와 달리 이중 연결 리스트는 말 그대로 다음 노드와 이전 노드의 주소를 모두 저장합니다.

자바의 LinkedList는 내부적으로 이중 연결 리스트로 구현되어 있습니다. 약간의 메모리를 더 쓰더라도 탐색과 삭제의 편의성을 챙기는 것이 현대 프로그래밍 환경에서는 더 이득이기 때문입니다.

### 단점

단점은 너무나 당연하게도 추가적인 메모리 공간이 필요하다는 것입니다. 데이터 양이 많아질 수록 메모리 사용량이 많아지는 것은 어쩔 수 없습니다.

또한 구현과 관리의 측면에서 복잡합니다. 코드가 길어지고 실수하기 쉽습니다.

### 장점

양방향으로 탐색이 가능하기 때문에 굉장히 유연합니다. 역방향 탐색도 됩니다.

단일 연결 리스트에서는 특정 노드를 삭제하려면, 그 이전 노드의 다음 주소(Next)를 수정해주기 위해 Head부터 다시 뒤져야 하지만, 이중 연결 리스트에서는 이전 노드의 주소를 알고있기 때문에 그 과정이 생략됩니다.

또한 혹여나 한쪽 포인터가 끊어지더라도 다른 쪽 포인터로 연결을 복구할 수 있습니다.

<br>

# 4. 연결 리스트에서 사이클을 탐지하는 방법은? (Floyd's Cycle Detection)

연결 리스트에서 매우 유명한 알고리즘이 하나 있습니다. 바로 사이클을 탐지하는 알고리즘인 플로이드의 순환 탐지 알고리즘(Floyd's Cycle Detection Algorithm)입니다. 토끼와 거북이 알고리즘이라고도 불립니다.

연결 리스트에서 마지막 노드가 그 다음으로 `null`이 아니라, 리스트 중간의 어떤 노드를 가리키고 있다면 그 연결 리스트는 사이클이 존재한다고 말합니다.

이것을 탐지하기 위해선 두 개의 포인터(토끼와 거북이)를 사용합니다.

거북이는 한 번에 한 칸씩 이동하고, 토끼는 한 번에 두 칸씩 이동합니다.

만약 연결 리스트에 사이클이 없다면 정상적으로 토끼가 먼저 `null`에 도착합니다.

하지만 사이클이 존재한다면 토끼와 거북이가 언젠가는 만나는 지점이 생깁니다.

이 방식은 리스트를 한 바퀴정도 돌면 결론이 나기 때문에 시간 복잡도는 $O(n)$입니다.

그리고 메모리 측면에선 포인터 2개만을 사용하므로 공간 복잡도는 $O(1)$입니다.

<br>

# 5. Runner 기법(Fast & Slow Pointer)은 어떻게 동작하는가?

4번에서 소개한 토끼와 거북이 알고리즘을 조금 더 일반화한 것이 바로 러너(Runner) 기법입니다.

러너 기법은 토끼와 거북이 알고리즘과 마찬가지로 한 번에 한 칸씩 이동하는 느린 러너(Slow Runner)와 한 번에 두 칸씩 이동하는 빠른 러너(Fast Runner)를 사용합니다.

### 중간 지점 찾기
가장 대표적인 활용 사례로, 리스트의 길이를 모를 때 중간 지점을 찾기 위해 사용합니다.

빠른 러너가 리스트의 끝(null)에 도착했을 때, 느린 러너는 정확히 리스트의 중간 지점을 가리키게 됩니다.

### 끝에서 K번째 노드 찾기
이 경우에는 두 러너의 속도를 같게 설정한 후, 한 러너를 K번째 앞에서 출발시키면 뒤에 따라가는 러너는 앞의 러너가 끝에 도착했을 때 정확히 뒤에서 K번째 노드를 가리키게 됩니다.

### 사이클 탐지
4번에서 설명한 토끼와 거북이 알고리즘이 바로 이 경우입니다.
<br>

이러한 러너 기법의 장점은 리스트의 길이를 미리 알 필요가 없다는 것입니다.

<br>

# 6. 연결 리스트를 뒤집는(reverse) 알고리즘을 설명하면?

연결 리스트를 뒤집기 위해 총 3개의 포인터를 사용합니다.

* `prev`: 현재 노드의 이전 노드를 가리킵니다. 초기값은 `null`입니다.
* `curr`: 현재 노드를 가리킵니다. 초기값은 `head`입니다.
* `next`: 현재 노드의 다음 노드를 가리킵니다. 초기값은 `head.next`입니다. 다음 노드로 가는 길을 잃지 않기 위해 미리 저장해두는 용도입니다.

### 반복 로직

1. `next`에 `curr.next`를 저장합니다.
2. `curr.next`를 `prev`로 변경합니다. (이 부분이 노드가 앞이 아닌 뒤를 보게 하는 핵심 로직)
3. `prev`를 `curr`로 변경합니다. (이제 다음 노드로 이동할 준비를 합니다.)
4. `curr`를 `next`로 변경합니다. (이제 다음 노드로 이동합니다.)

이 과정을 반복하다가 `curr`가 `null`이 되면 반복이 종료되고, `prev`가 새로운 헤드가 됩니다.
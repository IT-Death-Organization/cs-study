# Day 12: 해시 테이블(Hash Table)
> 📅 2025.02.24 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 해시 충돌은 왜 불가피한가? (비둘기집 원리)
- [x] Chaining과 Open Addressing의 장단점은?
- [x] Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?
- [x] Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?
- [x] Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?
- [x] 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?
---
Hash Table 핵심 정리 (면접 대비)

⸻

1. 해시 충돌은 왜 불가피한가? (비둘기집 원리)

핵심 개념: Pigeonhole Principle
	•	키 공간(Key Space)은 사실상 무한에 가깝다. (모든 문자열, 객체 등)
	•	해시 테이블의 버킷 수는 유한하다.
	•	서로 다른 두 키 k1 ≠ k2에 대해 h(k1) = h(k2)인 경우가 반드시 존재한다.

수학적 구조
	•	키 개수: n
	•	버킷 개수: m
	•	n > m이면 최소 하나의 버킷에는 2개 이상의 원소가 들어간다.

따라서 충돌은 설계 실패가 아니라 수학적으로 불가피한 현상이다.

⸻

2. Chaining vs Open Addressing

2.1 Separate Chaining

구조
	•	각 버킷에 Linked List 또는 Tree를 둔다.
	•	충돌 시 해당 버킷 내부 자료구조에 추가한다.

장점
	•	Load Factor가 1을 초과해도 동작 가능
	•	삭제가 단순함
	•	클러스터링 문제 없음
	•	구현이 비교적 단순

단점
	•	포인터로 인한 메모리 오버헤드
	•	캐시 친화성 낮음
	•	최악의 경우 O(n)

⸻

2.2 Open Addressing

구조
	•	충돌 시 테이블 내부에서 다른 빈 슬롯을 탐색
	•	모든 데이터가 배열 안에 저장됨

장점
	•	추가 포인터 메모리 불필요
	•	연속 메모리 사용 → 캐시 효율 높음
	•	공간 지역성(locality) 우수

단점
	•	Load Factor에 매우 민감
	•	삭제 구현이 복잡 (tombstone 필요)
	•	Clustering 발생

⸻

3. Linear Probing의 Clustering 문제

Primary Clustering

Linear Probing 탐색 방식:

h(k)
h(k) + 1
h(k) + 2
...

발생 원인
	•	특정 구간에 연속적으로 충돌이 발생하면 하나의 덩어리(cluster)가 형성된다.
	•	이후 충돌하는 키들은 그 클러스터 뒤에 붙는다.
	•	클러스터가 커질수록 평균 탐색 길이가 증가한다.
	•	더 많은 충돌을 유발하는 악순환 구조가 된다.

결과
	•	평균 탐색 시간이 증가
	•	Load Factor가 높아질수록 급격히 성능 저하
	•	최악의 경우 O(n)

⸻

4. Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?

정의

α = n / m

	•	n: 저장된 원소 수
	•	m: 버킷 수

Open Addressing 평균 탐색 비용

성공 탐색 평균 비용은 대략:

(1/2) * (1 + 1 / (1 - α))

α → 1이면:

1 / (1 - α) → 무한대

즉, Load Factor가 1에 가까워질수록 탐색 길이가 급격히 증가한다.

왜 0.75인가?
	•	실험적으로 성능과 메모리 사용량의 균형점
	•	Java HashMap도 기본 threshold로 0.75 사용
	•	그 이상부터 probe 길이가 비선형적으로 증가

⸻

5. Rehashing은 언제 발생하며 어떻게 동작하는가?

발생 조건

보통 다음 조건에서 발생:

Load Factor > Threshold (예: 0.75)

동작 과정
	1.	기존 테이블 크기를 보통 2배로 확장
	2.	새로운 배열 생성
	3.	모든 기존 키를 다시 해시 계산하여 재삽입

주의: 단순 복사가 아니라 새로운 capacity 기준으로 해시를 다시 계산해야 한다.

시간복잡도
	•	평소 삽입: O(1)
	•	Rehash 발생 시: O(n)
	•	Amortized Insert: O(1)

2배 확장 전략을 사용하면 전체 재배치 비용이 선형적으로 제한되기 때문에 평균적으로는 O(1)을 유지한다.

⸻

6. 해시 테이블의 최악 시간복잡도가 O(n)인 이유

Chaining의 경우
	•	모든 키가 동일한 버킷으로 해시되면
	•	해당 버킷이 길이 n의 리스트가 된다.
	•	탐색, 삽입, 삭제 모두 O(n)

Open Addressing의 경우
	•	모든 슬롯이 거의 차 있고
	•	원하는 키가 마지막에 있거나 존재하지 않으면
	•	선형 탐색을 n번 수행

근본 원인
	•	해시 함수가 균등 분포를 보장하지 못할 수 있다.
	•	공격적 입력(Adversarial input)에 취약할 수 있다.

따라서 평균 시간복잡도는 O(1)이지만, 최악의 경우는 O(n)이다.

⸻



## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

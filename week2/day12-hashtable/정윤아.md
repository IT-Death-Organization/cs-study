# Day 12: 해시 테이블(Hash Table)
> 📅 2025.02.24 | 📁 Week 2

---

## 🧠 학습 질문
- [x] 해시 충돌은 왜 불가피한가? (비둘기집 원리)
- [x] Chaining과 Open Addressing의 장단점은?
- [x] Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?
- [x] Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?
- [x] Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?
- [x] 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?

---

## Q1. 해시 충돌은 왜 불가피한가? (비둘기집 원리)

[답변]
* 해시 함수는 매우 큰(혹은 사실상 무한한) 키 공간을 유한한 크기의 버킷(테이블 인덱스) 공간으로 매핑
  - 가능한 입력(키)의 개수 > 가능한 출력(인덱스)의 개수
    => 서로 다른 두 키가 같은 인덱스로 매핑되는 충돌은 불가피
* 비둘기집 원리: 비둘기집(상자)보다 비둘기(원소)가 많으면 어떤 상자에는 비둘기가 2마리 이상 들어간다

---

## Q2. Chaining과 Open Addressing의 장단점은?

[답변]
* Chaining
  - 해시 테이블에서 어떤 인덱스(버킷)에 충돌 발생 -> 해당 버킷 안에 여러 원소 '연결'해서 보관
  - 각 버킷이 연결 리스트(or 동적 배열 등)을 가짐: 같은 인덱스로 해시된 값들이 들어감
  - 장점
    1. 충돌 처리 구조가 단순, 버킷에 여러 원소를 연결 리스트(or 동적 배열 등)로 담음 -> 테이블이 꽉 차도 저장 자체는 가능
    2. 삭제가 비교적 쉬움(체인에서 노드 제거)
    3. 로드 팩터가 1을 넘어도 동작 가능(성능은 저하), 설계 유연
  - 단점
    1. 포인터/노드 오버헤드 발생 + 메모리 사용 증가
    2. 캐시 지역성 떨어짐(연속 메모리 X) -> 실제 성능 불리
    3. 최악의 경우: 한 버킷에 몰림 -> 리스트 탐색 길어짐
* Open Addressing(개방 주소법)
  - 충돌 발생 -> 테이블 내부의 다른 빈 칸을 직접 찾아서 넣는 방식
  - 원소는 모두 테이블 안에만 저장
  - 장점
    1. 모든 원소를 테이블 내부 배열에 저장 -> 캐시 친화적 + 실제 탐색 빠름
    2. 추가적인 포인터 구조 X -> 메모리 오버헤드 적음
  - 단점
    1. 로드 팩터가 커질수록 급격히 성능 저하 + 테이블 가득 차면 삽입 불가
    2. 삭제가 까다로움 -> 삭제 표시를 둠 -> 누적시 성능 저하
    3. probing 방식에 따라 clustering 문제 발생 가능
   
[보완]
* 로드 팩터(Load Factor)
  - 해시 테이블이 얼마나 차 있는지 나타내는 값
  - 일반적으로 \alpha = \frac{n}{m} 로 정의
    - n: 현재 저장된 원소 수
    - m: 버킷(슬롯) 수 (테이블 크기)
* Probing
  - Open Addressing에서 충돌이 발생했을 때 다음으로 확인할 슬롯을 정해가며 빈 칸/목표 키를 찾는 탐색 규칙
  - 대표적인 방식
    - Linear Probing: i, i+1, i+2... 한 칸씩 순차 이동
    - Quadratic Probing: i+1^2, i+2^2... 제곱 간격으로 이동
    - Double Hashing: 두 번째 해시값을 점프 간격으로 사용하여 이동
  - probing이 길어질수록 성능 저하

---

## Q3. Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?

[답변]
* Linear Probing: 연속적으로 빈 슬롯 탐색
  - 한 번 연속 구간(cluster)이 생기면 이후에 들어오는 키들이 해당 구간에 더 자주 부딪힘
    -> 구간 뒤쪽에 삽입 -> 연속 구간 점점 커짐(Primary Clustering)
    => 탐색/삽입 시 평균적으로 더 긴 probing 필요 -> 성능 저하

[보완]
* Primary Clustering(1차 군집화): Linear Probing에서 특히 심함. '연속된 빈칸 탐색'
* Quadratic Probing: primary clustering은 완화하나 같은 초기 해시값을 가진 키들이 유사한 경로르 따라가는 Secondary Clustering 발생 가능
* Double Hashing: clustering 잘 완화

---

## Q4. Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?

[답변]
* 로드 팩터가 커질수록 충돌 확률 증가
  - 같은 크기 m의 버킷(슬롯)에 더 많은 원소 n를 넣고 있다
  - 비어 있는 버킷 비율 감소, 차 있는 버킷 비율 증가 -> 새로 들어오는 원소가 “사용 중인 버킷"에 떨어질 가능성(=충돌)이 커짐
* Open Addressing에선 probing 길이가 급격히 증가
* \alpha > 0.75에서 평균 탐색/삽입 비용이 증가하여 성능이 저하

[보완]
* Open Addressing은 \alpha가 1에 가까워질수록 실패 탐색/삽입 비용이 매우 커짐
* Chaining은 \alpha가 커지면 평균 체인 길이가 늘어 비용이 증가하지만, Open Addressing처럼 급격한 임계 악화가 더 두드러지는 경우가 많음

---

## Q5. Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?

[답변]
* Rehashing
  - 로드 팩터가 임계값을 넘을 때 테이블 크기 증가(대개 2배) -> 기존 모든 원소를 새 테이블에 다시 삽입
  - 크기가 바뀌면 인덱스 계산 h(k) mod m 에서 m이 달라지므로 기존 위치 그대로 사용 X -> 재배치 필요
  - 시간복잡도
    - 한 번의 rehash: 원소 n개 새 테이블에 삽입 -> O(n)
    - amortized: O(1)
   
[보완]
* Open Addressing은 tombstone 누적이 심할 때도 “정리 목적”으로 rehash를 수행해 성능을 회복
  - tombstone: 원소 삭제 시 해두는 표식 (실제 삭제 X)
  - tombstone 누적: 삭제 표시 쌓임 -> 탐색/삽입 시 probing 길어짐
    - 실제 삭제하지 않는 이유:
    - Open Addressing은 충돌이 나면 다음 칸으로 밀려서 저장 -> 어떤 키를 찾을 때는 “원래 해시 위치부터 연속으로” 검사 -> 진짜 빈 칸(empty) 을 만나면 “그 뒤에는 더 이상 있을 수 없다”고 보고 탐색 종료

---

## Q6. 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?

[답변]
* 평균적으로는 O(1)이나, 최악의 경우 충돌이 한 곳에 몰리거나 probing 매우 길어짐 -> 한 번의 연산(탐색/삽입/삭제)이 테이블에 있는 원소 수 n에 비례할 수 있음
  - Chaining: 최악의 경우 모든 키가 같은 버킷으로 해시 -> 한 버킷의 체인 길이 n -> 선형 탐색 필요 => O(n)
  - Open Addressing: 빈 슬롯/특정 키 탐색 -> 거의 모든 슬롯 순회 상황 발생 가능 -> O(n) (높은 로드 팩터 + clustering + 불리한 해시 분포)
 
[보완]
* 실무 구현: 해시 난수화(seed), 버킷 트리화, 적절한 리사이징, 더블 해싱 등으로 최악 상황의 빈도를 낮춤
  - 해시 난수화: 해시 함수 계산에 비밀값(seed) 을 섞어, 같은 입력 키라도 실행/프로세스마다 해시 결과가 달라지게 하는 방식
  - 버킷 트리화: Chaining에서 어떤 버킷의 체인이 너무 길어지면(충돌이 한 버킷에 몰리면) 연결 리스트 대신 균형 트리(예: Red-Black Tree) 로 바꿔 저장
  - 적절한 리사이징/리해싱: 로드 팩터가 임계값을 넘거나, tombstone이 많아지는 등 “혼잡”해지면 테이블 크기를 키우고 원소를 재배치
  - 더블 해싱: Open Addressing에서 probing할 때, 이동 간격(step)을 한 칸씩 고정(Linear)하지 않고 두 번째 해시 함수 값으로 점프 폭을 정하는 방식

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

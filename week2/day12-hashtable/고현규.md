# Day 12: 해시 테이블(Hash Table)
> 📅 2025.02.24 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 해시 충돌은 왜 불가피한가? (비둘기집 원리)
- [x] Chaining과 Open Addressing의 장단점은?
- [x] Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?
- [x] Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?
- [x] Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?
- [x] 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?
---
<br>

# 1. 해시 충돌은 왜 불가피한가? (비둘기집 원리)

해시 테이블은 해시 함수를 사용해 저장하고자 하는 값의 키를 배열의 인덱스로 변환하여 저장합니다.

이러한 구조의 해시 테이블은 검색 속도가 $O(1)$로 매우 빠르다는 장점을 가졌지만, 키와 인덱스가 정확히 1대1로 매칭되지는 않기에 서로 다른 두 개의 키가 같은 인덱스로 변환될 위험이 있습니다. 이러한 경우를 "해시 충돌(Hash Collision)"이라고 합니다.

수학적으로 보면 이러한 충돌은 일어날 수밖에 없습니다. 비둘기가 n마리 있고 비둘기집이 m개 있을 때, 만약 n > m 이라면 적어도 하나의 비둘기집에는 두 마리 이상의 비둘기가 들어가야 합니다. 이를 "비둘기집 원리(Pigeonhole Principle)"라고 합니다.

이러한 특징때문에 좋은 해시 테이블 설계는 충돌을 어떻게 막느냐도 중요하지만, 충돌이 났을 때 얼마나 효율적으로 수습하냐도 중요합니다.

<br>

# 2. Chaining과 Open Addressing의 장단점은?

1번의 마지막에 말한 "얼마나 효율적으로 수습하냐"에 대한 방법으로 Chaining과 Open Addressing이 있습니다.

쉽게 말하면 그 자리에 뒤로 줄 세우거나(Chaining), 다른 빈 자리를 찾아 떠나는(Open Addressing) 것입니다.

| 특징 | Chaining (체이닝) | Open Addressing (개방 주소법) |
| :--- | :--- | :--- |
| **저장 방식** | 버킷을 연결 리스트나 트리로 연결 | 테이블의 빈 공간을 찾아 저장 |
| **테이블 크기** | 데이터가 테이블 크기를 넘어도 저장 가능 | 테이블 크기(공간)가 곧 데이터 한도 |
| **메모리 사용** | 추가 노드 및 포인터 메모리 필요 | 추가 메모리 없음 (배열 내부만 사용) |
| **캐시 효율** | 낮음 (리스트가 메모리 곳곳에 흩어짐) | 높음 (데이터가 배열에 인접해 있음) |
| **삭제 연산** | 단순함 (노드만 삭제) | 복잡함 (삭제된 자리를 표시해야 함) |
---

### 1) Chaining (Separate Chaining)
각 인덱스(Bucket)를 연결 리스트로 관리하는 방식입니다.

구현이 비교적 단순하고, 해시 함수가 조금 별로더라도 어느정도 성능 유지가 됩니다.

하지만 데이터가 많아지면 리스트가 길어져 탐색 속도가 $O(n)$에 가까워질 수 있습니다. 또한, 포인터를 저장하기 위한 추가 메모리 오버헤드가 발생합니다.

### 2) Open Addressing (개방 주소법)
충돌이 발생할 경우 정해진 규칙(선형 탐색, 이차 탐색 등)에 따라 테이블의 비어있는 다른 칸을 찾습니다.

Chaining과 달리 추가적인 메모리가 필요없고 데이터가 연속적으로 꽉꽉 저장되므로 CPU 캐시 적중률(Chche Hit Rate)이 높아져 성능에 유리합니다.

하지만 테이블이 꽉 차면 성능이 급격히 나빠지고, 특정 영역에 데이터가 몰리는 "클러스터링(Clustering)" 문제가 발생합니다.

<br>

# 3. Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?

Linear Probing(선형 탐사법)은 Open Addressing의 한 종류로, 충돌이 발생할 경우 바로 다음 빈칸(index + 1, index + 2, ...)을 찾는 방식입니다.

이 방식은 단순하지만, 이로 인해 데이터가 몰리는 "클러스터링(Clustering)" 현상이 발생합니다.

클러스터링 현상이란 해시 테이블의 특정 영역에 데이터들이 눈덩이처럼 뭉쳐서 불어나는 현상을 말합니다. 한번 클러스터가 형성되면, 그쪽에 해시된 데이터들은 모두 덩어리 끝에 붙게 되면서 악순환이 반복됩니다.

또한 데이터를 찾거나 넣을 때 이 덩어리에 걸리게 되면 그 큰 덩아리를 다 훑어야 하므로 해시 테이블의 장점인 $O(1)$ 탐색 속도가 저하됩니다.

이를 해결하기 위해 다음칸이 아닌 제곱만큼 건너뛰는 이차 조사(Quadratic Probing)나, 해시 함수를 한번 더 돌리는 이중 해시(Double Hashing) 등의 방법이 등장했습니다.

<br>

# 4. Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?

> Load Factor는 해시 테이블에 저장된 데이터의 수(n)를 테이블의 크기(m)로 나눈 값으로, 해시 테이블의 공간 활용도를 나타내는 지표입니다.

해시 테이블의 빈 공간이 적어질 수록 새로운 데이터를 넣을 때 충돌이 발생할 확률이 기하급수적으로 높아집니다.

Load Factor가 작다면 충돌 확률은 적어서 성능은 좋지만 빈 공간이 너무 많아 메모리 낭비가 심해지고, Load Factor가 높다면 메모리 효율은 좋지만 충돌 확률이 높아져 탐색 시간이 증가합니다.

너무 작지도, 크지도 않은 시간 복잡도와 공간 복잡도의 균형을 맞춘 최적의 지점은 $0.75$입니다.

통계학적으로 부하율이 $0.75$를 넘어가는 순간부터 해시 충돌로 인한 성능 저하 곡선이 가파르게 상승하는 임계점에 도달합니다.

Java의 HashMap을 포함한 많은 라이브러리가 기본 부하율을 $0.75$로 설정하고 있습니다.

기본적으로 해시 테이블은 검색 속도를 위해 메모리를 넉넉하게 쓰겠다는 전제 하에 설계된 자료구조입니다.

<br>

# 5. Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?

> Rehashing이란 데이터 구조에서 해시 테이블의 크기가 꽉 찼을 때, 테이블의 크기를 늘리고 기존 데이터들을 새로운 해시 함수를 사용하여 다시 저장하는 과정입니다.

Rehashing은 Load Factor가 $0.75$를 넘어서는 순간 발생합니다.

테이블 크기만 늘리지 않고 기존 데이터들을 다시 저장하는 이유는 해시 테이블의 인덱스는 보통 `hash(key) % array_size`로 결정되기 때문입니다.

Rehashing의 시간복잡도는 n개의 데이터를 모두 꺼내서 새 위치를 계산 후 다시 저장해야 하므로 $O(n)$입니다.

하지만 이전에 배운 분할 상환(Amortized Analysis)을 적용하면 Rehashing은 아주 가끔 발생하는 이벤트이므로 수많은 $O(1)$ 연산에 섞여 평균적으로는 $O(1)$의 시간복잡도를 가집니다.

<br>

# 6. 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?

아주 극단적으로 해시 함수가 바보같이 동작해서 모든 키에 대해 똑같은 해시 값을 반환한다면 최악의 경우가 발생합니다. 이를 해시 충돌의 극단화라고 부릅니다.

이 경우 Chaining방식이든, Open Addressing 방식이든 시간복잡도가 $O(n)$이 됩니다.

Chaining의 경우 모든 데이터가 하나의 버킷에 연결된 연결 리스트에 저장되므로, 결국 특정 데이터를 찾으려면 연결 리스트를 순차적으로 탐색해야 합니다. $O(n)$

Open Addressing의 경우 하나의 거대한 클러스터가 형성된 상황입니다. 따라서 데이터를 찾기 위해 테이블을 순차적으로 탐색해야 합니다. $O(n)$

데이터의 특성을 고려하지 못하고 특정 숫자에만 결과가 쏠리는 함수를 썼을 때 발생할 수도 있고, 해커가 의도적으로 해시 충돌이 빈번하게 일어나는 입력들만 골라서 보내는 Hash DOS 공격을 당했을 때도 발생할 수 있습니다.
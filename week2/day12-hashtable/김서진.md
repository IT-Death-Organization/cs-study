# Day 12: 해시 테이블(Hash Table)
> 📅 2025.02.24 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 해시 충돌은 왜 불가피한가? (비둘기집 원리)
- [ ] Chaining과 Open Addressing의 장단점은?
- [ ] Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?
- [ ] Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?
- [ ] Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?
- [ ] 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?
---

## 1. 해시 충돌은 왜 불가피한가? (비둘기집 원리)
해시 함수는 임의 길이의 입력(key)를 받아서 고정된 범위의 정수 값(index)로 변환한다.

문제는 다음이다:
입력(key)의 가짓수는 사실상 무한하다. 그러나 해시 테이블의 크기는 예를 들어 1000칸이라고 정할 수 있듯 유한하다. 여기서 수학적으로 충돌은 반드시 발생하게 된다. 

예를 들어, 비둘기집 원리 n개의 비둘기를 m개의 집에 넣는데 n > m 이라면 최소 한 집에는 두 마리 이상이 들어간다.

이를 해시 상황에 적용하면:
    비둘기 = key
    비둘기집 = 해시 테이블 index

즉, 
    테이블 크기 = 10
    key 개수 = 11

    → 11개를 10칸에 넣으면
    최소 한 칸에는 2개 이상 들어간다.

다시 말하면, 충돌은 논리적으로 필연적이다.
해시 충돌은 해시 함수가 나빠서가 아니라 구조적으로 불가피한 현상이다. 

---

## 2. Chaining과 Open Addressing의 장단점은?
### 2-1. Chaining
Chanining은 각 index에 연결리스트(또는 다른 자료구조)를 둔다.
    예: index 3 → [A] → [B] → [C]

장점:
    - 구현이 단순하다. 충돌이 나면 그냥 리스트 뒤에 붙이면 끝이다. 빈 칸 탐색도 필요 없고, 재배치 계산도 필요 없다.
    - 테이블이 가득 차도 삽입 가능하다. Open Addressing은 **테이블의 빈 칸**이 반드시 필요하다. 하지만 Chaining은 한 index에 여러개 저장이 가능하다. 테이블이 100% 사용중이어도 index 3에 20개가 달려도 된다. 힙 메모리에서 계속 할당되기 때문! 즉, **테이블의 크기**와 **저장 가능한 원소 수**가 직접적으로 연결되지 않는다.
    - 삭제가 쉽다. 그냥 해당 리스트에서 노드를 제거하면 된다. Open Addressing에서는 삭제하면 probing 경로가 깨질수도 있고 관리가 복잡하다. 반면 Chaining은 구조가 독립적이기 때문에 다른 bucket에는 영향이 없다.

단점:
    - 메모리 추가(포인터) 사용한다. 각 노드는 next 포인터가 추가된다. 동적 할당 비용이 발생하고 저장 데이터 외에 추가 메모리가 필요하다. 반면 Open Addressing은 배열만 쓰므로 이 비용이 없다.
    - cache locality가 낮다. 노드가 메모리에 여기저기 흩어져 있기 때문이다. 배열이라면 연속적인 메모리에 저장되어 있으니 속도가 빠를것이다.
    - 최악의 경우 O(n)이다. 해시 함수가 나쁘거나 모든 key가 같은 bucket으로 들어가면 index 3 -> n개 연결 리스트가 생성된다. 이때 탐색은 O(n)이 되므로 해시 테이블이 사실상 연결리스트 1개가 되는 상황이다.

### 2-2. Open Addressing (개방 주소법)
충돌이 나면 **테이블 내부에서 다른 빈 칸을 찾아 저장**하여 별도 리스트를 사용하지 않는다. 즉, 추가 자료구조를 사용하지 않는다.

대표 방식으로는 다음이 있다. 
    - Linear Probing(충돌 발생하면 한 칸씩 오른쪽으로 이동)
    - Quadratic Probing(충돌 시 제곱 간격으로 이동)
    - Double Hashing(두 번째 해시 함수를 사용)

장점: 
    - 추가 메모리 필요 없다. 구조가 단순한 배열 하나이기 때문이다. 
    - 연속된 메모리이므로 cache 효율이 좋다. Linear Probing의 탐색은 연속 접근이 발생한다. 캐시 라인 단위로 읽는 cpu는 매우 빠를것이다.
    - 구현이 단순하고 메모리 단편화가 적다. 동적 할당이 없기 때문이다. Chaining은 new 호출을 반복하고 힙 메모리 단편화가 가능하다. 반면 Opening Addressing은 고정 배열을 사용하여 메모리 구조를 예측할 수 있다는 장점이 있다.

단점:
    - 테이블이 꽉차면 삽입 불가하다. 충돌 시 빈 칸을 찾아야 하는 구조이기 때문이다. 빈 칸이 없으면 더 이상 저장 불가하다. Chaining은 한 bucket에 여러 개 달 수 있지만 Open Addressing은 **1칸 = 1원소**이기에 구조적으로 제한된다.

    - Load Factor가 높아질수록 급격히 느려진다. Load Factor란, α = 저장 원소 수 / 테이블 크기이다. 

        예:
        α = 0.9(90%가 이미 차 있음)
        이때 새로운 원소를 삽입하면빈 칸 찾을 확률은 낮아지고 탐색 길이는 길어진다.
    즉,
    탐색 시간은 1 / (1 - α)에 비례하여 증가한다. 
    α → 1 에 가까워질수록 성능은 폭발적으로 나빠진다.

    - 삭제가 까다롭다. 예를 들어, A → B → C Linear Probing으로 들어갔다고 하자. 만약 B를 그냥 삭제하면 A → (빈칸) → C 이게 된다. 이때 C를 찾는다면, A 확인하고 다음이 빈칸이기 때문에 탐색을 중단하여 C를 찾지 못한다. 그래서 삭제는 완전 삭제가 아니라 tombstone 표시를 하게 된다. 이러한 이유로 Open Addressing은 구조적으로 삭제가 어렵다.

---

## 3. Linear Probing에서 clustering 문제는 무엇이며 왜 발생하는가?
1) Clustering이란?
Linear Probing에서 연속된 데이터 구간이 길게 뭉치는 현상을 말한다.
예를 들어,
[ ][ ][A][B][C][D][ ][ ]
3~6번 index가 하나의 덩어리(cluster)가 된 상태이다.

Linear Probing의 탐색 방식은 다음과 같다:
    **index = (h(k) + i) % M**
    즉, **항상 +1씩** 이동한다.

이미 cluster가 형성된 상태에서 새로운 충돌이 발생하면,
    1) 충돌 발생
    2) 그 cluster 끝까지 이동
    3) 끝에 추가

즉,
덩어리 → 더 많은 충돌 → 덩어리 확장 → 더 많은 충돌이 발생하게 된다.
이것을 Primary Clustering이라고 한다.

그렇다면 이게 왜 문제가 될까?
cluster가 커질수록
    - 탐색 길이 증가
    - 삽입 비용 증가
    - 평균 O(1) 성능이 무너지게 된다.

결국, 선형 탐색 구간이 길어져 거의 O(n)에 가까워질 수 있다.

---

## 4. Load Factor가 0.75를 넘으면 왜 성능이 저하되는가?
Load Factor란 위에서 언급하였듯, α = 저장 원소 수 / 테이블 크기이다. 
만약 α가 0.75라면, 75%를 사용했음을 의미한다. Open Addressing에서 평균 탐색 길이는 이렇게 계산한다. 평균 탐색 길이 = 1 / (1 - α).
따라서 α가 증가할수록 평균 탐색 길이가 길어진다. α가 1이 된다면 평균 탐색 길이는 무한대가 될 수 있다. 즉, 빈칸을 찾기 어려워지면서 탐색 길이가 급격히 증가한다.

테이블이 75% 차 있다는 것은 빈칸이 25% 밖에 남지 않았다는 것을 뜻하기에 충돌 확률이 급증한다. 즉 빈칸을 찾기 위해 여러칸을 검사해야 하고 90%가 되면 너무 늦기 때문이다.
그래서 보통 α > 0.7 ~ 0.75 이면 Rehashing(확장)을 수행한다.

---

## 5. Rehashing은 언제 발생하며 어떻게 동작하는가? 시간복잡도는?
보통 Load Factor가 임계값(예: 0.75)을 초과할 때 또는 충돌이 과도하게 많을 때 Rehashing을 수행한다.

Rehashing 수행 방법은 다음과 같다:
    1. 더 큰 배열 생성 (보통 2배)
    2. 기존 모든 원소를 새 배열에 다시 삽입
    3. 새로운 해시 함수 기준으로 재배치

이때의 시간 복잡도는 O(n)이다. 모든 원소를 다시 삽입해야 하기 때문이다.

---

## 6. 해시 테이블의 최악의 경우 시간복잡도가 O(n)인 이유는?
여러 이유가 있을 수 있다.
    1) 해시 함수가 완변하지 않은 경우, 해시 함수는 서로 다른 key를 같은 index로 보낼 수 있다.
    2) Chaining의 경우, 앞서 이야기 한것처럼 해시 테이블이 사실상 연결 리스트가 될 수 있다.
    3) Open Addressing의 경우, Linear Probing에서 모든 원소가 연속 구간에 몰리면 탐색 시 거의 전체 테이블을 확인해야 하므로 삽입 또한 전체 탐색과 동일하다. 

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

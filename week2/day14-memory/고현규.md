# Day 14: 메모리 관리 (페이징, 세그먼테이션)
> 📅 2025.02.26 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 메모리 단편화는 왜 발생하는가?
- [ ] 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?
- [ ] 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?
- [ ] 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?
- [ ] 세그먼테이션과 페이징의 차이는? 각각의 장단점은?
- [ ] 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?
---
<br>

# 1. 메모리 단편화는 왜 발생하는가?

> 메모리 단편화(Memory Fragmentation)는 프로세스들이 메모리에 적재되고 제거되는 과정이 반복되면서, 메모리 공간이 작은 조각으로 나뉘어 사용 가능한 전체 공간은 충분함에도 불구하고 새로운 프로세스를 올릴 수 없게 되는 현상을 말합니다.

초창기의 컴퓨터처럼 한 번에 딱 하나의 프로그램만 돌아간다면 메모리 단편화는 발생하지 않지만 현대의 컴퓨터는 얘기가 다릅니다.

현대의 컴퓨터는 멀티프로그래밍 환경이므로 여러 프로세스가 동시에 돌아가는데, 프로세스들은 각자 필요한 메모리의 크기가 다르고, 실행되는 시간도 제각각입니다. 

프로그램이 종료되면 해당 프로세스가 사용하던 메모리 공간이 비게 되는데, 만약 새로 시작하는 프로그램이 그 공간보다 더 큰 메모리를 필요로 하는 경우, 그 공간에 들어가지 못하고 빈틈이 생기게 됩니다. 

이러한 과정이 반복되면 메모리는 구멍이 숭숭 뚤리게 되고, 메모리 단편화가 발생합니다.

<br>

# 2. 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?

> 1번에서 본 메모리 조각들이 어디에 생기느냐에 따라 내부 단편화와 외부 단편화로 나뉩니다.

### 내부 단편화 (Internal Fragmentation)
* 정의
    * 프로세스가 할당된 메모리 공간보다 작아서 할당된 블록 안에서 남는 공간이 생기는 현상입니다.
    * 메모리를 일정한 크기로 미리 나누어놓는 고정 분할 방식(Fixed Partitioning)이나 페이징에서 발생합니다.
* 예시
    * 메모리를 10KB로 나누어놓았는데, 7KB짜리 프로세스가 할당되면 3KB의 내부 단편화가 발생합니다. 이 3KB는 다른 프로세스가 사용할 수 없습니다.

### 외부 단편화 (External Fragmentation)
* 정의
    * 어떤 큰 프로세스를 돌리기에 메모리상의 빈 공간을 다 합치면 충분하지만, 작은 조각들로 흩어져 있어서 돌리지 못하는 현상입니다.
    * 프로세스의 크기에 딱 맞춰 메모리를 할당하는 가변 분할 방식(Variable Partitioning)이나 세그먼테이션에서 발생합니다.
* 예시
    * 여기저기 흩어진 빈 공간이 합치면 100MB인데, 가장 큰 빈칸이 30MB라면 50MB짜리 프로세스는 메모리에 올라가지 못합니다.

<br>

# 3. 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?

> 페이징(Paging)은 프로세스의 논리적 주소 공간을 고정된 크기의 페이지(Page)로 나누고, 물리적 메모리 역시 동일한 크기의 프레임(Frame)으로 나누어 관리하는 기법입니다.

### 1) 핵심 개념
* 페이지(Page): 프로세스의 논리적 주소 공간을 고정된 크기로 나눈 것
* 프레임(Frame): 실제 물리 메모리(RAM)를 페이지와 같은 크기로 쪼갠 단위

페이징의 특징은 불연속 할당을 할 수 있다는 것입니다. 프로세스의 페이지들이 물리 메모리의 서로 떨어진 위치(프레임)에 흩어져서 저장될 수 있습니다.

### 2) 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?
이전의 가변 분할 방식에서는 프로세스가 통으로 들어갈 연속된 큰 공간이 필요했습니다. 하지만 페이징을 사용하면 메모리에 흩어져 있는 빈 프레임들을 모아서 프로세스를 올릴 수 있습니다.

물리적으론 쪼개져있지만 논리적으로는 연속성을 가지므로 프로세스의 입장에서는 자신이 연속된 메모리 공간을 쓰고있다고 착각하게 만들 수 있고, 외부 단편화 문제를 해결할 수 있습니다.

하지만 프로세스의 크기가 페이지 크기의 배수가 아니라면 마지막 페이지에서 남는 공간이 생기는 내부 단편화는 미세하게 발생합니다.

<br>

# 4. 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?

> CPU가 보는 주소(논리 주소)와 실제 RAM에 저장된 주소(물리 주소)는 완전히 다릅니다. 이 둘을 연결해주는 것이 페이지 테이블입니다.

CPU가 사용하는 논리 주소는 크게 두 부분으로 나뉩니다.

1. 페이지 번호 ($p$)
    * 프로세스의 몇 번째 조각인지 나타내는 번호입니다.
    * 페이지 테이블의 인덱스로 사용됩니다.
2. 변위 ($d$, Offset)
    * 해당 페이지 내에서 실제 데이터가 시작점으로부터 얼마나 떨어져 있는지를 나타냅니다.
    * 이 값은 물리 주소로 넘어가도 변하지 않습니다.

### 주소 변환 과정
CPU가 메모리에 접근하려고 할 때, 현재 가지고있는 주소는 실제 RAM의 주소가 아니라 논리 주소입니다. 이 가짜 주소를 진짜 주소로 바꿔주는 과정이 필요합니다.

1. 요청
    * CPU가 특정 데이터의 논리 주소($p, d$)를 요청합니다.
2. 참조
    * 메모리 관리 장치(MMU)가 페이지 테이블로 가서 $p$번 인덱스를 확인합니다.
3. 프레임 번호 획득
    * 페이지 테이블은 해당 페이지가 실제 RAM의 몇 번째 프레임($f$)에 들어있는지 알려줍니다.
4. 물리 주소 생성
    * 찾아낸 프레임 번호($f$)와 아까 챙겨두었던 변위($d$)를 결합하여 실제 RAM의 주소를 찾아갑니다.

처음에 CPU가 알고있던건 ($p + d$)인 가짜 주소였지만 이제 ($f + d$)인 진짜 주소로 변환되었습니다.

여기서 $d$를 그대로 쓸 수 있는 이유는 페이지와 프레임이 같은 크기이기 때문입니다.

<br>

# 5. 세그먼테이션과 페이징의 차이는? 각각의 장단점은?

> 페이징(Paging)이 메모리를 기계적인 크기로 나누는 방식이라면, 세그먼테이션(Segmentation)은 메모리를 의미 있는 단위로 나누는 방식입니다.

### 세그먼테이션 (Segmentation)

프로세스를 논리적 단위인 세그먼트(Segment)로 나눕니다. 예를 들어, 하나의 프로그램은 코드(Code), 데이터(Data), 힙(Heap), 스택(Stack)으로, 혹은 각각의 함수 단위로 쪼갤 수 있습니다.

이 경우에 논리 주소의 구성은 (세그먼트 번호, 변위)로 구성됩니다.

세그먼트 테이블은 페이징과 달리 각 세그먼트의 크기가 제각각이므로, 테이블에는 해당 세그먼트의 시작 주소(Base)와 크기(Limit) 정보가 함께 담깁니다.

### 세그먼테이션과 페이징의 차이

| 구분 | 페이징 (Paging) | 세그먼테이션 (Segmentation) |
| :--- | :--- | :--- |
| **분할 단위** | 고정된 크기 (Fixed Size) | 가변적인 크기 (Variable Size) |
| **분할 관점** | 시스템/하드웨어 관점 | 사용자/프로그래머 관점 (논리적 단위) |
| **단편화 문제** | 내부 단편화 발생 가능 | 외부 단편화 발생 가능 |
| **공유/보호** | 어려움 (함수가 여러 페이지에 걸칠 수 있음) | 쉬움 (의미 단위로 나뉘어 있어 권한 제어 용이) |
---

### 페이징의 장점

* **외부 단편화 해결:** 빈 공간 어디든 페이지를 끼워넣어 메모리 낭비를 줄임
* **메모리 관리의 단순함:** 모든 조각의 크기가 같아서 관리가 매우 쉬움
* **교체 알고리즘 적용 용이:** 페이지 단위로 스왑 인/아웃(Swap-in/out)을 하기에 최적화

### 페이징의 단점

* **내부 단편화 발생 가능성:** 페이지 크기가 프로세스의 크기보다 작다면 마지막 페이지에서 남는 공간이 생깁니다.
* **공유 및 보호의 어려움:** 함수가 여러 페이지에 걸쳐있을 수 있어 권한 제어가 어려움

### 세그먼테이션의 장점

* **공유 및 보호의 효율성:** 의미 단위로 나뉘어 있어 권한 제어 용이 (보안 권한 부여 또는 공용 라이브러리 공유)
* **내부 단편화 없음:** 딱 필요한 만큼 할당하기 때문에 내부에 남는 공간이 없음

### 세그먼테이션의 단점

* **외부 단편화 발생:** 세그먼트의 크기가 제각각이라 메모리 중간중간에 빈 공간이 생깁니다.
* **메모리 관리의 복잡함:** 세그먼트 테이블을 관리하는 것이 페이징보다 복잡

<br>

# 6. 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?

페이지 크기는 보통 $2^n$단위로 정해지며, 현대 시스템에서는 기본적으로 4KB를 가장 많이 사용합니다. 최근 메모리 용량이 커지면서 더 큰 페이지를 쓰기도 합니다.

### 1) 페이지 크기가 작을 때
* 장점
    * 내부 단편화가 감소합니다. 내부 단편화의 원인인 마지막 조각이 작아지므로 낭비가 줄어듭니다.
* 단점
    * 페이지 테이블의 크기가 증가합니다. 관리해야 할 페이지 개수가 많아지기 때문입니다. 이는 CPU의 주소 변환 캐시인 TLB(Translation Lookaside Buffer)가 커버하는 메모리 범위를 좁히고, 캐시 적중률을 떨어뜨립니다.

### 2) 페이지 크기가 클 때
* 장점
    * 페이지 테이블 관리 효율이 증가합니다. 테이블 엔트리 수가 적어져 메모리 오버헤드가 줄어듭니다.
    * 디스크에서 테이터를 가져올 때(Page-in), 한 번에 많은 양을 가져오므로 연속적인 읽기 성능(I/O 효율성)이 좋아집니다.
    * 하나의 TLB 엔트리가 훨씬 넗은 메모리 영역을 가리키게 되어 주소 변환 속도가 빨라지고 TLB 히트율이 상승합니다.
* 단점
    * 내부 단편화가 심화됩니다. 아주 작은 프로세스라도 무조건 하나의 큰 페이지를 할당받아야 하므로 버려지는 공간이 많아집니다.

| 특성 | 페이지가 작을 때 | 페이지가 클 때 |
| :--- | :--- | :--- |
| **내부 단편화** | 적음 (효율적) | 많음 (낭비) |
| **페이지 테이블 크기** | 큼 (관리 부담 증가) | 작음 (메모리 절약) |
| **TLB 적중률** | 낮음 (참조 범위 좁음) | 높음 (참조 범위 넓음) |
| **디스크 I/O 속도** | 비교적 느림 | 빠름 (한 번에 많이 읽음) |
# Day 14: 메모리 관리 (페이징, 세그먼테이션)
> 📅 2025.02.26 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 메모리 단편화는 왜 발생하는가?
- [x] 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?
- [x] 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?
- [x] 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?
- [x] 세그먼테이션과 페이징의 차이는? 각각의 장단점은?
- [x] 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?
---

### 📌 [Q1] 메모리 단편화는 왜 발생하는가?

**메모리 단편화(Fragmentation)**
- RAM에서 메모리 공간이 작은 조각으로 나뉘어져, 사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태
- 내부 단편화 / 외부 단편화로 나뉜다.
- 메모리 단편화로 인해 실제 사용 가능한 공간이 줄어들어 성능 저하를 일으킬 수 있다.

**발생 이유**
- 메모리 단편화는 **메모리를 할당하고 해체하는 과정이 반복되면서 메모리 공간이 비효율적으로 쪼개지기 때문에 발생**한다.

### 📌 [Q2] 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?

**내부 단편화 (Internal Fragmentation)**
- 메모리를 할당할 때, 프로세스가 **필요한 양보다 더 큰 고정된 크기의 블록을 할당받으면서 발생**
- 발생 위치: **할당된 메모리 블록 내부**
- 시스템이 효율적인 관리를 위해 메모리를 일정한 단위로 나누어 제공
- 고정 블록 할당 방식 or 페이징에서 발생
- ex) 3kb만 필요한 프로세스인데 4kb를 할당받아 1kb는 낭비됨

**외부 단편화 (External Fragmentation)**
- 메모리 할당과 해제가 반복되면서, 사용 가능한 메모리 공간이 여러 곳으로 흩어져 구멍이 생기는 현상
- 발생 위치: **할당된 메모리 블록들 사이**
- malloc 같은 가변 크기 메모리 할당, 연속 메모리 할당 방식, 세그멘테이션 방식에서 발생
- ex) 총 빈 공간은 100mb인데, 이 공간들이 10mb씩 10개로 쪼개져 있어 20mb 크기의 프로세스는 어디에도 들어갈 수 없게됨

### 📌 [Q3] 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?

**페이징(Paging)**
- 가상 메모리 관리 기법 중 하나
- 프로세스의 논리 메모리를 고정 크기 단위(Page)로 나누고, 물리 메모리도 같은 크기의 Frame으로 나누어 매핑하는 기법

```
// 연속되지 않아도 여기저기 배치 가능 (연속된 물리 메모리 필요 x)
논리 메모리:  Page 0 | Page 1 | Page 2 | Page 3
물리 메모리: Frame 5 | Frame 1 | Frame 9 | Frame 3
```

**외부 단편화 문제를 어떻게 해결하는가?**
- 프로세스를 연속된 공간에 넣을 필요가 없기 때문에 연속된 큰 메모리 공간이 없어도 되고, 메모리 중간 중간에 비어 있는 아무 Frame에 넣으면 된다. 때문에 외부 단편화 문제가 해결된다. (작은 빈 공간도 Frame 단위로 재사용 가능)
- 하지만 Page 크기는 고정이기 때문에 내부 단편화는 해결하지 못한다. 
  - ex) Page 크기 = 4kb인데 10kb를 요청 -> 4KB | 4KB | 4KB로 총 12kb 할당, 2kb 낭비

### 📌 [Q4] 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?

**페이지 테이블(Page Table)**
- CPU가 바라보는 논리 주소를 실제 메모리의 물리 주소로 변환해주는 이정표 역할을 하는 테이블
- 논리 주소(logical address)의 Page 번호를 물리 메모리의 Frame 번호로 매핑해주는 테이블 (이 페이지는 물리 메모리 어디에 있나요?를 알려주는 표)

**주소 변환 과정**
- CPU는 항상 논리 주소를 생성
  - 논리 주소 구조: `[ Page Number | Offset ]`
  - Page Number(p): 페이지 테이블의 인덱스 (프레임 찾기 위함)
  - Offset(d): 페이지 내부에서의 위치, 고정값 (페이지 크기가 4kb면 d는 0~4095 사이의 값을 가짐)
- 1) 논리 주소 생성: CPU가 특정 명령어를 실행하기 위해 논리 주소 생성
- 2) 페이지 테이블 참조: 논리 주소의 페이지 번호(p)를 인덱스로 하여 메모리에 있는 페이지 테이블을 조회
- 3) frame 번호(f) 획득: 페이지 테이블에서 해당 페이지 번호 & 실제 물리 메모리의 frame 번호를 읽어옴
- 4) 물리 주소 생성: 찾아낸 frame 번호와 offset을 결합해 최종 물리 주소를 만듦
- 5) 생성된 물리 주소를 통해 실제 RAM의 데이터에 접근함

### 📌 [Q5] 세그먼테이션과 페이징의 차이는? 각각의 장단점은?

**세그먼테이션이란?**
사용자가 바라보는 논리적 단위(Code, Data, Stack 등)로 메모리를 나누는 방식으로, 각 segment는 고유한 이름과 크기를 가진다.

**페이징(Paging)**
- 분할 단위: 고정 크기
- 메모리를 고정 크기(page)로 나눔
- 물리 메모리도 같은 크기의 frame으로 나눔
- 페이지 단위로 매핑, 크기 기반 분할
- `[ Page Number | Offset ]`
  - 페이지 번호 -> 프레임 번호로 변환
  - offset은 그대로
- 외부 단편화 X, 내부 단편화 O 
- 장점
  - 외부 단편화 해결 (빈 프레임 어디든 페이지를 넣을 수 있음)
  - 메모리 관리 단순
  - 가상 메모리 구현에 유리
  - 스와핑 쉬움
- 단점
  - 주소 변환 오버헤드
  - 내부 단편화 발생 (프로세스 크기가 페이지 크기의 배수가 아니면 마지막 페이지에서 빈 공간이 남음)
  - 공유 및 보호 어려움

**세그먼테이션(Segmentation)**
- 분할 단위: 가변 크기
- 메모리를 논리적 의미 단위(Segment)로 나눔
  - 코드 영역
  - 데이터 영역
  - 스택 영역
- 의미 기반 분할
- `[ Segment Number | Offset ]`
  - Segment Table에서 Base(시작 주소), Limit(길이)를 찾음
  - `물리주소 = Base + Offset`
- 외부 단편화 O, 내부 단편화 X
- 장점
  - 논리적 구조 반영 (코드/데이터 분리)
  - 공유 및 보호 (읽기 전용, 공유 가능 등 논리적 단위로 권한을 부여할 수 있음)
- 단점
  - 외부 단편화 (segment들의 크기가 제각각이라 메모리 할당과 해제가 반복되면 중간에 못 쓰는 공간들이 생김)
  - Compaction 필요
  - 구현 복잡

즉, **페이징은 물리 메모리 효율 중심이고**, **세그먼테이션은 사용자(논리구조) 중심**이다.

**현대 OS: Paged Segmentation**
- 오늘날 대부분의 OS는 둘을 혼용해서 사용함
  - 1) 프로그램을 논리적 단위인 Segment로 먼저 나눔
  - 2) 나누어진 Segment를 다시 고정 크기인 Page로 나눔

### 📌 [Q6] 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?

**페이지 크기가 작을 때**
- 장점
  - 내부 단편화 감소: 프로세스의 마지막 페이지의 남는 공간이 작아지므로 낭비되는 메모리 공간 줄어듦
  - 메모리 활용도 최적화: 꼭 필요한 데이터만 메모리에 올릴 수 있어 메모리 부족한 환경에서 유리
- 단점
  - 페이지 테이블 크기 증가: 같은 용량을 관리하기 위해 더 많은 페이지 번호가 필요하게 되어 테이블 자체가 차지하는 메모리도 커짐
  - TLB Miss 증가: CPU가 캐시인 TLB에 담을 수 있는 주소 변환 정보는 한정적임, 페이지가 작으면 TLB가 커버하는 메모리 범위가 좁아져 자주 메인 메모리의 페이지 테이블을 확인해야 하므로 성능 저하됨

**페이지 크기가 클 때**
- 장점
  - TLB Hit Ratio 상승: 하나의 TLB 엔트리가 훨씬 넓은 메모리 영역을 커버하게 됨 -> 주소 변환 속도가 빨라져 성능 향상
  - 페이지 테이블 오버헤드 감소: 관리해야 할 페이지 개수가 줄어들어 페이지 테이블의 크기가 작아짐
  - 디스크 I/O 효율성: 한 번에 많은 데이터를 읽어오므로 연속적인 데이터를 처리할 때 유리
- 단점
  - 내부 단편화 증가: 프로세스가 1KB만 필요해도 2MB짜리 페이지를 통째로 할당하는 등의 경우가 생겨 메모리 낭비 심해짐
  - 불필요한 데이터 로딩: 특정 데이터 1바이트가 필요한데도 거대한 페이지를 메모리에 올려야 하므로, 메모리 대역폭이 낭비될 수 있음

---
## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 14: 메모리 관리 (페이징, 세그먼테이션)
> 📅 2025.02.26 | 📁 Week 2

---

## 🧠 학습 질문
- [x] 메모리 단편화는 왜 발생하는가?
- [x] 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?
- [x] 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?
- [x] 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?
- [x] 세그먼테이션과 페이징의 차이는? 각각의 장단점은?
- [x] 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?

---

## Q1. 메모리 단편화는 왜 발생하는가?

[답변]
* 메모리를 동적으로 할당/해제 -> 사용 가능한 빈 공간이 연속적이지 않고 흩어져서 발생
  => 낭비: 메모리 공간이 충분해도 원하는 크기의 메모리 바로 할당 X
  - 요청 크기가 제각각
  - 해제되는 시점이 제각각
  - 연속 할당 방식의 구조적 한계
  - 고정 단위로 반올림하는 정책

---

## Q2. 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?

[답변]
* 외부 단편화(External Fragmentation)
  - 빈 공간이 역저기 흩어짐 -> 총 빈 공간은 충분하나 연속된 큰 공간을 만들지 못하는 상태
  - 가변 크기(연속) 할당에서 할당/해제 반복할 때 발생
  - 6KB 연속 공간 필요 -> 빈 공간이 2KB + 2KB + 2KB로 흩어짐 -> 할당 실패
* 내부 단편화(Internal Fragmentation)
  - 필요한 공간이 단위에 딱 맞아떨어지지 않음 -> 할당된 블록 내부에 실제로 쓰지 못하는 자투리 공간이 남는 상태
  - 고정 크기 블록을 할당할 때, 요청 크기가 블록 크기보다 작으면 남는 부분 낭비
  - ex. 6KB 필요 -> 페이지가 4KB -> 2페이지(8KB) 할당 -> 2KB 낭비

---

## Q3. 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?

[답변]
* 페이징(Paging): 가상 메모리/물리 메모리를 고정 크기 단위로 나누는 기법
  - 가상 메모리 단위: 페이지(page)
  - 물리 메모리 단위: 프레임(frame)
* 사용 이유
  - 프로세스 메모리를 연속된 물리 공간에 둘 필요가 없어짐 -> 물리 메모리의 빈 프레임들에 **분산 배치**
    => 외부 단편화 제거
  - 프로세스별 주소 공간 격리, 보호, 공유, 스와핑/요구 페이징 등 가상 메모리 기능 구현에 유리
  - 단편화 해결
    - 외부 단편화: 페이지가 프레임에 흩어져 올라가도 주소 변환으로 접근 가능 => 연속 공간 부족 문제 감소
    - 내부 단편화: 마지막 페이지는 꽉 차지 않을 수 있음 => 페이지 내부에 낭비 발생 가능
   
[보완]
* 연속 할당 포기, 주소 변환(페이지 테이블) 이용 -> 논리적 연속성 제공
* 외부 단편화 제거의 대가: 페이지 테이블 저장 비용, 주소 변환 오버헤드, TLB 미스 비용 => 성능/공간 비용 추가

---

## Q4. 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?

[답변]
* 페이지 테이블
  - 가상 페이지 번호(VPN) -> 물리 프레임 번호(PFN) 매핑
* 주소 변환 과정
  1. CPU가 가상 주소 생성
  2. 가상 주소를 [페이지 번호(VPN) | 오프셋(offset)]으로 분해
  3. VPN으로 페이지 테이블의 엔트리(PTE) 찾음 -> PFN 및 권한 비트(유효/읽기/쓰기/실행 등) 확인
  4. 물리 주소를 [PFN | offset]으로 결합 (오프셋 변하지 않음)
  5. 유효하지 않거나 권한 위반이면 페이지 폴트/보호 예외 발생
* 실제 시스템에서는 속도를 위해 TLB(Translation Lookaside Buffer) 사용
  - TLB 히트: PTE 접근 없이 즉시 PFN 얻음
  - TLB 미스: 페이지 테이블을 메모리에서 조회 후 TLB에 캐시

[보완]
* VPN(Virtual Page Number): 가상 주소를 '페이지 단위'로 나눴을 때 몇 번째 페이지인지 나타내는 번호
* PFN(Page Frame Number): 물리 메모리(RAM)를 '프레임 단위'로 나눴을 때 몇 번째 프레임인지 나타내는 번호
* CPU/MMU가 가상 주소에서 VPN을 뽑아 페이지 테이블(또는 TLB)에서 대응하는 PFN 찾음 -> 그 PFN으로 실제 RAM 위치 결정
  - OS는 각 페이지를 어느 프레임에 둘지 정하고, 그 결과가 페이지 테이블에 기록됨
* 오프셋: VPN/PFN은 어느 페이지/프레임이냐만 알려줌. 실제 접근은 그 안의 '어느 바이트'인지 알아야 하며, 오프셋은 해당 페이지/프레임 내부에서의 위치를 나타냄
  - 페이지와 프레임의 크기가 같으므로, 변환 과정에서 오프셋은 변하지 않는다.
* PTE(Page Table Entry): 페이지 테이블의 '한 칸'. 특정 VPN에 대한 정보를 담음
  - PFN: 매핑된 물리 프레임 번호
  - 유효/존재 비트(Present/Valid): 지금 RAM에 올라와 있는지
  - 권한 비트(R/W/X, user/supervisor 등): 접근 가능한지
  - Accessed/Dirty 같은 상태 비트: 최근 접근/수정 여부 등
  - MMU가 VPN으로 PTE를 찾음
* Page Fault
  - CPU가 어떤 가상 주소에 접근했을 때 발생하는 예외(trap)
    1. 가상 주소에 해당하는 페이지가 RAM에 없음 (Present=0)
    2. 권한이 없음
  - 제어가 OS로 넘어간다. OS는 상황에 따라
      1. 디스크에서 해당 페이지를 RAM으로 가져와 매핑을 갱신한 뒤 재실행
      2. 진짜 잘못된 접근 -> 프로세스 종료
* TLB(Translation Lookaside Buffer)
  - MMU 안에 있는 주소 변환 캐시
  - 최근에 사용한 VPN->PFN 매핑 저장
  - 동작
    1. CPU가 주소를 내면 MMU가 먼저 TLB에서 VPN WHGHL
    2. TLB 히트: 바로 PFN을 얻어 물리 주소 생성(빠름)
    3. TLB 미스: 페이지 테이블을 메모리에서 조회해 PTE를 얻고, 그 결과를 TLB에 넣은 뒤 진행(느림)

---

## Q5. 세그먼테이션과 페이징의 차이는? 각각의 장단점은?

[답변]
* 세그먼테이션(Segmentation): 주소 공간을 코드/데이터/스택 등 의미 있는 논리 단위(가변 크기)로 나눔
  - 주소 형식: [세그먼트 번호 | 오프셋]
  - 장점: 논리적 구조와 일치 -> 보호/공유가 직관적, 세그먼트 별 권한 관리 명확
  - 단점: 가변 크기 연속 할당 필요 -> 외부 단편화가 발생하기 쉽고, 압축 비용 발생 가능성
* 페이징(Paging): 주소 공간을 고정 크기 페이지로 나눔
  - 주소 형식: [페이지 번호 | 오프셋]
  - 장점: 연속 물리 공간이 불필요 -> 외부 단편화 제거, 할당/회수 단순
  - 단점: 페이지 테이블/주소 변환 오버헤드, 마지막 페이지의 내부 단편화, 페이지 단위 보호가 논리 구조와 덜 맞을 수 있음

[보완]
* 세그먼트 + 페이징 혼합 방식도 존재
* 실무적으론 페이징이 메인 + 세그먼트 제한적 사용
* 둘의 상위 개념: 메모리 관리 기법
  - 프로세스에게 가상 주소 공간을 제공하고, 이를 물리 메모리에 매핑하며, 보호/격리/공유를 가능하게 함

---

## Q6. 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?

[답변]
* 페이지 크기가 성능에 미치는 영향: TLB 효율, 페이지 테이블 크기, 페이지 폴트 비용, 내부 단편화, I/O 효율 등
* 페이지가 큰 경우(large page)
  - 장점
    - 같은 TLB 엔트리 수로 더 큰 메모리 범위를 커버(TLB reach 증가) -> TLB 미스 감소 가능
    - 페이지 테이블 엔트리 수가 줄어 페이지 테이블 관리 비용 감소
    - 순차 접근/대용량 워크로드 에서 디스크/파일 I/O 효율이 좋아질 수 있음
  - 단점
    - 내부 단편화 증가
    - 페이지 폴트 시 한 번에 가져오는 데이터가 커짐 -> 실제로 사용하지 않는 데이터까지 적재 -> 불필요한 메모리/대역폭 소비
* 페이지가 작은 경우(small page)
  - 장점
    - 내부 단편화 감소
    - 필요한 데이터만 더 정밀하게 적재 -> 일부 워크로드에서 메모리 효율 및 캐시 효율 개선 가능
  - 단점
    - 페이지 수 증가 -> 페이지 테이블 커짐 -> TLB가 커버하는 범위 감소 -> TLB 미스 증가
    - 페이지 폴트/관리 오버헤드(엔트리 처리, 매핑 관리)가 상대적으로 증가

[보완]
* Huge Page: 4KB 이상의 페이지. 큰 메모리 영역을 다룰 때, TLB로 커버할 수 있는 범위를 늘리기 위한 대용량 페이지.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

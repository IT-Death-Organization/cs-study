# 메모리 관리 (페이징, 세그먼테이션)

> 📅 2025.02.26 | 📁 Week 2
> 

---

## 🧠 학습 질문

## 메모리 단편화는 왜 발생하는가?

- 정의
    - 메모리 공간이 조각조각 나뉘어 실제로는 빈 공간이 충분함에도 불구하고 프로세스를 할당하지 못하는 현상임
- 발생 원인
    - 프로세스들이 메모리에 올라오고(Allocation) 나가는(Deallocation) 과정이 반복되면서, 사용 가능한 메모리 공간이 연속되지 않고 여기저기 흩어지기 때문임

## 내부 단편화와 외부 단편화의 차이는? 각각 어떤 경우에 발생하는가?

- 내부 단편화(Internal Fragmentation):
    - 현상
        - 프로세스가 필요한 양보다 더 큰 고정된 크기의 블록을 할당받아, 블록 내부에서 남는 공간이 생기는 것임
    - 상황
        - 메모리를 10KB 단위로 쪼개놨는데 프로세스가 7KB만 요구할 때, 남는 3KB는 누구도 못 쓰는 낭비 공간이 됨
- 외부 단편화(External Fragmentation):
    - 현상
        - 메모리 사이사이에 빈 공간(Hole)들은 많은데, 이들이 연속되지 않아서 커다란 프로세스가 들어가지 못하는 것임
    - 상황
        - 빈 공간이 5KB, 5KB 두 군데 있는데 8KB짜리 프로세스가 들어오려 하면, 합치면 10KB지만 연속되지 않아 할당 불가함

## 페이징이란 무엇이며 왜 사용하는가? 단편화 문제를 어떻게 해결하는가?

- 개념
    - 물리 메모리를 Frame이라는 고정된 크기로 나누고, 프로세스의 논리 메모리를 페이지(Page)라는 동일한 크기로 나누는 기법임
- 사용 이유
    - 프로세스를 메모리에 불연속적으로 올리기 위해서임. 즉, 남는 프레임이 어디에 있든 페이지를 끼워 넣을 수 있음
- 단편화 해결
    - 외부 단편화 완벽 해결: 빈 프레임이 있기만 하면 페이지를 넣을 수 있으므로 "공간은 있는데 연속되지 않아 못 넣는" 상황이 사라짐
    - 내부 단편화 발생 가능: 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지에서 남는 공간이 생길 수 있음 (하지만 외부 단편화에 비해 낭비가 매우 적음)

## 페이지 테이블은 어떻게 동작하는가? 주소 변환 과정은?

- **동작 원리**
    - CPU가 내는 논리 주소를 실제 메모리의 물리 주소로 매핑해주는 '지도' 역할을 함
- **주소 구성**
    - 논리 주소는 페이지 번호와 변위 (d, offset) 으로 구성
    - **변환 과정**
    1. CPU가 페이지 번호(p)를 보고 페이지 테이블에서 해당 페이지가 위치한 프레임 번호(f)를 찾음
    2. 찾아낸 프레임의 시작 주소에 변위를 더함
    3. 실제 물리 주소(f+d)에 접근함

## 세그먼테이션과 페이징의 차이는? 각각의 장단점은?

| **구분** | **페이징 (Paging)** | **세그먼테이션 (Segmentation)** |
| --- | --- | --- |
| **단위** | 고정 크기 (Fixed Size) | 가변 크기 (Variable Size, 논리적 단위) |
| **분할 기준** | 시스템/기계적 관점 | 사용자/의미적 관점 (Code, Data, Stack) |
| **단편화** | 내부 단편화 발생 가능 | 외부 단편화 발생 가능 |
| **장점** | 메모리 관리가 단순하고 효율적임 | 공유와 보호(Security) 기능 구현이 쉬움 |

## 페이지 크기가 성능에 미치는 영향은? 크면/작으면 어떤 문제가 있는가?

- **페이지 크기가 클 때**
    - **장점:** 페이지 테이블 크기가 줄어들어 테이블 관리 메모리가 절약됨. 디스크에서 메모리로 옮길 때 I/O 횟수가 줄어듦
    - **단점:** 내부 단편화가 심해져 메모리 낭비가 커짐. 필요 없는 데이터까지 메모리에 많이 올라오게 됨
- **페이지 크기가 작을 때:**
    - **장점:** 내부 단편화가 최소화되어 메모리를 아주 알뜰하게 쓸 수 있음. 꼭 필요한 데이터만 메모리에 유지됨
    - **단점:** 페이지 테이블이 너무 커져서 배보다 배꼽이 커짐(테이블 자체 용량 부담). 페이지 부재(Page Fault)가 자주 발생해 성능이 저하될 수 있음

---

## 📎 참고 자료

## <!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->
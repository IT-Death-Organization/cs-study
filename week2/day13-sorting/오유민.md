# Day 13: 정렬 알고리즘 1 (버블, 선택, 삽입)
> 📅 2025.02.25 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?
- [ ] 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?
- [ ] 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?
- [ ] 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?
- [ ] 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?
- [ ] 실무에서 이 세 정렬을 사용하는 경우가 있는가?
---

### 📌 [Q1] 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?

**버블 정렬은 인접한 두 원소를 비교해서 순서가 잘못되어 있으면 서로 교환(swap)하는 과정을 반복하는 정렬 알고리즘**이다.

```
[5, 3, 8, 4] -> [3, 5, 8, 4] -> [3, 5, 4, 8] -> [3, 4, 5, 8]
```
버블 정렬은 **불필요한 비교(swap)가 너무 많기 때문에 비효율적**이다. (이미 정렬되어 있어도 비교함)
버블 정렬은 매 패스마다 인접한 모든 원소를 끝까지 비교한다.

예를 들어 원소가 n개라면
- 첫 번째 패스: n-1번 비교
- 두 번째 패스: n-2번 비교
- ...
- 마지막 패스: 1번 비교

총 비교 횟수는 (n-1) + (n-2) + ... + 1 = n(n-1)/2로, 결국 O(n²)의 시간 복잡도를 갖게 된다.

**정리** <br>
버블 정렬은 인접 원소를 반복적으로 비교하면서 한 번에 한 칸씩만 이동시키기 때문에 비교 횟수가 약 n²에 가깝고, 평균 및 최악의 경우 O(n²)의 시간복잡도를 가지므로 비효율적입니다. 다만 swap 체크를 추가하면 이미 정렬된 경우 O(n)까지 개선할 수 있습니다.

### 📌 [Q2] 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?

**선택 정렬은 매 단계마다 남은 구간에서 가장 작은 값을 선택해서 맨 앞과 교환하는 정렬 알고리즘**이다.

```
[5, 3, 8, 4] (전체에서 최솟값 3 찾기) -> [3, 5, 8, 4] (남은 구간 [5, 8, 4]에서 최솟값 찾기) -> [3, 4, 8, 5] ([8, 5]에서 최솟값 찾기) -> [3, 4, 5, 8]
```

선택 정렬은 매 단계마다
- 남은 구간 전체를 탐색
- 최솟값 찾음
- 맨 앞 원소와 swap

즉, 원소가 n개일 때
- 1번째 단계 -> n-1번 비교
- 2번째 단계 -> n-2번 비교
- ...
- 마지막 단계 -> 1번 비교

총 비교 횟수는 (n-1) + (n-2) + ... + 1 = n(n-1)/2로, 결국 O(n²)의 시간 복잡도를 갖게 된다.

**이미 정렬되어 있는 경우**
`[1, 2, 3, 4, 5]` 같이 이미 정렬되어 있어도 선택 정렬은 최솟값을 찾기 위해 남은 구간 전체를 탐색해야 하므로 비교 횟수는 동일하게 O(n²)이다. (정렬 여부를 모르기 때문에 매 단계마다 전체를 다 탐색)

**버블 정렬은 최선의 경우 O(n)이지만, 선택 정렬은 항상 O(n²)인 이유**
- 버블 정렬은 swap이 안 일어나면 이미 정렬된 상태이고, 이를 감지해 중간에 종료가 가능하므로 최선의 경우 O(n)까지 개선할 수 있지만
- 선택 정렬은 매 단계마다 남은 구간 전체를 탐색해야 하므로 이미 정렬된 경우도 O(n²)의 시간 복잡도를 유지 (최소값이 앞에 있는지 확인하려면 끝까지 다 봐야 함, 중간 종료 불가능)

### 📌 [Q3] 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?

**삽입 정렬은 이미 정렬된 부분에 새로운 원소를 올바른 위치에 끼워 넣는 정렬 방식**이다. (두 번째 요소부터 시작해 앞의 요소들과 비교하며 자신의 위치 찾음)

```
[5, 3, 8, 4] (3을 5 앞에 삽입) -> [3, 5, 8, 4] (8은 그대로) -> [3, 5, 8, 4] (4를 5 앞에 삽입) -> [3, 4, 5, 8]
```

- 정렬되지 않은 상태
  - 선택한 데이터가 앞의 데이터보다 작다면, 계속해서 왼쪽으로 이동하며 비교한다.
- 거의 정렬된 상태
  - 선택한 데이터가 바로 직전 데이터보다 크다면, 그 앞의 데이터들은 이미 정렬되어 있으므로 더 이상 비교할 필요가 없다.

**최악의 경우 -> O(n²)**
- 배열이 역순으로 정렬되어 있다면 매번 가장 왼쪽 끝까지 비교하며 이동해야 하므로 1 + 2 + ... + n-1번의 비교 발생 = n(n-1)/2로 O(n²)의 시간 복잡도를 갖게 된다.

**거의 정렬된 배열 -> O(n)**
- 각 요소는 바로 왼쪽 요소와 한 번만 비교하고 제자리에 머뭄
- 위 과정이 n-1번 반복되므로 전체 비교 횟수는 n-1번이 되고, 이는 O(n)의 시간 복잡도를 갖게 된다.
- 특정 요소 한두 칸 이동하면 되기 때문에 전체 연산량은 n에 매우 가깝게 유지된다.

### 📌 [Q4] 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?

안정 정렬이란 **정렬되지 않은 상태에서 같은 값을 가진 요소들의 상대적인 순서를 유지**하는 정렬 방식이다.

ex) 점수 기준 정렬
```
(이름, 점수)
(A, 90)
(B, 80)
(C, 90)
(D, 70)
```

정렬 후
```
(D, 70)
(B, 80)
(A, 90) // A와 C의 상대적인 순서 유지 (불안정 정렬일 경우 둘의 순서 바뀜)
(C, 90)
```

**안정 정렬 (stable)**
- 같은 값 a, b가 있을 때, 입력 순서가 a -> b였다면 정렬 후에도 반드시 a -> b 순서를 유지 
- 데이터의 순서를 보장해야 할 때 사용
- 삽입 정렬, 병합 정렬, 버블 정렬


**불안정 정렬 (unstable)**
- 같은 값 a, b가 있을 때, 입력 순서가 a -> b였다면 정렬 후에도 반드시 a -> b 순서를 유지하지 않음 
- 순서 보장보다는 속도나 메모리 효율이 우선일 때 사용
- 선택 정렬, 퀵 정렬, 힙 정렬

**안정 정렬이 중요한 이유**
- 실제 데이터는 보통 하나의 필드만 가지지 않고, 여러 속성을 가진 **객체** 형태이고, 이때 안정 정렬은 **이전 정렬 결과를 유지한다**는 장점을 가짐

ex) **다중 정렬** - 학생 정보 정렬
1. 먼저 이름 순으로 정렬한다.
2. 그 다음 학년 순으로 정렬한다.

- 안정 정렬일 경우
  - 학년별로 묶인 결과 안에서도, 같은 학년 학생들은 이미 이름순으로 정렬되어 있음
- 불안정 정렬일 경우
  - 학년으로 정렬은 되지만, 그 안에서 이름 순서가 섞여 이전에 했던 이름 정렬 작업이 무의미

### 📌 [Q5] 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?

안정 정렬: 버블 정렬, 삽입 정렬
불안정 정렬: 선택 정렬

**버블 정렬 - 안정 정렬**
- 인접한 두 원소를 비교하며 자리를 바꾸는 방식
- 비교 연산 시 A[i]>A[i+1]일 때만 swap함
- 즉, **값이 같은 경우에는 자리를 바꾸지 않고 그대로 두기 때문에** 입력 순서를 유지할 수 있음

**삽입 정렬 - 안정 정렬**
- 정렬된 앞부분의 적절한 위치를 찾아 데이터를 삽입하는 방식
- 새로운 데이터를 앞의 데이터들과 비교할 때, **자신보다 큰 값들만 뒤로 밀어내고 자신과 값이 같은 데이터를 만나면 그 바로 뒤에 멈춤** -> 동일한 값들의 입력 순서를 유지할 수 있음

**선택 정렬 - 불안정 정렬**
- 매 단계에서 최솟값을 찾아 맨 앞의 원소와 swap하는 방식
- 최솟값을 찾아 맨 앞으로 보내는 과정에서, **기존에 맨 앞에 있던 원소가 뒤로 밀려나며 원래 뒤에 있던 동일한 값보다 더 뒤로 가게 될 수 있음**
- ex) [5(a), 5(b), 1] 이라는 배열이 있을 때
  - 최솟값 1을 찾음
  - 맨 앞의 5(a)와 1을 swap
  - 결과는 [1, 5(b), 5(a)]가 되어, 원래 앞에 있던 5(a)가 5(b)보다 뒤로 밀려남


### 📌 [Q6] 실무에서 이 세 정렬을 사용하는 경우가 있는가?

데이터의 양이 많은 실무 상황에서는 (버블, 삽입, 선택) 정렬을 단독으로 사용하기 보다는 (O(n²)의 시간 복잡도를 가짐), **병합 정렬, 퀵 정렬, 힙 정렬**과 같은 O(nlogn)의 시간 복잡도를 가진 정렬을 사용한다.

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

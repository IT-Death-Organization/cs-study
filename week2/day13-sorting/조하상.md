# Day 13: 정렬 알고리즘 1 (버블, 선택, 삽입)
> 📅 2025.02.25 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?
- [ ] 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?
- [ ] 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?
- [ ] 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?
- [ ] 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?
- [ ] 실무에서 이 세 정렬을 사용하는 경우가 있는가?

---
## 1. 버블 정렬은 왜 비효율적인가? 어떤 경우에도 $O(n^2)$인가?

**비효율성의 이유**
- 인접한 두 원소를 매번 비교하고 교체(Swap)하는 과정이 반복되기 때문이다. 특히 교체 연산은 CPU 리소스를 많이 소모하는데, 버블 정렬은 다른 정렬에 비해 교체 연산이 너무 자주 일어난다.

**시간 복잡도**
- 기본적으로 루프가 중첩되어 있어 $O(n^2)$이다. 다만, 한 번의 회전 동안 교체가 한 번도 일어나지 않았다면 이미 정렬된 것으로 간주하고 종료하는 최적화(Flag 변수 사용)를 적용하면 최선의 경우 $O(n)$까지 줄일 수 있다.



---
## 2. 선택 정렬은 왜 항상 $O(n^2)$인가?

**최소값 탐색의 강제성**
- 선택 정렬은 현재 위치에 넣을 '가장 작은 값'을 찾기 위해 나머지 미정렬 영역을 끝까지 전부 훑어야 한다. 
- 데이터가 이미 정렬되어 있든 역순이든 상관없이, 매 단계마다 최소값을 찾기 위한 비교 횟수가 고정되어 있으므로 최선, 평균, 최악의 상황 모두 $O(n^2)$의 시간 복잡도를 가진다.



---
## 3. 삽입 정렬이 거의 정렬된 배열에서 $O(n)$에 가까운 이유는?

**조기 종료 메커니즘**
- 삽입 정렬은 현재 대상을 이미 정렬된 앞부분의 적절한 위치에 '삽입'한다. 
- 이때, 대상 숫자가 이미 앞의 숫자보다 크다면 더 이상 비교하지 않고 그 자리에 멈춘다. 거의 정렬된 상태라면 비교 즉시 제자리를 찾게 되므로, 내부 루프가 거의 실행되지 않아 $O(n)$에 수렴하는 성능을 보여준다.



---
## 4. 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?

**상대적 순서의 보존**
- 중복된 키값을 가진 원소들이 정렬 후에도 **기존의 입력 순서를 그대로 유지**하는 정렬 방식을 말한다.
- **중요성:** 여러 기준을 가지고 정렬할 때 필수적이다. 예를 들어 '나이' 순으로 먼저 정렬된 데이터를 다시 '이름' 순으로 정렬할 때, 이름이 같은 사람들의 나이 순서가 뒤섞이지 않으려면 반드시 안정 정렬을 사용해야 한다.



---
## 5. 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?

- **버블 정렬 (안정):** 인접한 값이 같을 경우 위치를 바꾸지 않으므로 순서가 보존된다.
- **삽입 정렬 (안정):** 삽입 위치를 찾을 때 자기보다 작은 값을 만날 때까지만 이동하고, 같은 값을 만나면 그 뒤에 멈추므로 순서가 유지된다.
- **선택 정렬 (불안정):** 최소값을 찾아 멀리 떨어진 위치와 교체(Swap)하는 과정에서, 그 사이에 있던 같은 값들의 상대적 순서가 깨질 수 있다.

---
## 6. 실무에서 이 세 정렬을 사용하는 경우가 있는가?

- **버블/선택 정렬:** 실무에서 거의 사용하지 않는다. 교육용으로 개념을 익히는 용도가 강하다.
- **삽입 정렬:** 의외로 자주 쓰인다. 데이터의 개수가 매우 적을 때(보통 10~20개 이하)는 퀵 정렬이나 병합 정렬보다 빠르기 때문에, 고성능 정렬 알고리즘(Timsort, Introsort 등)의 하이브리드 방식으로 내부에서 혼용하여 사용한다.

---
## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

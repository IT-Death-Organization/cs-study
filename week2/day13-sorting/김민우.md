# Day 13: 정렬 알고리즘 1 (버블, 선택, 삽입)
> 📅 2025.02.25 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?
- [x] 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?
- [x] 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?
- [x] 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?
- [x] 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?
- [x] 실무에서 이 세 정렬을 사용하는 경우가 있는가?
---

## 1. 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?

### 비효율적인 이유

버블 정렬은 인접한 두 원소를 비교하여 잘못된 순서일 경우 교환하는 방식이다.  
한 번의 패스(pass)마다 가장 큰 원소가 뒤로 "버블처럼" 이동한다.

문제는 다음과 같다:

- 각 패스마다 거의 모든 원소를 비교해야 함
- 불필요한 비교가 매우 많음
- 교환(swap) 연산이 빈번하게 발생

비교 횟수는 대략:

```

(n-1) + (n-2) + ... + 1 = n(n-1)/2

```

→ 시간복잡도: O(n²)

### 모든 경우 O(n²)인가?

- 일반적인 구현: 최선 / 평균 / 최악 모두 O(n²)
- 최적화 구현 (swap이 한 번도 발생하지 않으면 종료):
  - 최선의 경우: O(n)
  - 평균 / 최악: O(n²)

즉, 최적화가 없다면 항상 O(n²)에 가깝다.

---

## 2. 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?

### 동작 방식

매 단계마다:

1. 현재 위치 이후의 모든 원소를 탐색
2. 최소값을 찾음
3. 현재 위치와 교환

### 핵심 포인트

선택 정렬은 "이미 정렬되어 있는지" 여부와 무관하게  
항상 전체 탐색을 수행한다.

예:

```

이미 정렬된 배열이어도
최소값을 찾기 위해 끝까지 탐색함

```

비교 횟수:

```

(n-1) + (n-2) + ... + 1 = n(n-1)/2

```

→ 최선 / 평균 / 최악 모두 O(n²)

교환 횟수는 최대 n-1로 적지만,  
비교 연산이 줄어들지 않기 때문에 시간복잡도는 항상 O(n²)이다.

---

## 3. 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?

### 동작 방식

왼쪽은 항상 정렬된 상태라고 가정하고,  
새로운 원소를 적절한 위치에 삽입한다.

### 거의 정렬된 경우

각 원소가 이미 제자리에 가깝다면:

- 비교는 거의 1번
- 이동도 거의 없음

즉, 각 단계가 상수 시간에 가까워짐.

전체 수행 시간:

```

n × O(1) ≈ O(n)

```

### 반대로 완전 역순일 경우

각 원소가 앞까지 이동해야 하므로:

```

1 + 2 + ... + n = O(n²)

```

정리:

- 최선: O(n)
- 평균: O(n²)
- 최악: O(n²)

삽입 정렬은 데이터가 거의 정렬된 경우 매우 효율적이다.

---

## 4. 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?

### 정의

안정 정렬이란:

> 같은 값을 가진 원소들의 상대적 순서를 유지하는 정렬

예:

```

(3, A), (1, B), (3, C)

```

정렬 후:

```

(1, B), (3, A), (3, C)

```

A와 C의 순서가 유지되면 안정 정렬이다.

### 왜 중요한가?

1. 다중 키 정렬 시 필수
   - 먼저 이름 기준 정렬
   - 다음으로 점수 기준 정렬
   → 이전 정렬 결과가 유지되어야 함

2. 객체 정렬에서 의미가 있음
   - 동일 key를 가진 데이터의 순서 보존

실무에서는 매우 중요한 특성이다.

---

## 5. 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?

### 버블 정렬: 안정 정렬

- 인접 원소만 비교
- 같은 값이면 교환하지 않음
- 상대적 순서 유지

### 삽입 정렬: 안정 정렬

- 삽입 시 같은 값보다 앞에 삽입하지 않음
- 순서 유지

### 선택 정렬: 기본 구현은 불안정

이유:

- 최소값을 찾아 멀리 있는 원소와 교환
- 이 과정에서 동일 값의 순서가 바뀔 수 있음

예:

```

(3, A), (2, B), (3, C)

```

최소값 2와 3(A) 교환 시  
3(A)와 3(C)의 상대적 순서가 깨질 수 있음.

정리:

| 알고리즘      | 안정성 |
|--------------|--------|
| Bubble Sort  | 안정 |
| Insertion Sort | 안정 |
| Selection Sort | 불안정 |

---

## 6. 실무에서 이 세 정렬을 사용하는 경우가 있는가?

### 직접 사용하는 경우는 거의 없음

현대 실무에서는:

- Java → TimSort
- C++ → IntroSort
- Python → TimSort

을 사용한다.

### 그러나 다음과 같은 상황에서는 사용됨

1. 데이터가 매우 작을 때 (n < 20)
2. 거의 정렬된 데이터일 때 → 삽입 정렬
3. 하이브리드 정렬의 내부 단계
   - QuickSort나 MergeSort의 작은 구간 처리
4. 교육 목적
5. 메모리 제약이 매우 강한 환경

특히 삽입 정렬은 실제 정렬 라이브러리 내부에서 자주 활용된다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

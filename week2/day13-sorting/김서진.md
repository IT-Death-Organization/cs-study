# Day 13: 정렬 알고리즘 1 (버블, 선택, 삽입)
> 📅 2025.02.25 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?
- [ ] 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?
- [ ] 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?
- [ ] 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?
- [ ] 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?
- [ ] 실무에서 이 세 정렬을 사용하는 경우가 있는가?
---
## 1. 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?
버블 정렬: 인접한 두 원소를 차례로 검사하여 큰 값을 오른쪽으로 밀어낸다. 이를 배열의 길이만큼 반복하는 정렬 방법이다.
    1. 앞에서부터 두 원소를 비교한다.
    2. 순서가 틀리면 교환한다.
    3. 한 바퀴 돌면 가장 큰 값이 맨 뒤로 간다.
    4. 이를 n-1번 반복한다.

버블 정렬이 비효율적인 첫번째 이유는 이미 다 정렬이 된 상태인데도 배열의 길이만큼 iteration을 반복하여 확인한다. 예를 들어, 길이가 7인 배열을 정렬한다고 하자. iteration 4번 만에 배열이 이미 정렬이 되었다고 해도 버블 정렬은 iteration 7까지 모든 요소를 비교한다. 
또한 원소 하나를 최종 위치로 옮기기 위해 너무 많은 교환이 발생한다. 작은 원소가 배열의 앞쪽으로 이동하기 위해 너무 많은 비교와 교환 과정을 거쳐야 하기에 비효율적이다.

버블 정렬은 구조가 단순하지만, 많은 데이터나 빠른 성능이 필요한 실제 개발환경에서는 사용하지 않는다. 특히 데이터 수가 10배 늘어나면, 연산 횟수는 100배 증가한다. 최선, 평균, 최악의 경우 모두 O(n^2)의 시간 복잡도를 가지기 때문이다.

---

## 2. 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?
선택 정렬: 가장 작은 값을 찾아 앞쪽 자리와 교환하며 정렬하는 방법이다. 
    1) 전체 배열에서 가장 작은 값을 찾는다.
    2) 그 값을 맨 앞 원소와 교환한다.
    3) 두 번째 위치부터 다시 최소값을 찾는다.
    4) 이를 끝까지 반복한다.
즉, 정렬 여부와 상관없이 매 iteration마다 남은 구간을 전부 탐색해서 최솟값을 찾는다.

선택정렬은 데이터의 초기 순서와 관계없이 항상 O(n^2)의 시간 복잡도를 갖는다. 데이터가 정렬되어 있더라도 최솟값을 찾기 위해 전체 원소를 매번 비교하고, 위치를 교환하는 2중 반복 구조로 수행되기 때문이다.

비교 횟수를 더 자세히 보겠다. 길이가 n인 배열이 있을때,
    1번째 단계: n-1번 비교
    2번째 단계: n-2번 비교
    ...
    마지막 단계: 1번 비교
총 비교 횟수는 (n-1) + (n-2) + ... + 1이다. 이는 등차수열의 합으로 n^2/2이며 시간 복잡도로는 O(n^2)이 된다.

선택 정렬은 배열이 이미 정렬되어 있어도, **최솟값을 찾기 위한 전체 탐색**을 생략하지 않는다. 이미 정렬된 상태 [1,2,3,4,5]라고 해도, 1~5단계까지 전부 비교한다. 따라서 최선의 경우에도 성능은 그대로이며 최선, 평균, 최악의 경우 모두 O(n^2)이다.

---

## 3. 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?
삽입 정렬: 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입하는 정렬 방법이다.
    1. 두번째 원소부터 시작한다.
    2. 현재 원소를 앞의 정렬된 부분과 비교한다.
    3. 자신보다 큰 값들을 오른쪽으로 밀고,
    4. 적절한 위치에 삽입한다.
이미 정렬된 구간에 새로운 원소를 끼워 넣는 방식이다.

삽입정렬의 시간복잡도는 **밀어내는 횟수**이다. 삽입 정렬의 비용은 **비교 횟수**와 **원소 이동 횟수**에 의해 결정된다. 특히 이동 횟수가 많을수록 느려진다.

거의 정렬된 배열의 예시는 다음과 같다:
[1,2,3,4,6,5]
5 하나만 제자리보다 뒤에 있다. 이때,
    1. 5와 6을 비교
    2. 6을 한 칸 밀기
    3. 5 삽입
하게 된다. 이때의 비용은 거의 **상수** 수준으로 작다.
완전히 정렬된 경우에는 각 단계에서 한번 비교 후 바로 종료되고 이동도 없기 때문에 O(n)이다.
반대로 최악의 경우, [5,4,3,2,1]과 같이 되어 있다면, 매번 앞의 모든 원소를 밀어야 한다. 이때는 O(n^2)이 될 것이다.

---

## 4. 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?
안정 정렬은 알고리즘의 한 카테고리이다. 안정 정렬은 나열된 수를 정렬한 뒤에도 기존에 있던 순서를 유지하는 것이다. 즉, 정렬 기준 값이 같은 원소들의 상대적 순서가 유지되는 정렬이다.

무슨 소리인가 싶다..ㅎ
예시를 들어보자!

(90, 철수)
(80, 영희)
(90, 민수)
가 있을때, **점수를 기준으로 오름차순 정렬을 하면**, 

(80, 영희)
(90, 철수)
(90, 민수)
와 같이 정렬된 것이 안정 정렬이다.
즉, 점수가 동일하게 90인 철수와 민수의 원래 순서를 유지한채 정렬이 완료된다.

대표적인 Stable sort로는,
    - 버블 정렬
    - 삽입 정렬
    - 병합 정렬
    - 힙 정렬
    - 퀵 정렬
이 있다.

안정 정렬이 중요한 이유는 크게 두가지가 있다.
    1. 다중 키 정렬
        2단계 이상 정렬할 때이다. 예를 들어 위의 예시처럼, 이름과 점수가 있을때 점수 기준 정렬이 안정 정렬이면 **점수가 같을 경우, 이름 순서가 그대로 유지된다**. 즉, 복합 정렬이 가능해진다.
    2. 실무 데이터는 보통 여러 속성을 가진다. 예를 들어 회원번호, 가입일, 등급, 점수 등이 있다. 안정 정렬이 아니라면, 정렬 과정에서 기존 의미있는 순서가 깨질수 있으며, 특히 DB 정렬이나 로그 정렬에서는 중요하다고 한다.

---

## 5. 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?
위에서 이미 답을 했지만, 버블과 삽입 정렬은 stable하다. 그러나 선택 정렬은 unstable하다.
1. 버블 정렬은 인접한 두 원소를 비교하고 앞이 더 클때만 교환한다. 때문에 같은 값을 가진 원소를 서로 자리를 바꾸지 않아 원래 순서가 유지된다.
2. 삽입 정렬은 현재 원소보다 큰 값만 오른쪽으로 민다. 이 정렬 또한 값이 같은 경우에는 이동하지 않고 같은 값은 기존 순서를 유지하기 때문에 stable하다.
3. 선택 정렬은 최소값을 찾아 앞의 원소와 교환하는 방식이었다. 
예를 들어, [2a, 2b, 1]이었다면, 2a와 1이 서로 자리가 교환되어 [1, 2a, 2b]이 될 것이다. 벌써 2a와 2b의 순서가 바뀌어버렸다. 따라서 상대적인 순서가 깨지므로 선택 정렬은 unstable하다!

---

## 6. 실무에서 이 세 정렬을 사용하는 경우가 있는가?
대규모 데이터 정렬에서는 모두 거의 사용되지 않는다. 버블 정렬과 선택 정렬은 거의 사용되지 않지만, 삽입정렬은 실무에서 쓰인다. 특히 작은 데이터와 거의 정렬된 데이터가 있을 경우에는 매우 빠르게 작동하기에 사용된다고 한다. 
대부분 c++에서는 Introsort, Java에서는 Dual-Pivot QuickSort, 파이썬에서는 Timsort 등을 쓴다고 한다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
Bubble sort: https://www.reddit.com/r/Python/comments/u90cgx/step_by_step_explanation_of_bubble_sort_with/?tl=ko

Bubble, Insertion, Selection sort: https://www.youtube.com/shorts/2PoEBDHZ3RU

Insertion sort: https://www.youtube.com/shorts/W8x-df6vryw

안정 정렬: https://hyo-ue4study.tistory.com/421
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 13: 정렬 알고리즘 1 (버블, 선택, 삽입)
> 📅 2025.02.25 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?
- [x] 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?
- [x] 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?
- [x] 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?
- [x] 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?
- [x] 실무에서 이 세 정렬을 사용하는 경우가 있는가?
---
<br>

# 1. 버블 정렬은 왜 비효율적인가? 어떤 경우에도 O(n²)인가?

> 버블 정렬은 인접한 두 원소를 쭉 비교해가며 큰 값을 계속 뒤로 보내는 방식입니다. 마치 거품이 위로 보글보글 올라오는 것과 같아서 붙여진 이름입니다.

버블 정렬은 그 특징때문에 두 원소의 자리가 바뀌는 데이터 교환(Swap)이 너무 빈번하게 일어납니다. 이러한 쓰기 작업은 컴퓨터에게 비용이 큰 작업입니다.

또한 만약 가장 작은 값이 배열의 맨 뒤에 있다면, 이 값이 맨 앞으로 오기까지 매 회전마다 한칸씩밖에 움직이지 못하므로 전체 배열을 계속 순회하는 비효율적인 모습을 보여줍니다.

기본적인 버블 정렬은 정렬 전 데이터가 어떻게 위치해있든 상관없이 항상 끝까지 비교를 수행하므로 최선, 평균, 최악 모두 $O(n^2)$의 시간복잡도를 가집니다. 하지만 한 번의 순회에서 교환이 한번도 일어나지 않았다면 이미 정렬이 완료되었다고 판단하고 종료하도록 하는 최적화를 적용한다면 최선의 경우 $O(n)$의 시간복잡도를 가지게됩니다.

<br>

# 2. 선택 정렬은 왜 항상 O(n²)인가? 최선의 경우도 마찬가지인 이유는?

> 선택 정렬은 전체에서 최솟값을 찾아 첫 번째 자리에 놓고, 남은 원소들에서 최솟값을 찾아 두 번째 자리에 놓는 방식으로 정렬을 수행합니다.

선택 정렬의 특성을 살펴보면 최선의 경우에도 시간 복잡도가 $O(n^2)$인 것을 알 수 있습니다. 어떤 값이 최소인지 찾기 위해 결국 배열 전체를 순회해야 하기 때문입니다.

<br>

# 3. 삽입 정렬이 거의 정렬된 배열에서 O(n)에 가까운 이유는?

> 삽입 정렬은 현재 위치에서 그 앞의 원소들과 비교하여 자신이 들어갈 적절한 위치를 찾아 '삽입'하는 방식입니다.

삽입 정렬의 가장 큰 특징은 데이터가 이미 어느 정도 정렬되어 있다면 압도적으로 빠르다는 점입니다.

### 조기 종료
삽입 정렬은 현재 원소를 앞의 원소들과 비교하다가, 자신보다 작은 원소를 만나는 즉시 그 자리에서 멈춥니다. 앞부분은 이미 정렬되어 있다는 전제가 있기 때문에 더 이상 앞으로 가서 비교할 필요가 없기 때문입니다.

만약 배열이 이미 완벽하게 정렬되어 있다면, 모든 원소는 바로 직전의 원소와 딱 한 번만 비교하고 제자리에 머물게 됩니다. 이 경우 전체 배열을 딱 한 번 순회하는 것과 같으므로 최선의 경우 $O(n)$의 성능을 보여줍니다.

<br>

# 4. 안정 정렬(Stable Sort)이란 무엇이며 왜 중요한가?

> 안정 정렬은 중복된 키를 가진 원소들의 기존 순서가 정렬 후에도 유지되는 정렬 알고리즘을 말합니다.

### 왜 중요한가?
데이터가 단일 값이 아니라 여러 필드를 가진 객체일 때 매우 중요해집니다.
예를 들어 성적순으로 정렬된 학생 명단을 다시 이름순으로 정렬한다고 가정해 봅시다. 안정 정렬을 사용하면 이름이 같은 학생들끼리는 기존의 성적 순서가 그대로 유지되지만, 불안정 정렬은 이 순서가 뒤섞일 수 있습니다. 즉, 다중 조건 정렬을 수행할 때 데이터의 신뢰성을 보장하기 위해 필수적입니다.

<br>

# 5. 세 정렬 중 어떤 것이 안정 정렬인가? 그 이유는?

세 정렬 알고리즘의 안정성 여부는 자리를 바꿀 때 인접한 원소만 건드리는가를 보면 알 수 있습니다.

| 알고리즘 | 안정성 | 이유 |
| :--- | :---: | :--- |
| **버블 정렬** | O | 인접한 두 원소만 비교하며, 값이 같으면 자리를 바꾸지 않으므로 순서가 유지됩니다. |
| **선택 정렬** | X | 멀리 떨어진 최솟값과 자리를 바꾸는 과정에서, 중간에 있던 동일한 값의 원소를 뛰어넘어 순서가 뒤바뀔 수 있습니다. |
| **삽입 정렬** | O | 자신보다 큰 원소하고만 자리를 바꾸고, 같은 값을 만나면 그 뒤에 멈추므로 순서가 유지됩니다. |

<br>

# 6. 실무에서 이 세 정렬을 사용하는 경우가 있는가?

결론부터 말하자면, 대규모 데이터를 처리할 때는 이 알고리즘들을 단독으로 사용하는 경우는 거의 없습니다. 보통 $O(n \log n)$인 퀵 정렬이나 병합 정렬을 사용하죠. 하지만 특정 상황에서는 여전히 쓰입니다.

* 삽입 정렬의 재발견
    * 데이터의 개수가 아주 적을 때(보통 10~20개 이하)는 오히려 퀵 정렬보다 빠를 수 있습니다. 그래서 현대의 고성능 정렬 알고리즘(Timsort 등)은 큰 덩어리는 병합 정렬로 나누고, 작은 조각들은 삽입 정렬로 마무리하는 하이브리드 방식을 취합니다.
* 임베디드/제한된 환경
    * 알고리즘이 매우 단순하고 별도의 추가 메모리 공간을 거의 쓰지 않기 때문에(In-place sort), 메모리가 극도로 제한된 환경에서 아주 작은 데이터를 정렬할 때 가끔 고려됩니다.
* 교육적 목적
    * 정렬의 가장 기초적인 원리와 시간 복잡도, 안정성 개념을 익히기에 최적이기 때문에 학습용으로 반드시 거쳐 가는 코스입니다.

<br>
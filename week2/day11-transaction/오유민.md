# Day 11: 트랜잭션(Transaction)과 ACID
> 📅 2025.02.23 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 트랜잭션이란 무엇이며 왜 필요한가?
- [x] ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?
- [x] 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?
- [x] Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?
- [x] 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?
- [x] 락(Lock)의 종류(공유 락, 배타 락)와 역할은?
- [x] 2PL(Two-Phase Locking) 프로토콜이란?

---

### 📌 [Q1] 트랜잭션이란 무엇이며 왜 필요한가?

트랜잭션이란 **데이터베이스의 상태를 변화시키기 위해 수행하는 하나의 논리적 작업 단위**를 말한다. (더 이상 쪼갤 수 없는 업무의 최소 단위)
즉, 데이터베이스에서 하나의 작업을 모두 성공하거나 모두 실패하도록 보장하는 논리적 실행 단위이다.

ex) 계좌 이체
A -> B에게 10만원 송금
1. A의 계좌에서 10만원 차감
2. B의 계좌에 10만원 입금

위 두 연산은 **하나의 트랜잭션**으로 묶여야 한다.
만약 A에서 돈은 차감됐는데 B에게 이 돈이 입금이 안 된다면 데이터가 꼬이는 큰 문제가 발생한다.
따라서 트랜잭션은 **모든 연산이 성공하거나, 모든 연산이 실패해야 한다.** (둘 다 성공하면 커밋, 하나라도 실패하면 롤백)

**트랜잭션이 필요한 이유**

1. 데이터 무결성 보장 (한 번에 처리되어야 하는 작업들을 하나의 단위로 묶어 처리함으로써 데이터의 일관성을 유지)
2. 동시성 제어 (여러 사용자가 동시에 데이터에 접근할 때 충돌 방지)
3. 회복 기능 (장애 발생 시 이전 상태로 복구)

### 📌 [Q2] ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?

**원자성(Atomicity)**
트랜잭션의 연산은 **모든 연산이 성공하거나, 모든 연산이 실패해야 한다.** (둘 다 성공하면 커밋, 하나라도 실패하면 롤백)

**일관성(Consistency)**
트랜잭션이 완료된 후에도 데이터베이스는 **일관된 정상 상태를 유지해야 한다. / 미리 정의된 규칙(제약 조건)을 만족해야 한다.** (무결성 제약 조건 준수)

**격리성(Isolation)**
트랜잭션은 **독립적으로 실행되어야 한다.** (동시에 실행되도 다른 트랜잭션의 영향을 받지 않도록 격리되어야 함)

**지속성(Durability)**
트랜잭션이 완료된 후에는 **데이터가 영구적으로 저장되어야 한다.** (장애 발생 시 복구 가능)

### 📌 [Q3] 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?

트랜잭션 격리 수준이란 **동시에 여러 트랜잭션이 실행될 때, 다른 트랜잭션의 연산이 현재 트랜잭션에 어느 정도까지 영향을 미칠 수 있는지**를 정의한 것이다. (격리 수준이 높을수록 안전하지만 성능은 저하될 수 있다.)

**1. Read Uncommitted (읽기 미확정)**
- 가장 낮은 격리 수준
- 다른 트랜잭션이 커밋하지 않은 데이터도 읽을 수 있음
- Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능

**2. Read Committed (읽기 확정)**
- 다른 트랜잭션이 커밋한 데이터만 읽을 수 있음 -> Dirty Read 방지
- 하지만 같은 데이터를 여러 번 조회했는데 중간에 다른 트랜잭션이 수정 후 커밋하면 값이 달라짐 -> Non-Repeatable Read, Phantom Read 발생 가능

**3. Repeatable Read (반복 읽기)**
- 한 트랜잭션 내에서는 같은 데이터를 여러 번 읽어도 항상 같은 값이 나옴 -> Dirty Read, Non-Repeatable Read 방지
- 하지만 같은 범위의 데이터를 읽었는데 중간에 다른 트랜잭션이 데이터를 추가 후 커밋하면 결과가 달라짐 -> Phantom Read 발생 가능

**4. Serializable (직렬화)**
- 가장 높은 격리 수준
- 트랜잭션이 순차적으로 실행되는 것과 동일한 결과 보장 (순차적으로 실행한 것처럼 보임)
- Dirty Read, Non-Repeatable Read, Phantom Read 모두 방지
- lock을 많이 사용해서 성능이 저하될 수 있음

### 📌 [Q4] Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?

**1. Dirty Read (더티 리드)**
- 커밋되지 않은 데이터를 읽음

**2. Non-Repeatable Read (반복 읽기 불가능)**
- 한 트랜잭션 내에서 같은 데이터를 여러 번 읽었는데 다른 값이 나옴 (같은 쿼리를 두 번 실행했는데 값이 달라짐, 같은 행을 다시 읽었는데 값이 바뀜)

**3. Phantom Read (팬텀 리드)**
- 같은 조건으로 다시 조회했는데 없던 행이 생기거나 있던 행이 사라짐

### 📌 [Q5] 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
|:---:|:---:|:---:|:---:|
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | 방지 | 발생 | 발생 |
| Repeatable Read | 방지 | 방지 | 발생 |
| Serializable | 방지 | 방지 | 방지 |

### 📌 [Q6] 락(Lock)의 종류(공유 락, 배타 락)와 역할은?

락은 동시에 여러 트랜잭션이 같은 데이터에 접근할 때 데이터 충돌을 막기 위한 장치이다.

**공유 락(Shared Lock)**
- 데이터를 읽을 때 사용 (read)
- 역할: 내가 데이터를 읽는 동안 다른 사람이 그 데이터를 수정하지 못하게 막음
- 여러 트랜잭션이 동시에 한 데이터에 대해 공유 락을 걸 수 있음 (여러 트랜잭션이 동시에 데이터를 읽을 수 있음, 수정은 x)
- 공유 락끼리는 서로 방해하지 않음

**배타 락(Exclusive Lock)**
- 데이터를 수정할 때 사용 (write)
- 역할: 내가 데이터를 수정하는 동안 다른 사람이 그 데이터를 읽거나 수정하지 못하게 막음 (독점함)
- 한 번 배타 락이 걸리면 다른 트랜잭션은 데이터를 읽거나 수정할 수 없음
- 배타 락은 어떤 락과도 공존할 수 없음 (공유 락, 배타 락 모두 x)

### 📌 [Q7] 2PL(Two-Phase Locking) 프로토콜이란?

2PL(Two-Phase Locking) 프로토콜은 트랜잭션이 락을 획득하고 해제하는 방식을 정의한 프로토콜로, 트랜잭션이 **락을 획득하는 단계(Growing Phase)**와 **락을 해제하는 단계(Shrinking Phase)**로 구성된다.

**1. 락 획득 단계 (Growing Phase)**
- 트랜잭션은 필요한 락을 획득할 수 있다.
- 이 단계에서는 락을 해제할 수 없다.

**2. 락 해제 단계 (Shrinking Phase)**
- 트랜잭션은 보유하고 있는 락을 해제할 수 있다.
- 이 단계에서는 새로운 락을 획득할 수 없다.

이때 **! 한 번이라도 락을 해제하면 그 이후로는 락을 획득할 수 없다. !**
이때문에 **트랜잭션 실행 순서가 꼬이지 않고 순차적으로 실행되는 것과 동일한 결과를 보장**한다. (Serializable 보장)

ex)
트랜잭션 A (올바른 2PL)
1. 계좌1 배타락
2. 계좌2 배타락
3. 계좌1 락 해제
4. 계좌2 락 해제

트랜잭션 B (잘못된 2PL)
1. 계좌1 락
2. 계좌1 락 해제
3. 계좌2 락 <- X (2PL에서는 락 해제 후 락 획득 불가)

---
## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

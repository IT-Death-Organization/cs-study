# Day 11: 트랜잭션(Transaction)과 ACID
> 📅 2025.02.23 | 📁 Week 2

---

## 🧠 학습 질문
- [x] 트랜잭션이란 무엇이며 왜 필요한가?
- [x] ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?
- [x] 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?
- [x] Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?
- [x] 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?
- [x] 락(Lock)의 종류(공유 락, 배타 락)와 역할은?
- [x] 2PL(Two-Phase Locking) 프로토콜이란?

---

## Q1. 트랜잭션이란 무엇이며 왜 필요한가?

[답변]
* 트랜잭션: 데이터베이스에서, 하나의 논리적 작업 단위를 이루는 연산들의 묶음
  - 여러 읽기/쓰기 함께 수행
  - 전부 실패(Rollback) or 전부 성공(Commit)
* 필요한 이유
  - 데이터 정합성(Consistency) 보장: 중간에 실패 -> 데이터 정합성 깨짐
  - 동시성(Concurrency) 제어: 여러 사용자가 동시에 접근/수정해도 서로의 작업이 꼬이지 않음
  - 장애 복구(Recovery): 시스템 오류 or 전원 장애 발생 -> 완료된 작업만 남기고 미완료 작업은 되돌림

---

## Q2. ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?

[답변]
* 원자성(Atomicity): 하나의 트랜잭션 내의 연산들은 모두 성공하거나 모두 실패함 -> 더이상 '쪼개지지 않는' 원자성을 가짐
* 일관성(Consistency): 트랜잭션 수행 전후의 데이터가 정의된 규칙(제약조건, 무결성)을 항상 만족함
* 격리성(Isolation): 다른 트랜잭션과 독립적으로 실행되는 것처럼 보임
* 지속성(Durability): 트랜잭션이 COMMIT되면 그 결과가 유지됨

[보완]
* 트랜잭션이 '단독으로 실행'되는 게 아니라 '단독으로 실행되는 것처럼 보이는' 것인 이유
  - 현실의 DB는 성능 이유로 여러 트랜잭션을 동시에 실행
  - 서로의 중간 결과를 건드려 이상 현상이 발생할 수 있음
  - Lock, MVCC를 사용해 격리성 구현

---

## Q3. 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?

[답변]
* Read Uncommitted
  - 다른 트랜잭션이 커밋하지 않은 변경 내용도 조회 가능
  - 동시성 가장 높음, 이상 현상 가장 빈번
* Read Committed
  - 다른 트랜잭션이 커밋한 데이터만 조회 가능
  - Dirty Read 방지
  - Non-Repeatable Read, Phantom Read 발생 가능
* Repeatable Read
  - 한 트랜잭션에서 같은 행을 반복 조회 시 항상 동일한 값 보장(Non-Repeatable Read 방지)
  - 구현에 따라 Phantom Read 발생 가능
* Serializable
  - 가장 강한 격리
  - 동시에 실행되어도 결과가 어떤 순서로 직렬 실행한 것과 동일하게 보장
  - Dirty/Non-Repeatable/Phantom 모두 방지
  - 성능/동시성 가장 낮음
 
[보완]
* 직렬 실행(Serial Execution): 트랜잭션을 동시에 섞지 않고 한 번에 하나씩 실행
* 격리 수준이 높아질수록 정합성↑, 동시성↓, 락 경합↑, 대기/교착 가능성↑ 경향
* 실제 DBMS는 “Repeatable Read에서 Phantom을 막는 방식”이 락 기반/다중버전(MVCC) 등에 따라 다름

---

## Q4. Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?

[답변]
* Dirty Read: 다른 트랜잭션이 커밋하지 않은 변경을 읽는 현상. 이후에 그 트랜잭션이 롤백하면 조회한 값이 '존재하지 않는 값'이 됨
* Non-Repeatable Read: 한 트랜잭션이 같은 행을 두 번 조회하는데, 그 사이 다른 트랜잭션이 UPDATE -> COMMIT해 값이 달라지는 현상
  - Repeatable Read에서 이를 방지하는 방법: Lock, MVCC
* Phantom Read: 한 트랜잭션이 같은 조건으로 두 번 조회하는데, 그 사이 다른 트랜잭션이 INSERT/DELETE -> COMMIT해 조회 결과의 행 개수 및 목록이 달라지는 현상
  - phantom: 유령

---

## Q5. 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?

[답변]
* Read Uncommitted
  - 방지: X
  - 발생 가능: Dirty Read, Non-Repeatable Read, Phantom Read
* Read Committed
  - 방지: Dirty Read
  - 발생 가능: Non-Repeatable Read, Phantom Read
* Repeatable Read
  - 방지: Dirty Read, Non-Repeatable Read
  - 발생 가능: Phantom Read
* Serializable
  - 방지: Dirty Read, Non-Repeatable Read, Phantom Read
  - 발생 가능: X
 
[보완]
* “Repeatable Read에서 Phantom이 막히는지”는 DBMS 구현에 따라 차이가 있음
  - 락 기반 구현: 범위 락(range lock), 갭 락(gap lock), next-key lock
  - MVCC 기반 구현: 스냅샷/검증(예: 직렬화 충돌 감지) 방식

---

## Q6. 락(Lock)의 종류(공유 락, 배타 락)와 역할은?

[답변]
* 공유 락(Shared Lock, S-lock)
  - 읽기용 락
  - 여러 트랜잭션이 동시에 S-lock 획득 가능
  - 다른 트랜잭션의 X-lock 막음
* 배타 락(Exclusive Lock, X-lock)
  - 쓰기용 락
  - 한 트랜잭션이 X-lock을 잡으면 다른 트랜잭션은 S-lock/X-lock 모두 획득 불가

[보완]
* 호환성
  - S vs S: 가능
  - S vs X: 불가
  - X vs X: 불가

---

## Q7. 2PL(Two-Phase Locking) 프로토콜이란?

[답변]
* 2PL(2단계 락킹): 트랜잭션이 락을 획득/해제하는 규칙 강제 -> 동시성 환경에서도 직렬 가능성 보장
  - 단계
    1. 성장 단계(Growing Phase): 락 획득만 가능, 해제 불가
    2. 축소 단계(Shrinking Phase): 락 해제만 가능, 새 락 획득 불가
  - 락을 한 번이라도 해제하기 시작하면, 그 이후에는 새로운 락을 얻지 않는다
  - 락 해제 후 새 락 획득이 가능하면, 여러 트랜잭션의 실행 순서가 '꼬임'
  - **어떤 트랜잭션이 필요한 락들을 '모두 획득'할 때까지 다른 락들을 해제하지 않는다**

[보완]
* 동작 예시
  - 트랜잭션 T1이 A를 읽고(A는 SELECT), B를 수정(B는 UPDATE)
    - 성장 단계(락 획득)
      1. T1: A를 얻기 위해 S-lock(A) 획득
      2. T1: B를 수정하기 위해 X-lock(B) 획득
      3. T1: 필요한 작업 수행(SELECT A, UPDATE B)
    - 축소 단계(락 해제)
      4. T1: unlock(A) (또는 커밋 시점에 일괄 해제)
      5. T1: unlock(B)
      6. T1: COMMIT/ROLLBACK
    - 4에서 unlock을 시작하면, X-lock(C)와 같이 새 락 획득 불가
    - unlock 이후에 새 락 획득 시 트랜잭션 실행 순서 꼬임 -> 직렬 가능성 보장 어려움
  - T1: A를 읽고 나서 A를 수정하려고 함 (읽기 후 쓰기)
    T2: 동시에 A를 수정하려고 함
      1. T1(성장): S-lock(A) 획득 -> A 읽기
      2. T2(성장): X-lock(A) 요청 -> 대기
      3. T1: X-lock(A) 요청
         - 락 업그레이드(S -> X) 시도
      4. T1: X-lock(A) 획득(업그레이드 성공) -> A UPDATE
      5. T1(축소): COMMIT 후 unlock(A)
      6. T2: X-lock(A) 획득 -> UPDATE -> COMMIT

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 11: 트랜잭션(Transaction)과 ACID
> 📅 2025.02.23 | 📁 Week 2
---
## 🧠 학습 질문
- [ ] 트랜잭션이란 무엇이며 왜 필요한가?
- [ ] ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?
- [ ] 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?
- [ ] Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?
- [ ] 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?
- [ ] 락(Lock)의 종류(공유 락, 배타 락)와 역할은?
- [ ] 2PL(Two-Phase Locking) 프로토콜이란?
---

## 1. 트랜잭션이란 무엇이며 왜 필요한가?
트랜잭션이란:
    DB의 상태를 변화시키는 하나의 논리적인 작업에 포함된 연산들의 집합이다.
    트랜잭션은 완전히 완료되기도 하고, 전혀 완료되지 않을수도 있으며, 스토리지 시스템을 **한결같은 상태**로 둔다. 예를 들어 은행 계좌에서 금액을 이체할때, 현금이 계좌에서 이체되거나, 이체되지 않거나 둘 중의 하나일 뿐, 그 중간 어딘가의 상태란 없는 것과 같다. 은행 계좌에서 이체할때, 
        1. A 계좌의 잔액을 조회
        2. A 계좌의 잔액에서 이체할 금액을 빼고 저장
        3. B 계좌의 잔액을 조회
        4. B 계좌에 이체 금액을 더한 뒤 저장
    까지 몇가지의 과정들이 필요하고, 이를 모두 합쳐 **계좌이체**라는 하나의 작업단위를 구성한다. 이렇듯 DB 상태 변화를 위한 작업에 포함된 과정(연산)의 집합을 트랜잭션이라고 한다.

트랜잭션의 필요성:
    트랜잭션은 DB의 상태를 변화시키기 위한 작업에 필요한 모든 연산이 모두 성공적으로 수행될 수도 있지만 그렇지 않을 수도 있다. 즉 연산 과정 중 오류 발생 시, 데이터의 불일치를 방지하고 무결성과 일관성을 보장하기 위해 트랜잭션이 필요하다.
    예를 들어 A 계좌에서 B 계좌로 금액을 이체하기 위해 A 계좌에서 이체할 금액을 빼고 저장했다. 그러나 예기치 못한 상황으로 중단되어 B 계좌에 금액을 더하여 저장하지 못했다. 이러한 상황을 트랜잭션으로 관리하지 않는다면, A 계좌에서 빠진 금액이 증발해버리고 만다. 이러한 상황을 방지하기 위해 ACID 성질을 갖는 트랙잭션을 사용한다.

---

## 2. ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?
- **A**(Atomicity - 원자성): 트랜잭션의 연산은 모두 수행되거나 하나도 수행되지 않은 상태를 보장해야 한다.
- **C**(Consistency - 일관성): 트랜잭션이 완료된 이후에도 DB가 일관된 상태를 유지해야 한다.
- **I**(Isolation - 독립성): 한 트랜잭션이 수행되는 도중 변경한 데이터는 완료될 때까지 다른 트랜잭션이 접근하지 못하도록 해야한다.
- **D**(Durability - 지속성): 트랜잭션 실행으로 인해 변경된 데이터는 저장되도록 보장한다.

---

## 3. 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?
트랜잭션 격리 수준이란, 여러 트랜잭션이 동시에 처리될때 트랜잭션끼리 얼마나 격리 되어 있는가에 대한 수준을 말한다.
트랜잭션의 성질 중 하나인 Isolation(독립성)은 트랜잭션 수행 시, 다른 트랜잭션이 끼어들지 못하도록 보장하는 것을 말한다. 이는 '트랜잭션은 서로 완전히 격리되어 있으니 다른 트랜잭션이 끼어들지 못한다'가 아닌, 독립성을 강화시킨다면 다른 트랜잭션이 끼어들지 못하게 보장할 수 있고, 약화시킨다면 다른 트랜잭션이 중간에 끼어들 수 있다는 의미이다.

트랜잭션 수행 중간에 다른 트랜잭션이 끼어들 수 없다면 어떻게 될까? 모든 트랜잭션은 순차적으로 이루어질 것이고 **데이터의 정확성**은 보장될 것이다. 그렇다면 **속도**는 어떨까? 트랜잭션이 많아질수록 처리를 기다리는 트랜잭션은 쌓여간다. 앞에 있는 트랜잭션이 기다리는 시간만큼 대기시간이 늘어난다. 

결국, 처리 속도를 위해서는 트랜잭션의 완전한 격리가 아닌 완화된 수준의 격리가 필요하다. 이처럼 **속도와 데이터 정확성**의 trade off를 고려하여 트랜잭션의 격리성 수준을 나눈 것이 바로 **트랜잭션의 격리 수준**이다.

격리 수준이 가장 낮은 순으로 알아보겠다.

    1. Read Uncommitted(커밋되지 않은 읽기)
        한 트랜잭션의 변경 사항이 커밋되지 않아도 다른 트랜잭션에서 읽을 수 있다. 즉 다른 트랜잭션에서 커밋되지 않은 데이터에 접근할 수 있는 격리 수준이다. 가장 저수준의 격리이며 일반적으로 사용하지 않는다.
        커밋되지 않은 트랜잭션에 접근하여 부정합을 유발할 수 있는 데이터를 읽는 것을 Dirty Read라고 한다.

    2. Read Committed(커밋된 읽기)
        다른 트랙잭션에서 커밋된 데이터로만 접근할 수 있게 하는 격리 수준이다. MySQL을 제외하고 대부분 이를 기본 격리수준으로 사용한다.

    3. Repeatable Read(반복 가능한 읽기)
        Non Repeatable Read 문제를 해결하는 격리 수준으로, 커밋된 데이터만 읽을 수 있되 자신보다 낮은 트랜잭션 번호를 갖는 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리수준이다. 
        이게 가능한 이유는? Undo 로그 때문이다. 또한 트랜잭션 ID를 통해 Undo 영역의 데이터를 스냅샷처럼 관리하여 동일한 데이터를 보장하는 것을 MVCC(Multi Version Concurrency Control) 라고 한다.
        즉, 트랜잭션 내에서 조회한 데이터는 항상 동일함을 보장한다. MySQL(InnoDB) 기본 설정이며 Phantom Read(유령 읽기) 문제가 발생할 수 있다.

    4. Serializable
        가장 고수준의 격리수준으로 트랜잭션을 무조건 순차적으로 진행시킨다. 트랜잭션이 끼어들 수 없으니 데이터의 부정합 문제는 발생하지 않으나, 동시 처리가 불가능하여 처리 속도가 느려진다. 
        트랜잭션이 중간에 끼어들 수 없는 이유는 SELECT 쿼리 실행 시 Shared Lock(공유 잠금)을, INSERT, UPDATE, DELETE 쿼리 실행 시 Exclusive Lock (MySQL의 경우 Nexy Key Lock)을 걸어버리기 때문이다.


## 4. Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?
### 1) Dirty Read
아직 **커밋되지 않은 데이터**를 다른 트랜잭션이 읽는 현상이다.

- T1이 데이터를 수정했지만 아직 COMMIT하지 않은 상태
- T2가 그 데이터를 읽음
- 이후 T1이 ROLLBACK하면?
  → T2는 실제로 존재하지 않는 데이터를 읽은 것이 됨

즉, **무효화될 수 있는 데이터를 읽는 문제**이다.  
발생 격리 수준: **Read Uncommitted**

---

### 2) Non-Repeatable Read (반복 불가능 읽기)
하나의 트랜잭션 내에서 **같은 행(Row)을 두 번 조회했을 때 결과가 달라지는 현상**이다.

- T1이 특정 row를 조회
- T2가 그 row를 수정 후 COMMIT
- T1이 다시 조회 → 값이 달라짐

즉, 같은 데이터를 읽었는데 값이 바뀌는 문제이다.  
발생 격리 수준: **Read Committed**

---

### 3) Phantom Read (유령 읽기)
같은 조건으로 조회했을 때 **존재하지 않던 행이 새로 나타나는 현상**이다.

- T1이 `WHERE age > 20` 조건으로 조회
- T2가 age 25인 데이터를 INSERT 후 COMMIT
- T1이 다시 조회 → 행이 하나 증가

즉, 행 자체가 추가/삭제되어 결과 집합이 달라지는 문제이다.  
발생 격리 수준: **Repeatable Read (표준 기준)**  
※ MySQL InnoDB는 Next-Key Lock으로 대부분 방지

---

## 5. 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?
| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
|------------|------------|--------------------|--------------|
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed   | 방지 | 발생 | 발생 |
| Repeatable Read  | 방지 | 방지 | 발생(표준 기준) |
| Serializable     | 방지 | 방지 | 방지 |

정리하면 다음과 같다.

- **Read Uncommitted**
  → 아무것도 보장하지 않는다. 성능은 가장 빠르지만 정합성은 가장 낮다.

- **Read Committed**
  → Dirty Read만 방지한다.
  → 대부분 DBMS의 기본 설정 (Oracle, PostgreSQL 등)

- **Repeatable Read**
  → Dirty Read + Non-Repeatable Read 방지
  → MySQL(InnoDB) 기본 설정
  → MVCC 기반으로 스냅샷 유지

- **Serializable**
  → 모든 문제 방지
  → 완전한 직렬 실행과 동일한 결과 보장
  → 성능 저하가 큼

---

## 6. 락(Lock)의 종류(공유 락, 배타 락)와 역할은?
락은 동시성 제어를 위해 **데이터 접근을 제어하는 메커니즘**이다.

### 1) 공유 락 (Shared Lock, S-Lock)

- 읽기 전용 락
- 여러 트랜잭션이 동시에 획득 가능
- 하지만 배타 락과는 공존 불가

#### 예시
T1: SELECT → S-Lock 획득
T2: SELECT → S-Lock 획득 가능
T3: UPDATE → X-Lock 필요 → 대기

즉, 공유 락은 **데이터를 읽는 동안 수정이 발생하지 않도록 보호하는 역할**을 한다.

---

### 2) 배타 락 (Exclusive Lock, X-Lock)

- 쓰기(Update, Insert, Delete) 시 사용되는 락
- 단 하나의 트랜잭션만 획득 가능
- 모든 다른 락(S, X)과 공존 불가

#### 특징

- Write-Write 차단
- Write-Read 차단

#### 예시
T1: UPDATE → X-Lock 획득
T2: SELECT → 대기
T3: UPDATE → 대기

즉, 배타 락은 **데이터 변경 시 완전한 독점권을 보장**한다.

---

### 3) 락 호환성 정리

| 요청 ↓ / 보유 → | S-Lock | X-Lock |
|----------------|--------|--------|
| S-Lock 요청    | 가능   | 불가   |
| X-Lock 요청    | 불가   | 불가   |

---

### 4) 락의 역할 요약

- 데이터 정합성 보장
- Dirty Read 방지
- 직렬 가능성(Serializable) 구현의 기반
- 동시성 제어 핵심 메커니즘

단점은 과도한 락 사용 시 성능 저하와 교착상태(Deadlock) 가능성이 있다는 점이다.

---

## 7. 2PL(Two-Phase Locking) 프로토콜이란?

2PL은 트랜잭션이 락을 두 단계로 나누어 관리하는 동시성 제어 기법이다.  
직렬 가능성(Serializable)을 보장하는 대표적인 방법이다.

---

### 1) Two-Phase 구조

#### (1) Growing Phase (확장 단계)
- 필요한 락을 획득만 가능
- 락 해제는 불가능

#### (2) Shrinking Phase (축소 단계)
- 락을 해제만 가능
- 새로운 락 획득은 불가능

구조적으로는 다음과 같다:
[락 획득 단계] → [락 해제 단계]

중간에 다시 락을 얻으면 2PL 위반이다.

---

### 2) 2PL의 특징

- 충돌 직렬 가능성(Conflict Serializability) 보장
- 락 기반 동시성 제어의 핵심 이론
- Deadlock 발생 가능

---

### 3) Strict 2PL (엄격 2단계 락킹)

실제 DBMS에서 가장 많이 사용하는 방식이다.

특징:

- 모든 배타 락(X-Lock)을 COMMIT 또는 ROLLBACK 시점까지 유지
- Cascading Rollback 방지
- Recoverability 보장

즉, 트랜잭션 종료 시점까지 쓰기 락 유지


이로 인해 안정성은 높아지지만 동시성은 감소할 수 있다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
https://rays-space.tistory.com/30

---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

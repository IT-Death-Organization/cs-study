# Day 11: 트랜잭션(Transaction)과 ACID
> 📅 2025.02.23 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 트랜잭션이란 무엇이며 왜 필요한가?
- [x] ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?
- [x] 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?
- [x] Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?
- [x] 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?
- [x] 락(Lock)의 종류(공유 락, 배타 락)와 역할은?
- [x] 2PL(Two-Phase Locking) 프로토콜이란?
---
# 1. 트랜잭션(Transaction)이란 무엇이며 왜 필요한가?

## 정의

트랜잭션은 데이터베이스에서 하나의 **논리적 작업 단위**이다.  
여러 SQL 문이 하나의 작업처럼 동작해야 할 때 사용한다.

예시:

A 계좌 -10000  
B 계좌 +10000  

위 두 작업은 반드시 함께 성공하거나 함께 실패해야 한다.

## 왜 필요한가?

1. 데이터 무결성 보장
2. 동시성 환경에서 정합성 유지
3. 시스템 장애 시 복구 가능성 확보

즉, **중간 상태가 외부에 노출되면 안 되기 때문에** 트랜잭션이 필요하다.

---

# 2. ACID 속성 설명

## 2.1 Atomicity (원자성)

- 전부 성공하거나 전부 실패
- 부분 커밋 없음
- 실패 시 Rollback

예: 송금 중 하나라도 실패하면 전체 작업 취소

---

## 2.2 Consistency (일관성)

- 트랜잭션 전후에 DB는 항상 유효한 상태
- 제약조건과 무결성 조건 유지

예:
- 계좌 잔액은 음수가 될 수 없음
- 외래키 제약 위반 불가

---

## 2.3 Isolation (격리성)

- 동시에 실행되는 트랜잭션이 서로 영향을 최소화
- 마치 순차적으로 실행된 것처럼 보이게 함

---

## 2.4 Durability (지속성)

- Commit 이후 데이터는 영구 저장
- 시스템 장애가 발생해도 유지됨
- WAL(Write-Ahead Logging)을 통해 보장

---

# 3. 트랜잭션 격리 수준 차이

| 격리 수준           | Dirty Read | Non-Repeatable Read | Phantom Read |
|--------------------|------------|----------------------|--------------|
| Read Uncommitted   | 발생       | 발생                 | 발생         |
| Read Committed     | 방지       | 발생                 | 발생         |
| Repeatable Read    | 방지       | 방지                 | DBMS에 따라 다름 |
| Serializable       | 방지       | 방지                 | 방지         |

---

## 3.1 Read Uncommitted

- 커밋되지 않은 데이터도 읽음
- Dirty Read 발생
- 거의 사용되지 않음

---

## 3.2 Read Committed

- 커밋된 데이터만 읽음
- Dirty Read 방지
- 가장 많이 사용됨 (Oracle 기본값)

---

## 3.3 Repeatable Read

- 동일 Row에 대해 반복 조회 시 동일한 결과 보장
- Non-Repeatable Read 방지
- MySQL(InnoDB) 기본값
- Phantom Read는 락 기반 DB에서는 발생 가능

---

## 3.4 Serializable

- 완전한 직렬 실행처럼 동작
- 가장 안전한 격리 수준
- 성능 비용이 가장 큼

---

# 4. 동시성 문제 3종

## 4.1 Dirty Read

커밋되지 않은 데이터를 읽는 현상

T1:
UPDATE A = 100  
(Commit 안함)

T2:
SELECT A → 100 읽음

T1이 Rollback하면 T2는 잘못된 값 사용

---

## 4.2 Non-Repeatable Read

같은 Row를 두 번 읽었는데 값이 변경되는 현상

T1:
SELECT balance → 100

T2:
UPDATE balance → 200  
COMMIT

T1:
SELECT balance → 200

---

## 4.3 Phantom Read

조건 조회 결과 집합이 달라지는 현상

T1:
SELECT * FROM user WHERE age > 20

T2:
INSERT age = 25  
COMMIT

T1이 다시 조회하면 행이 증가함

---

# 5. 격리 수준별 문제 발생 여부

| 격리 수준        | Dirty | Non-Repeatable | Phantom |
|-----------------|--------|----------------|----------|
| Read Uncommitted| O      | O              | O        |
| Read Committed  | X      | O              | O        |
| Repeatable Read | X      | X              | O        |
| Serializable    | X      | X              | X        |

---

# 6. Lock의 종류와 역할

## 6.1 Shared Lock (S-Lock, 공유 락)

- 읽기 락
- 여러 트랜잭션이 동시에 획득 가능
- 쓰기 불가

정리:
읽기 가능  
쓰기 불가  

---

## 6.2 Exclusive Lock (X-Lock, 배타 락)

- 쓰기 락
- 하나의 트랜잭션만 획득 가능
- 읽기 및 쓰기 모두 차단

정리:
읽기 불가  
쓰기 불가  

---

## 6.3 Lock의 목적

- 동시성 제어
- 격리성 보장
- Lost Update 방지

---

# 7. 2PL (Two-Phase Locking) 프로토콜

## 정의

트랜잭션의 락 획득을 두 단계로 나누는 방식

---

## 7.1 Growing Phase

- Lock 획득만 가능
- Lock 해제 불가

---

## 7.2 Shrinking Phase

- Lock 해제만 가능
- 새로운 Lock 획득 불가

즉, 락을 해제하기 시작하면 이후에는 새로운 락을 획득할 수 없다.

---

## 왜 필요한가?

2PL을 따르면 **충돌 직렬 가능성(Conflict Serializability)** 이 보장된다.  
즉, 실행 결과가 어떤 직렬 실행과 동일한 결과를 갖는다.

---

## Strict 2PL

- 모든 X-Lock을 Commit 시점까지 유지
- Cascading Rollback 방지
- 대부분의 상용 DBMS에서 사용

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
---
## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

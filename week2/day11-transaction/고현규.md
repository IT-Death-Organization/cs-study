# Day 11: 트랜잭션(Transaction)과 ACID
> 📅 2025.02.23 | 📁 Week 2
---
## 🧠 학습 질문
- [x] 트랜잭션이란 무엇이며 왜 필요한가?
- [x] ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?
- [x] 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?
- [x] Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?
- [x] 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?
- [x] 락(Lock)의 종류(공유 락, 배타 락)와 역할은?
- [x] 2PL(Two-Phase Locking) 프로토콜이란?
---
<br>

# 1. 트랜잭션이란 무엇이며 왜 필요한가?

> 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 하나의 논리적 작업 단위입니다.

하나의 논리적 작업 단위라는 것은 중간에 끊기지 않고 한꺼번에 처리되어야 하는 작업 세트를 말합니다.

예를 들어, A 계좌에서 B 계좌로 100만원을 이체하는 작업을 트랜잭션이라고 할 수 있습니다.

이 과정에서 A 계좌에서 100만원이 출금되고, B 계좌로 100만원이 입금되는 2가지 상태변화가 있는데, 만약 두 작업 중 하나만 성공하고 나머지 하나는 실패한다면 큰일이 날 것입니다. 돈 100만원이 복사되거나 사라지는 재앙이 생길 것입니다.

트랜잭션은 바로 이러한 상황을 막기 위해 두 작업을 하나로 묶어서 전부 성공하거나 아예 없었던 일로 만드는 상황을 보장합니다. (All or Nothing)

<br>

# 2. ACID 속성(원자성, 일관성, 격리성, 지속성)을 각각 설명하면?

### 원자성 (Atomicity) - "All or Nothing"

트랜잭션 내의 모든 연산은 반드시 모두 성공하거나, 아니면 아예 실패해야 합니다.

### 일관성 (Consistency)

트랜잭션이 실행되기 전과 후에 데이터베이스는 항상 일관된 상태를 유지해야 합니다.

예를 들어 통장 잔고는 0원 이상이어야 한다는 규칙이 있다면, 이체 트랜잭션이 수행된 이후에 통장 잔고가 음수가 되는 일은 없어야 합니다.

### 격리성 (Isolation)

여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 서로의 작업에 끼어들거나 간섭할 수 없습니다.

### 지속성 (Durability)

트랜잭션이 성공적으로 완료(Commit)되었다면, 그 결과는 영구적으로 보존 되어야 합니다.

만약 트랜잭션 수행 완료 후에 시스템 장애가 발생하거나 전원이 꺼지는 상황이 생겨도, 한 번 기록된 데이터는 로그 파일 등을 통해 복구되어야 합니다.

<br>

# 3. 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)의 차이는?

> 격리 수준은 여러 트랜잭션이 동시에 돌아갈 때, 얼마나 서로를 모르게 할 것인지에 대한 설정입니다.

격리 수준은 높을수록 데이터의 정확성은 올라가지만, 그만큼 데이터를 잠그는 시간이 길어져 성능은 떨어집니다.

### 1) READ UNCOMMITTED (Level 0)

다른 트랜잭션이 작업중인(아직 커밋하지 않은) 데이터도 읽을 수 있습니다.

격리성이 거의 없습니다. 속도는 빠르지만 데이터의 신뢰성은 매우 낮고, Dirty Read가 발생할 수 있습니다.

### 2) READ COMMITTED (Level 1)

커밋이 완료된 데이터만 읽을 수 있습니다.

대부분의 DB(Oracle, PostgreSQL, SQL Server 등)에서 기본값으로 사용하는 가장 일반적인 수준입니다.

격리성과 신뢰성은 어느정도 있습니다. 다만, 한 트랜잭션 내에서 똑같은 데이터 조회를 두 번 했는데 그 결과가 달라지는 Non-Repeatable Read가 발생할 수 있습니다.

### 3) REPEATABLE READ (Level 2)

한 트랜잭션 내에서 똑같은 데이터 조회를 두 번 해도 항상 같은 결과를 보장합니다.

MySQL(InnoDB)의 기본값입니다.

격리성과 신뢰성은 높습니다. 다만, 데이터는 그대로인데 없던 레코드가 갑자기 나타나는 Phantom Read가 발생할 수 있습니다.

### 4) SERIALIZABLE (Level 3)

가장 높은 격리 수준으로, 트랜잭션을 순차적으로 실행하는 것처럼 동작한다고 생각하면 됩니다.

모든 읽기 작업에도 공유 락(Shared Lock)을 걸기 때문에, 다른 트랜잭션이 수정할 수 없습니다.

다만, 동시 처리 성능이 급격히 떨어지기 때문에 실제 운영 환경에서는 거의 사용되지 않습니다.

<br>

# 4. Dirty Read, Non-Repeatable Read, Phantom Read란 무엇인가?

### 1) Dirty Read (더티 리드)

트랜잭션 $T_1$이 데이터를 수정하고 아직 커밋하지 않았는데, 트랜잭션 $T_2$가 이 데이터를 읽어서 사용하는 경우에 발생합니다.

만약 $T_1$에 문제가 생겨 롤백(Rollback)되면, $T_2$가 읽은 데이터는 존재하지 않는 가짜(Dirty) 데이터가 됩니다.

### 2) Non-Repeatable Read (비반복 읽기)

한 트랜잭션 내에서 똑같은 데이터 조회를 두 번 했는데 그 사이에 다른 트랜잭션이 값을 수정하거나 삭제해서 결과가 달라지는 현상입니다.

### 3) Phantom Read (팬텀 리드)

한 트랜잭션이 일정 범위의 데이터를 두 번 조회했는데, 그 사이에 다른 트랜잭션이 새로운 데이터를 삽입하여 없던 데이터(유령 데이터, Phantom Data)가 나타나는 현상입니다.

<br>

# 5. 각 격리 수준에서 어떤 문제가 발생하고 방지되는가?

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
|:---|:---:|:---:|:---:|
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 방지 | 발생 | 발생 |
| REPEATABLE READ | 방지 | 방지 | 발생 |
| SERIALIZABLE | 방지 | 방지 | 방지 |

<br>

# 6. 락(Lock)의 종류(공유 락, 배타 락)와 역할은?

### 공유 락 (Shared Lock, S-Lock)

어떤 트랜잭션이 데이터를 읽기만 할 때 사용합니다.

여러 트랜잭션이 동시에 한 데이터에 대해 공유 락을 가질 수 있습니다. 읽기만 하는 트랜잭션은 데이터에 동시에 접근해도 문제가 없기 때문입니다.

이 데이터를 수정하려는 트랜잭션이 있다면, 공유 락이 모두 해제될 때까지 기다려야 합니다. (배타 락을 획득할 수 없습니다.)

### 배타 락 (Exclusive Lock, X-Lock)

데이터를 수정(쓰기)할 때 사용합니다.

배타 락은 오직 한 트랜잭션만 획득할 수 있습니다.

배타 락이 걸린 데이터는 다른 트랜잭션이 읽거나 쓸 수 없습니다. (공유 락, 배타 락 모두 획득할 수 없습니다.)

<br>

# 7. 2PL(Two-Phase Locking) 프로토콜이란?

> 2PL은 모든 트랜잭션이 락을 설정하는 단계와 락을 해제하는 단계로 나누어 수행되어야 한다는 프로토콜입니다.

### 1) 확장 단계 (Growing Phase)

트랜잭션이 자신이 필요한 락들을 획득하기만 하고, 락을 해제하지는 않는 단계입니다.

### 2) 축소 단계 (Shrinking Phase)

트랜잭션이 락을 해제하기 시작하는 단계입니다. 이 단계에서는 새로운 락을 획득할 수는 없습니다.

---
<br>

만약 트랜잭션이 위의 두 단계가 없고 중구난방으로 락을 획득하고 풀게 된다면 다른 트랜잭션이 그 사이에 끼어들어 데이터를 수정할 수 있고, 일관성이 깨질 수 있습니다.

2PL은 락 획득중에 해제를 금지함으로써, 마치 트랜잭션들이 순차적으로 실행되는 것과 같은 직렬 가능성(Serializability)을 보장합니다.

하지만 2PL은 교착 상태를 방지하지는 못합니다. 예를 들어 $T_1$이 A에 락을 걸고, $T_2$가 B에 락을 걸었는데, $T_1$이 B를 기다리고, $T_2$가 A를 기다리면 교착 상태가 발생합니다.
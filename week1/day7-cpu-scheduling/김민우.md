# Day 7: CPU 스케줄링
> 📅 2025.02.19 | 📁 Week 1

---

## 🧠 학습 질문

- [x] CPU 스케줄링이 필요한 이유는?
- [x] FCFS, SJF, RR, Priority 스케줄링의 장단점은?
- [x] 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?
- [x] SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?
- [x] Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?
- [x] 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)
- [x] 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?



## 1. CPU 스케줄링이 필요한 이유

핵심 목적은 CPU 자원을 효율적으로 배분하는 것이다. 하나의 CPU를 여러 프로세스가 공유하므로 OS는 다음을 최대화하려 한다.

- CPU utilization 증가
- Throughput 증가
- Turnaround time 감소
- Waiting time 감소
- Response time 감소
- Fairness 확보

특히 I/O-bound 프로세스와 CPU-bound 프로세스가 섞여 있을 때 스케줄링이 없으면 CPU가 유휴 상태가 되거나 특정 프로세스가 독점하게 된다. 따라서 Ready Queue에서 어떤 프로세스를 실행할지 결정하는 정책이 필요하다.

---

## 2. 주요 스케줄링 알고리즘

### FCFS (First Come First Served)

먼저 도착한 프로세스부터 실행하는 비선점형 알고리즘이다.

**장점**
- 구현이 단순하다.
- 오버헤드가 거의 없다.

**단점**
- 평균 대기시간이 길다.
- Convoy Effect가 발생한다.
- 응답 시간이 느리다.

### SJF (Shortest Job First)

CPU burst가 가장 짧은 프로세스를 먼저 실행하는 비선점형 알고리즘이다. 선점형 버전은 SRTF(Shortest Remaining Time First)이다.

**장점**
- 평균 대기시간이 최소화된다.
- 이론적으로 가장 효율적이다.

**단점**
- CPU burst time을 미리 알기 어렵다.
- 긴 작업의 starvation이 발생할 수 있다.

### RR (Round Robin)

Time Quantum만큼 실행한 후 다음 프로세스로 넘기는 선점형 알고리즘이다.

**장점**
- 응답 시간이 빠르다.
- 공정성이 높다.
- 인터랙티브 시스템에 적합하다.

**단점**
- 문맥 교환(context switch) 오버헤드가 발생한다.
- Time Quantum 설정이 성능에 큰 영향을 미친다.

### Priority Scheduling

우선순위가 높은 프로세스를 먼저 실행하며, 선점형과 비선점형 모두 가능하다.

**장점**
- 중요한 작업을 빠르게 처리할 수 있다.
- 실시간 시스템에 적합하다.

**단점**
- 낮은 우선순위 프로세스의 starvation이 발생한다.

---

## 3. 선점형 vs 비선점형

| 구분 | 선점형 | 비선점형 |
|------|--------|----------|
| CPU 강제 회수 | 가능 | 불가능 |
| 문맥 교환 | 많음 | 적음 |
| 응답성 | 좋음 | 나쁨 |
| 예시 | RR, SRTF, 선점 Priority | FCFS, SJF |

선점형은 인터랙티브 환경에, 비선점형은 배치 처리 환경에 적합하다.

---

## 4. SJF가 평균 대기시간이 가장 짧은 이유

짧은 작업을 먼저 처리하면 뒤에 긴 작업이 대기하는 총 시간이 줄어든다. 두 작업 A, B가 있을 때 A의 burst time이 B보다 작다면 A를 먼저 실행하는 것이 항상 총 대기시간을 최소화한다. 이는 교환 논법(exchange argument)으로 수학적으로 증명 가능하다.

**실무에서 잘 쓰이지 않는 이유**

1. CPU burst time을 실행 전에 알 수 없다.
2. 예측이 틀리면 성능이 급격히 악화된다.
3. 긴 작업의 starvation이 발생한다.

실제 OS는 이를 보완하기 위해 exponential averaging으로 burst time을 근사 예측한다.

---

## 5. Round Robin에서 Time Quantum 설정

Time Quantum이 너무 크면 FCFS처럼 동작하여 응답 시간이 느려진다. 반대로 너무 작으면 context switch가 폭증하여 CPU가 스케줄링에만 시간을 소모하고 throughput이 감소한다.

이상적인 조건은 Time Quantum이 대부분의 CPU burst보다 약간 큰 값이며, 실제 OS는 보통 10~100ms를 사용한다.

---

## 6. 기아 상태 (Starvation)

낮은 우선순위 프로세스가 무한정 CPU를 할당받지 못하는 상태를 말한다. SJF와 Priority Scheduling에서 주로 발생한다.

**해결 방법: Aging**

시간이 지날수록 프로세스의 우선순위를 점점 높여주는 방식이다. 대기 시간이 길어질수록 우선순위가 올라가므로 결국 실행이 보장된다.

---

## 7. Convoy Effect (컨보이 효과)

하나의 긴 CPU-bound 작업이 뒤에 대기하는 많은 I/O-bound 작업을 오랫동안 기다리게 만드는 현상이다. FCFS에서 발생하며, 결과적으로 CPU utilization 저하, I/O 장치 유휴 상태 발생, 전체 시스템 성능 저하로 이어진다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

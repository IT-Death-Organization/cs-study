# Day 7: CPU 스케줄링
> 📅 2025.02.19 | 📁 Week 1

---

## 🧠 학습 질문

- [x] CPU 스케줄링이 필요한 이유는?
- [x] FCFS, SJF, RR, Priority 스케줄링의 장단점은?
- [x] 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?
- [x] SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?
- [x] Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?
- [x] 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)
- [x] 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?

---

## Q1. CPU 스케줄링이 필요한 이유는?

[답변]
* CPU 이용률 향상
    - 준비 큐에 여러 프로세스/스레드가 있을 때 CPU가 놀지 않도록 다음 실행 대상 선택
* 대기 시간 및 반환 시간 감소
    - 프로세스가 오래 대기하거나 전체 완료 시간이 길어지는 일 줄임
* 응답 시간 개선: 사용자 경험 향상
* 공정성 확보: 특정 프로세스가 계속 실행되거나 계속 밀리는 상황 방지
* 우선순위 반영: 중요한 작업에 더 높은 우선순위 부여

[보완]
스케줄링이 발생하는 대표 시점
1. Running -> Waiting 전환 (I/O 요청)
2. Running -> Ready 전환 (선점, 타임 슬라이스 종료)
3. Waiting -> Ready 전환 (I/O 완료)
4. Terminated

---

## Q2. FCFS, SJF, RR, Priority 스케줄링의 장단점은?

[답변]
* FCFS: First-Come, First-Served
    - 장점
        - 구현이 매우 단순, 오버헤드 낮음
        - '먼저 온 순서대로': 직관적, 공정
    - 단점
        - '컨보이 효과' 발생하기 쉬움: 긴 작업이 앞에 오면 뒤에 오는 짧은 작업들도 밀림
* SJF: Shortest Job First
    - 장점
        - 이론적으로 평균 대기 최소에 유리
        - 짧은 작업의 응답성이 좋음
    - 단점
        - 다음 CPU 버스트 길이를 미리 알기 어려움
        - 긴 작업이 계속 밀리는 starvation 발생 가능
* RR: Round Robin
    - 장점
        - 모든 프로세스에 '시간 할당량' 단위로 공정하게 분배
        - 기아 상태가 상대적으로 잘 발생하지 않음
    - 단점
        - Context Switch 오버헤드 증가 가능
        - Time Quantum 설정이 성능에 매우 민감
* Priority Scheduling: 우선순위 스케줄링
    - 장점
        - 중요한 작업에 우선 실행 보장
        - 서비스 품질 반영에 유리
    - 단점
        - 낮은 우선순위 작업의 Starvation
        - Priority Inversion 문제 발생 가능

[보완]
* CPU Burst: 프로세스가 CPU를 연속으로 사용하는 구간. 해당 구간 이후 I/O로 넘어갈 수 있음
* Priority Inversion
    - 높은 우선순위 작업(H)이 실행되어야 하는데, 낮은 우선순위 작업(L)이 잡고 있는 자원(락/뮤텍스 등) 때문에 H가 대기
    - 그 사이에 중간 우선순위 작업(M) 들이 CPU를 계속 점유
    => H가 L보다도 더 늦게 진행되는 것처럼 보임
	- 대표 상황(동작 흐름)
	    1. L(낮은 우선순위)이 어떤 락을 획득
	    2. H(높은 우선순위)가 그 락이 필요해져서 대기(Block)
    	3. M(중간 우선순위)들이 준비 큐에서 계속 실행됩니다(선점형 우선순위 스케줄링이면 특히)
	    4. L은 CPU를 못 받아 락을 오래 쥐고 있고, H는 락을 기다리느라 더 오래 멈춤
    	5. 결과적으로 H가 가장 중요한데도 가장 늦게 처리되는 상황이 됨
    - 해결 방법
        - Priority Inheritance(우선순위 상속): L이 락을 쥐고 있는 동안 L의 우선순위를 H 수준으로 임시 상승 -> L이 빨리 실행되어 락을 풀게 함
	    - Priority Ceiling(우선순위 천장): 특정 자원을 잡으면 해당 자원의 “천장 우선순위”까지 우선순위를 올리도록 제한하여 역전을 예방

---

## Q3. 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?

[답변]
* 비선점형(Non-preemptive)
    - CPU를 얻은 프로세스가 자발적으로 반납
    - 문맥 교환이 적지만, 응답 시간이 나빠질 수 있음
    - ex. FCFS, 비선점형 SJF
* 선점형(Preemptive)
    - OS가 실행 중인 프로세스의 CPU 강제로 뺏기 가능
    - 응답성이 좋고, 요구사항 반영이 용이하나 문맥 교화 오버헤드가 증가
    - ex. RR, SRTF(Shortest Remaining Time First, 선점형 SJF)

---

## Q4. SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?

[답변]
* 평균 대기 시간이 짧은 이유
    - 짧은 작업을 먼저 처리하면, 뒤에 남는 작업들의 기다리는 시간의 누적이 줄어듦
* 실무에서 잘 사용하지 않는 이유
    - CPU 버스트 시간 예측 어려움
    - 기아 발생 가능
    - 요구사항 반영 어려움

[보완]
실무에서는 SJF 자체보다는
1. 추정 기반의 변형(예: CPU 사용 패턴 기반 우선순위 조정)
2. 다단계 피드백 큐(MLFQ)
같은 방식으로 “짧은 작업 우대 효과”를 간접적으로 얻는 경우가 많음

---

## Q5. Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?

[답변]
* Time Quantum이 너무 큰 경우
    - 한 프로세스가 CPU를 오래 점유해 FCFS처럼 동작
    - 작업의 응답 시간이 악화
* Time Quantum이 너무 작은 경우
    - 프로세스가 자주 교체되어 문맥 교환 오버헤드가 급증
    - 실제 유효 작업보다 “전환 비용”이 커져 CPU 효율/처리량이 감소
    - 실행이 끊기며 캐시 재적중률 저하

---

## Q6. 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)

[답변]
* 기아 상태
    - 어떤 프로세스가 계속해서 CPU 할당을 받지 못하고 무기한 대기하는 현상
    - 주로 Priority, SJF 계열에서 발생
* 해결 방법: Aging
    - 대기 시간이 길어질수록 우선순위를 점진적으로 올려주는 기법

[보완]
* 동작 원리
	1. 각 프로세스의 대기 시간 추적
	2. 일정 시간(또는 틱)마다 대기 중인 프로세스의 우선순위를 조금씩 올림
	3. 충분히 오래 기다린 프로세스는 결국 높은 우선순위를 갖게 되어 CPU를 할당받음
	4. 결과적으로 무한 대기 방지

---

## Q7. 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?

[답변]
* 정의
    - CPU를 오래 쓰는 큰 작업(긴 CPU 버스트)이 큐의 앞에 있으면 뒤에 있는 짧은 작업들(I/O 중심, 짧은 CPU 버스트)이 오래 기다림
    => CPU와 I/O 장치 모두의 활용률이 떨어지고, 시스템 전체 성능 악화
* 주요 발생 스케줄링
    - 대표적으로 FCFS에서 자주 발생
    - 비선점형 방식: 긴 작업이 자발적으로 CPU를 놓을 때까지 대기열이 정체

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

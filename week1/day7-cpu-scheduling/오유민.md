# Day 7: CPU 스케줄링

> 📅 2025.02.19 | 📁 Week 1

---

## 🧠 학습 질문

- [x] CPU 스케줄링이 필요한 이유는?
- [x] FCFS, SJF, RR, Priority 스케줄링의 장단점은?
- [x] 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?
- [x] SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?
- [x] Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?
- [x] 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)
- [x] 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?

---

### 📌 [Q1] CPU 스케줄링이 필요한 이유는?

CPU는 한정된 자원이지만, 여러 프로세스와 스레드가 동시에 실행을 요구한다. 때문에 CPU 사용률을 높이고 응답성과 공정성을 보장하기 위해 CPU 스케쥴링이 필요하다. (어떤 작업에게 CPU를 먼저 할당할지 결정)

**1) 멀티 프로그래밍 및 효율성 증대**

- CPU는 연산 속도 매우 빠르지만, I/O 작업은 상대적으로 매우 느림
- **I/O 작업은 CPU를 사용하지 않음** (ex. 파일 읽기, 네트워크 통신, 사용자 입력 대기)
- I/O 작업을 수행하는 동안 CPU가 가만히 기다리기만 한다면 막대한 자원 낭비 -> **스케줄러는 I/O 대기 중인 프로세스를 제외하고, 실행 가능한 프로세스에게 CPU를 넘겨줌**

**2) 응답성 보장, 응답 시간 단축**

- 특정 작업이 계속 CPU를 독점한다면 사용자가 마우스를 클릭하는 등 인터랙션이 발생했을 때 화면이 멈춘 것처럼 보임 -> **OS는 일정 시간동안만 CPU를 쓰게 하고 (time slice), 다른 프로세스에게도 기회를 줌**
- 이를 통해 사용자 인터페이스의 반응성을 보장 (스케줄링을 통해 여러 프로세스가 번갈아 가며 CPU를 점유하게 함으로써, 사용자가 마치 여러 프로그램이 동시에 실행되는 것처럼 느끼게 함)

**3) 공정성 & 우선순위를 위해서**

- 모든 작업에는 우선순위가 있음 (동일하게 중요하진 않음)
- CPU 스케줄링을 통해 우선순위 기반 실행 / 공정한 CPU 분배 / 기아(starvation) 방지 가능

### 📌 [Q2] FCFS, SJF, RR, Priority 스케줄링의 장단점은?

**FCFS(First-Come, First-Served)**

- 가장 먼저 도착한 프로세스를 먼저 처리하는 비선점(non-preemptive) 방식
- 큐에 들어온 순서대로 처리
- 장점
  - 먼저 온 순서대로 처리하므로 기아 현상 발생 x
  - 구현이 쉽고 직관적
- 단점
  - 컨보이 효과(convoy effect) 발생: 실행 시간이 긴 프로세스가 앞에 있으면, 뒤에 있는 짧은 프로세스들은 앞의 작업이 끝날 때까지 무한정 기다려야 하므로 효율성 떨어짐
  - 평균 대기 시간 길어질 수 있음
  - 응답성 나쁨 (대화형 시스템에 부적합)

**SJF(Shorted Job First)**

- 실행 시간이 가장 짧은 프로세스들에게 CPU를 먼저 할당하는 방식
- 장점
  - 최적의 평균 대기 시간: 모든 알고리즘 중 평균 대기 시간 가장 짧음
  - 처리량이 높음
- 단점
  - 기아 현상(starvation): 실행 시간이 긴 프로세스는 짧은 프로세스가 계속 들어올 경우 영원히 CPU를 할당받지 못할 수도 있음
  - 실제 실행 시간을 미리 알기 어려움

**RR(Round Robin)**

- 각 프로세스에 동일산 시간 할당량(time quantum)을 주고, 시간이 지나면 다음 프로세스로 넘기는 선점(preemptive) 방식
- 장점
  - 응답 시간 단축: 모든 프로세스가 조금씩 CPU를 쓰므로 사용자 체감 응답 속도가 빠름 (대화형 시스템에 적합)
  - 공정성: 특정 프로세스가 CPU를 독점하는 것을 방지
- 단점
  - 오버헤드 발생: 타임 퀀텀이 너무 짧으면 context switching이 빈번해져 시스템 성능이 저하될 수 있음
  - 성능의 가변성: 타임 퀀텀이 너무 길면 FCFS와 다를 바 없게 됨
  - 평균 대기 시간 SJF보다 큼

**Priority Scheduling**

- 각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당
- 장점
  - 유연성: 시스템 목적에 따라 중요도가 높은 작업 먼저 처리 가능
  - 실시간 시스템에 적합
- 단점
  - 기아 현상: 낮은 우선순위의 프로세스는 계속 밀려남
- 해결: 기다린 시간에 비례해 우선순위를 높여주는 에이징(Aging) 기법을 통해 방지 가능

### 📌 [Q3] 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?

**선점형(Preemptive) 스케줄링**
: OS가 실행 중인 프로세스로부터 CPU를 강제로 회수/중단해 다른 프로세스에 할당하는 방식

- 특징
  - 응답성: 높은 우선순위의 프로세스가 오면 즉시 처리할 수 있어 대화형 or 실시간 시스템에 적합
  - 오버헤드: 프로세스 교체가 잦아 context switching 비용 발생
  - 데이터 정합성: 공유 데이터를 사용 중일 때 중단되면 데이터가 꼬일 수 있어 동기화(sync)가 중요함
- 예시
  - RR(할당 시간 끝나면 강제로 다음 프로세스로), SRTF(Shortest Remaining Time First, 남은 실행 시간 더 짧은 프로세스 나타나면 CPU 뺏어옴), Multilevel Queue(우선순위가 높은 큐에 작업이 들어오면 현재 작업을 중단)

**비선점형(Non-Preemptive) 스케줄링**
: 한 프로세스가 CPU를 점유하면, 그 프로세스가 스스로 종료되거나 I/O 요청 등으로 대기 상태에 들어갈 때까지 CPU를 독점하는 방식

- 특징
  - 효율성: context switching이 적게 일어나 오버헤드 적음
  - 예측 가능성: 프로세스 실행 순서가 안정적임
  - 불공정성: 실행 시간이 긴 프로세스가 CPU를 잡으면 짧은 프로세스들이 하염없이 기다리는 convoy effect 발생 가능
- 예시
  - FCFS, SJF

### 📌 [Q4] SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?

실행 시간이 가장 짧은 프로세스를 먼저 처리하면, 기다리는 프로세스들의 **공통 대기 시간**이 줄어들기 때문이다.
실무에서 사용하지 않는 이유는 **실행 시간 예측 불가 & 기아 상태** 때문이다.
CPU가 해당 프로세스를 처리하는 데 정확히 몇 초가 걸릴지 미리 알 수 있는 방법이 없을 뿐더러, 짧은 작업이 계속 들어오면 긴 작업은 영원히 실행되지 못할 수 있다.

ex) 100분짜리 A, 1분짜리 B

- A(100) → B(1): B는 100분을 기다려야 합니다. (평균 대기 50분)
- B(1) → A(100): A는 1분만 기다리면 됩니다. (평균 대기 0.5분)

### 📌 [Q5] Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?

**Time Quantum이 너무 큰 경우**

- 프로세스가 자신의 작업을 다 끝낼 만큼 time slice가 넉넉해지면, 사실상 먼저 온 순서대로 처리하는 FCFS와 동일하게 느껴짐
- 응답 시간이 길어져 사용자가 시스템이 느리다고 느낌

**Time Quantum이 너무 작은 경우**

- 프로세스가 아주 조금 실행되고 바로 다음 프로세스로 교체됨
- 이때 발생하는 context switching 오버헤드가 커져 효율 하락

### 📌 [Q6] 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)

기아 상태는 특정 프로세스(주로 우선순위가 낮거나 실행 시간이 긴 작업)가 지원을 할당받지 못하고 무한정 대기하는 현상이다.

이는 에이징(Aging)으로 해결할 수 있다. **에이징은 시스템에서 대기하는 시간이 길어질수록 해당 프로세스의 우선순위를 점진적으로 높여주는 기법**이다. **아무리 우선순위가 낮아도 오래 기다리면 결국 최우선순위가 되어 실행되도록 보장한다.**

### 📌 [Q7] 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?

**컨보이 효과(Convoy Effect)**란 CPU 사용 시간이 매우 긴 하나의 프로세스가 CPU를 점유하고 있을 때, 그 뒤에 줄 서 있는 짧은 프로세스들이 모두 실행되지 못하고 긴 시간 동안 대기하게 되는 현상이다.

이는 주로 **FCFS 스케줄링**에서 발생한다. 비선점형 방식이기 때문에 앞의 긴 작업이 끝날 때까지 뒤의 작업들이 CPU를 뺏어올 수 없다.

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

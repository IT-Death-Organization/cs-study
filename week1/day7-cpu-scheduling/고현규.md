# Day 7: CPU 스케줄링
> 📅 2025.02.19 | 📁 Week 1

---

## 🧠 학습 질문

- [ ] CPU 스케줄링이 필요한 이유는?
- [ ] FCFS, SJF, RR, Priority 스케줄링의 장단점은?
- [ ] 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?
- [ ] SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?
- [ ] Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?
- [ ] 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)
- [ ] 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?

<br>

# 1. CPU 스케줄링이 필요한 이유는?

CPU는 컴퓨터에서 가장 중요한, 가장 빠른 핵심 자원입니다. 하지만 우리가 사용하는 프로그램(프로세스)들은 CPU에서만 작업하지 않고 실행 도중 파일 읽기/쓰기, 네트워크 통신 같은 I/O 작업을 자주 수행합니다. 

### CPU 이용률 상승

만약 한 프로세스가 CPU 자원을 계속 점유한 채로 느리고 무거운 I/O 작업을 수행한다면 CPU 자원의 낭비는 매우 심각해질 것입니다. 대신 I/O 작업을 수행중인 프로세스를 잠시 양보시키고 다른 프로세스를 CPU에 할당한다면 CPU 자원의 효율성이 향상됩니다.

### Multi-programming

우리가 쓰는 컴퓨터는 한번에 하나의 일만 하지 않습니다. 지금 이 cs 내용을 정리하면서 브라우저로 서칭도 해야하고, AI도 써야하죠. 실제로 CPU(코어)는 한 번에 하나의 일만 할 수 있지만, 스케줄러가 여러 프로세스를 아주 짧은 시간 단위로 번갈아 가며 실행해 주기 때문에 우리는 동시에 여러 일이 일어나는 것처럼 느끼게 됩니다.

### 처리량과 응답 시간의 균형

시스템 전처의 작업량이 늘어나더라도 사용자가 답답함을 느끼지 않도록 반응 속도를 빠르게 유지하기 위해 프로세스들의 작업 순서를 공정하게 정하는 과정은 필수적입니다.

<br>

# 2. FCFS, SJF, RR, Priority 스케줄링의 장단점은?

| 알고리즘 | 핵심 아이디어 | 장점 | 단점 |
| :--- | :--- | :--- | :--- |
| **FCFS** | 먼저 온 순서대로 | 구현이 단순하고 공정함 | 컨보이 효과 (대기 시간 증가) |
| **SJF** | 짧은 작업 먼저 | 평균 대기 시간 최소화 | 기아 상태, 실행 시간 예측 불가 |
| **RR** | 정해진 시간만큼 번갈아 | 응답 시간이 빠름 | 할당량(Time Quantum)에 민감함 |
| **Priority** | 중요도 순서대로 | 긴급한 작업 우선 처리 | 낮은 순위 프로세스의 기아 상태 |
---
<br>

1) FCFS (First-Come, First-Served)

가장 단순한 방식으로, 준비 큐에 도착한 순서대로 CPU를 할당합니다. 비선점형이며, 앞선 작업이 끝날 때까지 뒤의 작업들이 무작정 기다려야 하므로 효율성이 떨어질 수 있습니다.

2) SJF (Shortest Job First)

CPU 버스트(Burst) 시간이 가장 짧은 프로세스에게 먼저 기회를 줍니다. 대기 시간을 줄이는 데는 최적(Optimal)이지만, 실행 시간이 긴 프로세스가 계속 밀려나는 현상이 발생할 수 있습니다.

3) Round Robin (RR)

현대 시분할 시스템의 기초입니다. 각 프로세스에 동일한 CPU 할당 시간(Time Quantum)을 주고, 시간이 다 되면 다음 프로세스로 넘깁니다. 모든 프로세스가 공평하게 CPU를 점유할 수 있어서 대화형 시스템에 적합합니다.

4) Priority Scheduling

각 프로세스에 우선순위를 부여하고 가장 높은 프로세스에 CPU를 줍니다. 하지만 시스템이 바쁘면 우선순위가 낮은 프로세스는 CPU를 한 번도 잡지 못하는 상황이 벌어질 수 있습니다.

<br>

# 3. 선점형과 비선점형 스케줄링의 차이는? 각각의 예시는?

### 선점형 스케줄링 (Preemptive)

>운영체제가 실행 중인 프로세스로부터 CPU를 강제로 뺏어올 수 있는 방식. (Round Robin, 선점형 SJF(SRTF), 다단계 큐 스케줄링 등)

현재 실행중인 프로세스보다 우선순위가 더 높은 프로세스가 나타나거나, 할당된 시간이 종료되면 현재 프로세스를 중단시키고 다른 프로세스에 CPU를 할당합니다.

빠른 응답시간을 보장하는 특징이 있고, 특정 프로세스가 CPU를 독점하는 것을 방지할 수 있습니다. 현대의 OS의 주류입니다.

하지만 Context Switching이 자주 발생하여 오버헤드가 생길 수 있습니다.

### 비선점형 스케줄링 (Non-preemptive)

>한번 CPU를 할당받으면 프로세스가 스스로 종료하거나 I/O 작업을 위해 CPU를 반환할 때까지 주도권을 계속 가지는 방식. (FCFS, 비선점형 SJF, HRN 등)

다른 프로세스가 중간에 끼어들 수 없습니다. 따라서 Context Switching이 거의 발생하지 않고, 스케줄링 구조가 단순합니다.

하지만 실행시간이 긴 프로세스가 CPU를 점유하면 시스템 전체의 효율이 떨어지는 "컨보이 효과"가 발생할 수 있습니다.

<br>

# 4. SJF가 평균 대기 시간이 가장 짧은 이유는? 왜 실무에서 사용 안 하는가?

SJF는 평균 대기 시간이 가장 짧고, 이것은 수학적으로 증명되어 있습니다. 짧은 작업들을 먼저 끝내버리면, 그 뒤에 기다리는 수많은 프로세스의 대기 시간을 누적해서 줄여주는 효과가 있기 때문입니다.

예를 들어 편의점 계산 줄을 선 사람들 중 물건을 100개 가지고 온 사람을 맨 뒤로 보내면 전체 사람들의 평균 대기 시간이 줄어듭니다.

하지만 SJF는 실행 시간을 예측할 수 없는 가장 큰 문제가 있습니다. 편의점 손님들이 물건을 몇개 가지고 있는지 모르는 것입니다. 즉, 이론상 완벽하지만 실제 사용은 불가능합니다.

만약 가능하다고 해도 실행 시간이 짧은 프로세스가 계속해서 들어온다면, 실행시간이 긴 프로세스는 영원히 CPU를 할당받지 못할 수 있습니다.

따라서 SJF는 실무에서 거의 사용하지 않습니다.

<br>

# 5. Round Robin에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 생기는가?

Time Quantum이 너무 크다면, 프로세스가 작업을 다 끝내고 나갈 때까지 CPU를 거의 독점하게 됩니다. 또한 다른 프로세스들이 자기 차례를 기다리는 시간이 길어져, 사용자가 답답함을 느끼게 됩니다.

Time Quantum이 너무 작다면, 프로세스가 CPU를 거의 점유하지 못하고 Context Switching이 자주 발생하게 됩니다. 이는 CPU가 핵심적인 계산을 하는 시간보다 작업 상태를 불러오는 문맥 교환 자체에 시간을 더 많이 쓰게 되고, 효율성을 크게 떨어뜨립니다.

<br>

# 6. 기아 상태(Starvation)는 무엇이며 어떻게 해결하는가? (Aging)

기아 상태(Starvation)란 특정 프로세스의 우선순위가 너무 낮아서, 자기보다 우선순위가 높은 프로세스들이 계속 들어오는 바람에 영원히 CPU를 할당받지 못하고 대기하는 상태를 말합니다.

### 발생 원인
SJF(Shortest Job First)나 우선순위(Priority) 스케줄링처럼 '효율'이나 '중요도'를 따지는 알고리즘에서 주로 발생합니다. 시스템에 짧은 작업이나 높은 순위의 작업이 끊임없이 유입되면, 길거나 순위가 낮은 작업은 준비 큐에서 무한정 기다리게 됩니다.

### 해결 방법: 에이징 (Aging)
이 문제를 해결하는 가장 대표적인 방법이 **에이징(Aging)**입니다. 말 그대로 프로세스가 기다린 '나이(시간)'를 고려하는 것입니다.
* 원리: 준비 큐에서 기다리는 시간이 길어질수록 해당 프로세스의 우선순위를 조금씩 높여주는 방식입니다.
* 효과: 아무리 우선순위가 낮았던 프로세스라도, 시간이 충분히 지나면 결국 우선순위가 가장 높아지게 되어 반드시 CPU를 할당받을 수 있게 보장합니다.

<br>

# 7. 컨보이 효과(Convoy Effect)란 무엇이며 어떤 스케줄링에서 발생하는가?

컨보이 효과(Convoy Effect)란 수행 시간이 아주 긴 프로세스 하나 때문에, 그 뒤에 있는 짧은 프로세스들이 오랫동안 실행되지 못하고 줄줄이 대기하는 현상을 말합니다.

### 발생하는 상황
주로 FCFS(First-Come, First-Served) 스케줄링에서 발생합니다. 비선점형 방식이기 때문에 앞에 있는 거대한 작업이 끝나기 전까지는 뒤의 짧은 작업들이 CPU를 선점할 수 없기 때문입니다.

### 문제점
* CPU 및 장치 이용률 저하
    * 긴 작업이 CPU를 쓰는 동안, 짧은 작업들은 I/O 장치를 사용하고 싶어도 CPU를 못 잡아서 대기하게 됩니다. 결과적으로 CPU는 바쁜데 I/O 장치들은 노는 불균형이 발생하여 전체 시스템 효율이 떨어집니다.
* 평균 대기 시간의 급증
    * 짧은 작업들이 금방 끝날 수 있음에도 불구하고 앞에 큰 작업 때문에 한참을 기다려야 하므로, 전체 프로세스의 평균 대기 시간이 매우 길어집니다.
# 프로세스와 스레드

# Day 2: 프로세스와 스레드

> 📅 2025.02.14 | 📁 Week 1
> 

---

## 🧠 학습 질문

- [x]  프로세스와 프로그램의 차이는?
- [x]  프로세스와 스레드의 차이를 메모리 구조 관점에서 설명하면?
- [x]  멀티 프로세스와 멀티 스레드의 장단점은? 어떤 경우에 무엇을 선택하는가?
- [x]  스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?
- [x]  프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)
- [x]  Context Switching이 프로세스보다 스레드에서 더 빠른 이유는?

## 프로세스와 프로그램의 차이

|  | 프로세스 | 프로그램 |
| --- | --- | --- |
| 정의  | 디스크 상 실행 가능 파일  | 프로그램이 메모리에 로드되어 실행 중인 상태  |
| 메모리 할당  | 로드되지 않은 상태. 디스크에 저장됨 | 로드되어 실행중. (코드, 데이터, 스택, 힙 영역 등이 메모리에 할당) |
| 상태  | 정적  | 동적  |
- 프로그램
    - 실행 파일, 소스코드, 바이너리코드 등과 같은 속성 가짐
- 프로세스
    - 프로세스 ID, 상태, 메모리 주소, 스택, 힙 등의 속성 가짐
    - 시스템에서 실행중인 프로그램의 고유 인스턴스

![image.png](image.png)

## 프로세스와 스레드의 차이(메모리 구조 관점)

|  | 프로세스 | 스레드 |
| --- | --- | --- |
| 자원공유 | X (독립적) | 코드, 데이터, 힙 공유 |
| 통신비용  | 높음 (IPC 필) | 낮음 (공유 메모리 접근) |
| Context Switching | 무거움(느림) | 가벼움(빠름) |
| 안정성 | 높음 | 낮음(하나가 죽으면 프로세스 전체에 영향)  |
- 스레드는 프로세스 안에서 CPU가 실행되는 최소 단위
    - 같은 프로세스 내 스레드들은 코드 , 데이터, 힙 영역을 서로 공유
    - Stack, Program Counter 레지스터는 독립 영역임. 공유하지 않음
        - stack → 독립적인 함수 호출, 제어 흐름 유지를 위해
        - PC → 스레드는 CPU를 번갈아가며 사용

## 멀티 프로세스와 멀티 스레드의 장단점

- 멀티 프로세스
    - 장점
        - 안정성: 독립된 메모리 구조 → 한 프로세스가 죽어도 다른 프로세스에 영향을 X
        - 보안: 프로세스 간 자원 침범이 불가능하여 데이터 보호에 유리
    - 단점
        - 오버헤드: 컨텍스트 스위칭(Context Switching) 발생 시 캐시 메모리 초기화 등 무거운 작업이 필요해 비용이 크게 발생
        - 통신 복잡도: 프로세스 간 데이터를 주고받으려면 IPC(Inter-Process Communication)라는 별도의 복잡한 매커니즘이 필요
- 멀티 스레드
    - 장점
        - 자원 효율성: 스레드 간 메모리(Code, Data, Heap)를 공유하므로 메모리 소모가 적고 생성/종료가 빠름
        - 통신 속도: 공유 메모리를 통해 데이터를 직접 주고받으므로 통신 비용 낮음
        - 빠른 컨텍스트 스위칭: 스레드 교체 시 공유 영역을 그대로 두기 때문에 프로세스 교체보다 훨씬 빠름
    - 단점
        - 동기화 문제: 여러 스레드가 동시에 공유 자원에 접근하면 데이터가 꼬이는 **데드락(Deadlock)**이나 **경쟁 상태(Race Condition)**가 발생 가능
        - 안정성 문제: 하나의 스레드에서 치명적인 오류가 발생하면 프로세스 전체가 종료될 수 있음
    
- 어떤 경우에 무엇을 선택?
    - 안정성이 최우선인 경우 (예:  크롬 브라우저 탭) ⇒ 멀티프로세스 (한 탭이 에러로 꺼져도 다른 탭/ 브라우저 전체가 죽으면 안 됨)
    - CPU 작업량 매우 많은 경우 ⇒ 멀티프로세스 (여러 CPU 코어를 독립적으로 활용해 병렬 처리 극대화, 동기화 오버헤드 감소)
    - 데이터 공유 잦은 경우 ⇒ 멀티스레드(실시간으로 대량의 데이터 주고받아야 함, 빠른 응답 속도 주용하기 때문)
    - 자원이 제한적인 경우 ⇒ 멀티스레드(스레드는 프로세스보다 메모리 점유율이 낮아 효율적)

## 스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?

결론: 스레드는 독립적인 실행 흐름을 유지해야 하기에 스택을 독립적으로 할당받는다. 반면, 프로세스 자원을 효율적으로 사용/ 스레드 간 데이터를 쉽고 빠르게 주고받기 위해, 힙과 데이터 영역은 공유한다. 

### 만약 스택들 공유한다면

→ 한 스레드가 함수 실행 중, 다른 스레드가 새로운 함수를 호출한다면 ⇒ 이전 스레드의 리턴 주소나 지역 변수가 덮어씌워져 실행 흐름이 꼬이고 프로그램이 붕괴됨 

스레드는 한 프로세스 내 별도의 실행단위이므로, 각 스레드가 서로 다른 함수를 호출하거나 같은 함수여도 실행 시점이 다를 수 있음 

### 힙 공유 이유

- 스레드는 서로 협력하여 하나의 작업을 완수해야 하는 경우가 많음. 이때 힙을 공유하면, 복잡한 IPC 없이 메모리 주소만으로 데이터 즉시 공유 가능 → 속도가 아주 빠름
- 스레드들이 각자 힙을 가진다면, 메모리 낭비가 매우 심해짐. 동적으로 생성되는 대용량 데이터를 공유 영역에 두어 메모리 절약

## 프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)

프로세스: 서로의 메모리에 접근 불가 → OS가 제공하는 특별한 통로 “IPC”  를 사용해야 함 

### IPC란?

- 프로세스 간 통신(Inter-Process Communication).  협력 프로세스들이 데이터를 공유하고, 작업을 조율하기 위해 사용하는 다양한 메커니즘들을 포함.
- OS 핵심 기능 중 하나로, 효율적인 시스템 운영/ 자원 관리를 가능하게 한다.
- 주요 통신 방법은 Pipe, message queue, shared memory, socket 등이 있다.

- Pipe
    - 단방향 통로 (한쪽에서 쓰고 다른 쪽에서 읽음)
    - 부모-자식 프로세스처럼, 연관된 프로세스 간 통신에 주로 사용됨 (익명 파이프)
    - 매우 단순하고, 고전적인 방식
    - 양방향 통신을 하려면 파이프 2개 필요함(단방향이기 때문)
    
    - Named Pipe
        - 기본적으로는 단방향이지만, OS 설정이나 구현에 따라 양방향 통신 가능
            - 지원을 하는거지, 동시에 양쪽으로 보내지는 못함 (전이중 통신 방식)
            - 동시에 양방향 통신을 하려면 두개의 파이프 사용
        - 아무런 연관 관계가 없는 독립적인 프로세스들 간에도 통신이 가능
        - 원리: 파일 시스템에 실제 이름이 있는 파일(FIFO)을 생성해 이것을 통로로 사용한다.
            - e.g. /tmp/my_pipe 라는 파일을 만들면, 프로세스 A와 B는 이 파일 이름만 알면 서로 데이터 주고받을 수 있다.
- Message Queue
    - 데이터를 메시지 단위로 관리
    - 메시지마다 타입을 붙일 수 있음 → 여러 프로세스가 골라 읽기 좋음
    - 비동기적
    - 여러 프로세스가 동시에 데이터 주고받을 때 유리
    - Queue에 메시지 넣고 빼는 과정에서 오버헤드 위험 있음
- Shared Memory
    - 프로세스들이 공통으로 사용할 수 있는 메모리 영역을 할당받아 직접 읽고 쓰는 방식
    - OS 개입 없이 메모리 직접 접근
    - 복사 과정 없음 → IPC 방법 중 속도가 가장 빠름
    - 여러 프로세스가 동시에 쓰면 데이터가 꼬일 수 있으므로, Semaphore 같은 동기화 기술이 필수
- Socket
    - 네트워크 통신 기술을 프로세스 간 통신에도 적용한 방식
    - 로컬 컴퓨터 내 프로세스뿐만 아니라, **네트워크로 연결된 다른 컴퓨터**의 프로세스와도 통신할 수 있음
    - 범용성이 매우 높고 표준화되어 있음
    - 데이터 패킷을 캡슐화하는 과정 등으로 인해, 속도는 다른 방식보다 상대적으로 느림

## Context Switching이 프로세스보다 스레드에서 더 빠른 이유

### 가상 메모리 주소 체계 & TLB

프로세스는 독립적인 주소 공간을 가지지만, 스레드는 동일 프로세스 내 ‘메모리 주소 공간’을 공유함 

- 프로세스 스위칭
    - 완전 새 주소 공간으로 전환
    - CPU는 기존 프로세스 가상 주소를 물리주소로 변환 → 저장하던 TLB (* Translation Lookaside Buffer) 라는 캐시를 모두 Flush해야 함 (시간이 오래 걸림)
- 스레드 스위칭
    - 같은 프로세스 내 스레드끼리는 주소 공간이 같음 → TLB 비울 필요 없음
    - CPU는 메모리 지도를 바꿀 필요 없이 실행 흐름만 바꾸면 됨 → 훨씬 빠름

### 저장 및 복원하는 정보의 양

- 프로세스 스위칭
    - PCB에 담긴 방대한 양의 정보를 저장 및 복구해야 함 (e.g. 메모리 정보, 파일 디스크립터, 상태)
- 스레드 스위칭
    - TCB에는 스레드 고유의 정보만 저장하면 됨. 처리해야할 데이터 양이 훨씬 적음

### 캐시 메모리 효율성

- **프로세스 스위칭**
    - 새로운 프로세스가 실행됨 → CPU 캐시(L1, L2, L3)에 들어있는 기존 데이터들은 무용지물 → 새로운 데이터를 가져오는 과정에서 캐시 미스(Cache Miss)가 빈번하게 발생하여 초기 실행 속도가 느림
- **스레드 스위칭:** 스레드들은 데이터(Data)와 힙(Heap) 영역을 공유함 →  따라서 이전 스레드가 사용하던 데이터가 캐시에 남아 있을 확률이 높고, 이를 그대로 활용할 수 있어 성능상 유리

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
[https://velog.io/@moonblue/프로그램program-과-프로세스process](https://velog.io/@moonblue/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8program-%EA%B3%BC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process)

[https://velog.io/@raejoonee/프로세스와-스레드의-차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
[https://wikidocs.net/231840](https://wikidocs.net/231840)

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->
# Day 2: 프로세스와 스레드

> 📅 2025.02.14 | 📁 Week 1

---

## 🧠 학습 질문

-   [x] 프로세스와 프로그램의 차이는?
-   [x] 프로세스와 스레드의 차이를 메모리 구조 관점에서 설명하면?
-   [x] 멀티 프로세스와 멀티 스레드의 장단점은? 어떤 경우에 무엇을 선택하는가?
-   [x] 스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?
-   [x] 프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)
-   [x] Context Switching이 프로세스보다 스레드에서 더 빠른 이유는?

## 프로세스와 프로그램의 차이는?

프로그램:

-   디스크에 저장된 실행 파일
-   정적인 개념
-   예: `a.out`, `chrome.exe`

코드 + 데이터가 파일 형태로 존재하는 것

프로세스:

-   실행 중인 프로그램
-   동적인 개념
-   운영체제가 자원을 할당한 실행 단위

os는 프로그램을 실행하면

```bash
┌──────────────────────┐
│        Code          │
├──────────────────────┤
│        Data          │
├──────────────────────┤
│        Heap   ↑      │
│               │      │
│               ↓      │
│        Stack         │
└──────────────────────┘

+ 별도 영역: PCB (Kernel Space)

```

을 구성해 메모리에 적재한다.

<details>
<summary><b>자바 관점에서</b></summary>
<br>
    
자바 프로그램이 실행되면 실제 구조는 다음과 같다

```bash
[ User Space ]
    └─ JVM 프로세스
        ├─ Code 영역
        ├─ Data 영역
        ├─ Heap (JVM Heap)
        ├─ Stack (Thread Stack)
        └─ Method Area (JVM 메타데이터)

[ Kernel Space ]
    └─ PCB
    └─ Page Table
    └─ File Descriptor
    └─ Scheduler 정보
```

자바에서는 **JVM이 하나의 프로세스**이다.

### code 영역

-   무엇이 저장되는가
    -   JVM 실행 코드 (C/C++로 작성됨)
    -   JIT 컴파일된 Native 코드
    -   일부 HotSpot 내부 코드
-   자바 코드 자체를 어디?
    -   `.class` 파일의 바이트코드는 처음엔 Heap에 로드되고, JIT가 네이티브 코드로 변환하면 **Code Cache 영역에 저장된다.**
-   예시

```java
public int add(int a, int b) {
    return a + b;
}
```

실행 흐름:

1. 클래스 로더가 `.class` 파일을 메모리에 로드
2. Method Area에 메타정보 저장
3. JIT가 hot method를 네이티브 코드로 변환
4. Code Cache에 저장

### Data 영역

자바에서는 전통적인 C의 Data 영역과 조금 다르다.

-   저장되는 것
    -   static 변수
    -   static final 변수
    -   클래스 메타데이터
    이것들은 JVM의 Method Area (MetaSpace)에 저장된다.
-   예시

```java
class Test {
    static int count = 10;
}
```

`count` → Method Area에 저장

### ⭐️Heap 영역

-   무엇이 저장되는가
    -   new로 생성된 객체
    -   인스턴스 변수
    -   배열
    -   런타임 상수 풀
-   예시

```java
Test t = new Test();
```

-   new Test() → Heap 에 객체 생성
-   t (참조 변수) → Stack에 저장
-   실제 객체 → Heap에 저장

-   객체 구조. Heap 내부:

```bash
Object Header
Instance Variables
Padding
```

-   언제 저장되는가?
    -   `new` 실행 시
    -   GC가 관리
    -   Young → Old 영역 이동

### Stack 영역

자바에서 스레드마다 독립적으로 존재

-   저장되는 것
    -   지역 변수
    -   매개변수
    -   리턴 주소
    -   참조 변수
-   예시

```java
public void method() {
    int a = 10;
    Test t = new Test();
}
```

| 변수            | 위치  |
| --------------- | ----- |
| a               | Stack |
| t (참조값)      | Stack |
| new Test() 객체 | Heap  |

-   함수 호출 시
    -   Stack Frame 생성:
    ```java
    Local Variable Array
    Operand Stack
    Frame Data
    ```

### PCB (Process Control Block)

자바는 결국 하나의 os 프로세스이다.

PCB에는:

-   JVM 프로세스 PID
-   CPU register
-   Page Table
-   Scheduling 정보
-   Open file descriptor
-   Thread 정보

이 저장된다.

</details>

## 프로세스와 스레드의 차이를 메모리 구조 관점에서 설명하면?

프로세스 메모리 구조

```bash
Code
Data
Heap
Stack
```

프로세스는 **자기만의 독립된 주소 공간**을 가진다.

스레드 메모리 구조

```bash
공유:
	Code
	Data
	Heap
독립:
	Stack
	Register
```

-   스레드는 같은 작업을 병렬로 처리하기 위한 실행 흐름
-   자원은 공유하고, 실행 흐름 상태 (함수 호출, 지역 변수)는 분리해야 함

## 멀티 프로세스와 멀티 스레드의 장단점은? 어떤 경우에 무엇을 선택하는가?

멀티 프로세스

-   장점
    -   안정성 높음 (하나 죽어도 다른 프로세스 영향 x)
    -   보안성 높음 (메모리 분리)
-   단점
    -   Context Switching 비용 큼
    -   IPC 비용 큼
    -   메모리 사용량 많음
-   예시
    -   브라우저 탭 분리
    -   마이크로서비스 아키텍처

멀티 스레드

-   장점
    -   자원 공유 → 메모리 효율
    -   Context Switching 빠름
    -   IPC 필요 없음
-   단점
    -   동기화 문제
    -   Deadlock 가능
    -   한 스레드 오류가 전체에 영향
-   예시
    -   웹 서버 요청 처리
    -   게임 엔진
    -   병렬 계산

## ⭐️스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?

Stack은 왜 독립인가?

Stack 에는:

-   함수 호출 정보
-   지역 변수
-   리턴 주소

가 저장된다.

만약 Stack을 공유하면:

```bash
Thread A 함수 호출
Thread B 함수 호출
-> 스택 프레임 충돌
```

→ 실행 흐름이 꼬인다!

따라서 **실행 흐름은 반드시 독립적이어야 함**

Heap은 왜 공유하는가?

Heap 에는:

-   객체
-   동적 할당 메모리

가 저장된다.

스레드를 사용하는 이유가:

> 같은 데이터를 여러 실행 흐름이 처리하기 위함

Heap을 공유하지 않으면 스레드를 쓰는 의미가 사라지는 것

## 프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)

Inter Process Communication. 프로세스는 메모리가 분리되어 있으므로 통신이 필요하다.

Pipe

-   부모-자식 간 통신
-   단방향
-   os 버퍼 사용

Message Queue

-   커널이 메시지 관리
-   구조화된 메시지 전달

Shared Memory

-   가장 빠름
-   같은 메모리 영역을 공유
-   대신 동기화 필요

Socket

-   네트워크 기반
-   로컬/원격 모두 가능
-   TCP/UDP 기반

속도 순서

```bash
Shared Memory > Pipe > Message Queue > Socket
```

## Context Switching이 프로세스보다 스레드에서 더 빠른 이유는?

📌 프로세스 Context Switch

저장해야 할 것:

-   Register
-   PC
-   Stack Pointer
-   Page Table
-   TLB flush
-   Kernel Stack
-   PCB 전체

주소 공간 변경이 필요하다

📌 스레드 Context Switch

저장:

-   Register
-   PC
-   Stack Pointer

주소 공간은 동일하다

→ Page Table 변경 없음

→ TLB flush 필요 없음

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

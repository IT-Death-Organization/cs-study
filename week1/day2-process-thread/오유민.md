# Day 2: 프로세스와 스레드

> 📅 2025.02.14 | 📁 Week 1

---

## 🧠 학습 질문

- [ ] 프로세스와 프로그램의 차이는?
- [ ] 프로세스와 스레드의 차이를 메모리 구조 관점에서 설명하면?
- [ ] 멀티 프로세스와 멀티 스레드의 장단점은? 어떤 경우에 무엇을 선택하는가?
- [ ] 스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?
- [ ] 프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)
- [ ] Context Switching이 프로세스보다 스레드에서 더 빠른 이유는?

---

### 📌 [Q1] 프로세스와 프로그램의 차이는?

**프로그램**
= 디스크에 저장된 실행 파일

- 실행을 기다리는 정적인 코드 파일 (아직 실행되지 않은 상태)
- 하드디스크나 SSD 같은 저장 장치에 저장되어 있으며, 아무런 동작을 하지 않음

**프로세스**
= 메모리에 올라와 실행되고 있는 프로그램

- 운영체제가 프로그램을 메모리에 올려서 실행한 동적인 상태
- 운영체제로부터 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받음
- 최소 하나 이상의 스레드를 포함함
- 스레드, 메모리, 자원 등을 모두 포함하고 있는 동적인 개념

### 📌 [Q2] 프로세스와 스레드의 차이를 메모리 구조 관점에서 설명하면?

프로그램이 실행되어 메모리에 올라가면 프로세스가 되고, 그 프로세스 안에서 실제로 작업을 수행하는 실행 단위가 바로 스레드이다. 이 둘은 **자원 공유 범위**에서 서로 차이가 있다.

**프로세스**

- 각 프로세스는 독립적인 메모리 영역을 가짐 (Code, Data, Heap, Stack)
  - Code: 실행할 프로그램의 코드 저장
  - Data: 전역 변수나 정적 변수 저장
  - Heap: 런타임에 동적으로 할당되는 데이터 저장
  - Stack: 지역 변수, 매개 변수, 리턴 값 등 임시 데이터 저장
- 다른 프로세스의 메모리에 직접 접근할 수 없음
  - 따라서 안정성은 높지만, 프로세스 간 통신(IPC)은 비용이 많이 들음

**스레드**

- 스레드는 하나의 프로세스 내에서 실행되는 작업 단위로, 프로세스의 자원을 공유받는다.
- 프로세스와 공유하는 영역: Code, Data, Heap -> 메모리 낭비 줄이고 통신 속도 향상
- 개별적인 영역: Stack, PC 레지스터
  - 독립적인 실행 흐름을 유지하기 위해 따로 가짐
  - Stack에는 함수 호출 정보, 지역 변수, 매개 변수 등과 같은 실행 흐름 정보가 저장되는데, 이를 공유하면 함수 호출이 서로 꼬이게 됨
  - 따라서 실행 흐름은 분리하되, 자원은 공유하기 위해 이 Stack만 분리함
- 공유 메모리에 직접 접근할 수 있어 통신 비용은 낮지만, 동기화 문제 있음 (공유 자원 충돌 가능성)

**정리**
| 프로세스는 독립된 메모리 공간(Code, Data, Heap, Stack)을 가지는 실행 단위이고, 스레드는 하나의 프로세스 내에서 Code, Data, Heap을 공유하면서 Stack만 별도로 가지는 실행 단위이다. 따라서 프로세스는 안정성이 높지만 생성 비용이 크고, 스레드는 자원 공유가 가능해 효율적이지만 동기화 문제가 발생할 수 있다.

### 📌 [Q3] 멀티 프로세스와 멀티 스레드의 장단점은? 어떤 경우에 무엇을 선택하는가?

**멀티 프로세스 (Multi-Process)**

- 하나의 프로그램을 여러 개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하도록 하는 방식
- 장점
  - 안정성 높음: 각 프로세스가 독립된 메모리 공간 가짐 -> 한 프로세스가 죽어도 다른 프로세스에 영향을 미치지 않는다.
  - 보안: 데이터 침범 위험이 적다.
- 단점
  - 메모리 사용량 많음: 각 프로세스마다 독립된 메모리 영역을 할당해야 하므로 메모리 사용량이 크다.
  - Context Switching 비용이 큼: 프로세스 간 전환 시 캐시 메모리 초기화 등 오버헤드가 크다.
  - 통신 복잡도: 프로세스 간 데이터를 주고받으려면 IPC(프로세스 간 통신)라는 복잡한 기술이 필요하고 이 역시 비용이 크다.

  **멀티 스레드 (Multi-Thread)**
  - 하나의 프로세스 내에서 여러 개의 스레드를 생성해 자원을 공유하며 작업을 처리하는 방식
  - 장점
    - 메모리 공유 -> 효율성: 메모리 공간(Heap, Data)을 공유하므로 자원 소모가 적다.
    - 통신 속도: 공유 메모리를 통해 스레드 간 데이터 전달이 매우 빠르다.
    - 응답성: 한 스레드가 대기(I/O 등)중이어도 다른 스레드가 작업을 계속할 수 있어 사용자 경험이 좋다.
    - Context Switching 비용이 적다.
  - 단점
    - 안정성 취약: 하나의 스레드에서 오류가 발생하면 프로세스 전체가 종료될 수 있다.
    - 동기화 문제: 여러 스레드가 동시에 같은 자원에 접근할 때 데드락이나 데이터 정합성과 같은 문제가 발생할 수 있다.

따라서

- 안정성이 가장 중요한 경우 -> 멀티 프로세스
  - 서버에서 한 요청의 오류가 전체 시스템에 영향을 주면 안 될 때
  - ex) 탭마다 독립 프로세스를 가지는 브라우저 (크롬 등)
- 자원 효율 + 빠른 통신이 중요한 경우 -> 멀티 스레드
  - 요청을 빨리, 많이 처리해야 하는 서버
  - 공유 데이터가 많은 작업
  - 실시간 처리 시스템
  - ex) 게임 서버, 채팅 서버

**정리** <br />
멀티 프로세스는 각 프로세스가 독립된 메모리 공간을 가지기 때문에 안정성이 높지만, 생성 비용과 통신 비용이 크다.
반면 멀티 스레드는 메모리를 공유하기 때문에 자원 효율이 좋고 빠르지만, 동기화 문제가 발생할 수 있다.
따라서 안정성과 격리가 중요하면 멀티 프로세스를, 성능과 자원 효율이 중요하면 멀티 스레드를 선택하며, 실무에서는 두 방식을 혼합하여 사용하는 경우가 많다.

### 📌 [Q4] 스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?

**스레드가 스택을 독립적으로 가지는 이유**
각 스레드는 **독립적인 실행 흐름**을 가지기 위해 스택을 반드시 따로 가져야 한다.
스택은 함수 호출과 관련된 정보(콜 스택, 지역 변수, 매개 변수, 리턴 주소 등)를 저장하는 공간이다.

만약 이 스택을 공유하게 되면, 두 스레드가 동시에 함수 호출을 하면 같은 스택 안에서 함수 호출 순서가 섞이거나, 리턴 주소가 꼬이거나, 지역 변수가 덮어쓰이는 등의 문제가 발생해 프로그램 실행 자체가 망가질 수 있다.

또한 CPU는 한 번에 하나의 스레드만 처리하므로, 스레드 간 전환(Context Switching)이 빈번하게 일어난다. 이때 스택이 독립적이어야만 이전에 어디까지 실행했는지(복귀 주소 등)를 정확히 기억하고 다시 시작할 수 있다.

**스레드가 힙을 공유하는 이유**
힙은 런타임에 동적으로 할당되는 데이터(객체, 인스턴스 등)가 저장되는 공간으로, **여러 실행 흐름이 함께 써야 하는 데이터(공유 데이터 저장 공간)** 이다.
멀티 스레드의 목적은 같은 프로세스 내에서 데이터를 공유하면서 동시에 작업하기 위함이다. 따라서 **자원 효율성과 빠른 데이터 공유**를 위해 힙을 공유한다.

**자원 공유의 효율성**: 만약 힙이 스레드마다 독립적이라면, 같은 데이터를 쓰기 위해 매번 복사본을 만들어야 해 메모리가 낭비된다. 힙을 공유하면 큰 데이터를 하나만 생성해두고 여러 스레드가 주소값만 참조해서 사용할 수 있다.

**스레드 간 통신 속도 빠름**: 멀티 프로세스는 데이터를 주고받기 위해 복잡한 IPC 기법을 써야하지만, 멀티 스레드는 힙 영역에 데이터를 올려두고 서로 공유하기 때문에 통신 속도가 엄청나게 빠르다.

**정리** <br />
스택에는 함수 호출 정보와 지역 변수 등 실행 흐름과 관련된 데이터가 저장되기 때문에, 여러 스레드가 공유하면 호출 순서와 리턴 주소가 충돌할 수 있다. 따라서 스레드는 각각 독립적인 스택을 가진다. 반면 힙에는 객체와 같은 동적 데이터가 저장되며, 멀티 스레드는 데이터를 효율적으로 공유하기 위해 존재하므로 힙 영역은 공유한다. 하지만 이로 인해 동기화 문제(race condition)가 발생할 수 있다.

### 📌 [Q5] 프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)

프로세스는 각각 독립된 메모리 영역을 가지므로 직접 메모리를 공유할 수 없다. 따라서 서로 데이터를 주고받으려면 운영체제가 제공하는 통신 방법인 IPC(Inter-Process Communication)를 사용해야 한다.

**1. 파이프(Pipe)**

- 가장 오래된 IPC 기법 중 하나로, 한 프로세스가 쓰고 다른 프로세스가 읽는 **단방향** 통신 방식이다.
- 부모 & 자식 프로세스 간 통신에 주로 사용된다.
- FIFO 구조 & 단순하고 빠름 & 양방향 통신은 파이프 2개 필요
- 서로 관계 있는 프로세스에서 주로 사용하고, 같은 시스템 내에서만 가능하다.

**2. 메세지 큐(Message Queue)**

- 데이터를 메세지 단위로 묶어 큐 형태로 관리하는 방식이다.
- **비동기적** 입출력 방식으로, 보낸 쪽에서 메세지를 던져두면 받는 쪽에서 원할 때 꺼내갈 수 있다.
- 여러 프로세스가 동시에 메세지를 읽고 쓸 수 있다.
- 커널을 거치므로 오버헤드가 존재한다.

**3. 공유 메모리(Shared Memory)**

- 여러 프로세스가 같은 메모리 영역을 공유하도록 설정
- 가장 빠른 IPC 방식 (커널을 거의 거치지 않고 직접 메모리에 접근하기 때문)
- 대용량 데이터 전송에 적합하다.
- 여러 프로세스가 동시에 같은 데이터를 수정하려고 할 때 발생하는 **동기화 문제**를 직접 해결해야 한다. (세마포어, 뮤텍스)

**4. 소켓(Socket)**

- 네트워크 통신을 위한 도구이지만, 같은 컴퓨터 내의 프로세스 간 통신에도 사용된다.
- 로컬 컴퓨터뿐만 아니라 네트워크로 연결된 다른 컴퓨터의 프로세스와도 통신이 가능하다.
- 범용성이 높고, 표준화된 인터페이스(TCP/IP, UDP 등)을 사용한다.
- 데이터를 패킷 단위로 직렬화/역직렬화해야 하므로 오버헤드가 크다.

### 📌 [Q6] Context Switching이 프로세스보다 스레드에서 더 빠른 이유는?

**바꿔야 할 정보의 양과 범위가 스레드가 훨씬 더 작기 때문이다.**

**1. 캐시 메모리의 초기화 여부**

- 프로세스: 독립적인 주소 공간 가지므로, 프로세스가 바뀌면 CPU 내부에 저장된 캐시 데이터와 TLB(주소 변환 캐시)가 기존 프로세스의 정보로 차있어, 이를 모두 비우고(Flush) 새로운 프로세스의 데이터로 채워야 한다.
- 스레드: 같은 프로세스 내의 code, data, heap 영역을 공유 -> 스레드만 바뀔 때는 메모리 주소 체계가 바뀌지 않으므로 캐시나 TLB를 비울 필요가 없다. CPU 입장에서는 이미 메모리에 올라와있는 데이터를 그대로 쓰면서 실행 지점(stack)만 옮기면 되기 때문에 훨씬 빠르다.

**2. 저장 및 복구할 정보량의 차이**
context switching이 일어날 때 운영체제는 현재 상태를 PCB(Process Control Block)나 TCB(Thread Control Block)에 기록한다.

- 프로세스 (스위칭): 가상 메모리 주소 정보, 열려 있는 파일 목록, 입출력 상태 등 **프로세스 전체의 무거운 상태 정보를 모두 저장하고 불러와야** 한다.
- 스레드 (스위칭): 스레드 고유의 정보인 **레지스터 값, 스택 포인터, PC** 정도만 저장하고 복구하면 된다.

**3. 메모리 주소 체계 전환 비용**
운영체제는 프로세스를 바꿀 때마다 Page Table을 교체해 가상 메모리 주소를 실제 물리 주소로 맵핑하는 기준을 완전히 바꾼다.
이 작업 자체가 CPU에겐 상당이 부담이 되는 작업인데, 스레드 간 전환 시에는 이 주소 체계가 유지되므로 이로 인한 오버헤드가 발생하지 않는다.

**\*왜 주소 공간 변경이 무거울까?**
CPU는 메모리 접근을 빠르게 하기 위해 TLB(주소 변환 캐시)를 사용한다.
프로세스가 바뀌면 아래와 같은 비효율적인 과정을 거친다.

- 기존 가상 주소 <-> 물리주소 맵핑이 무효가 됨
- TLB flush 발생
- 캐시 미스 증가
  하지만 스레드는 같은 주소 공간을 사용하므로 위 과정이 필요가 없다.

**정리** <br />
프로세스는 서로 다른 주소 공간을 가지기 때문에 Context Switching 시 페이지 테이블 변경과 TLB 초기화가 발생한다. 반면 스레드는 같은 프로세스 내에서 메모리를 공유하므로 주소 공간을 변경할 필요가 없고, 단순히 레지스터와 스택 포인터만 교체하면 된다. 따라서 스레드의 Context Switching이 더 빠르다.

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

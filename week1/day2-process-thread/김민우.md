# Day 2: 프로세스와 스레드
> 📅 2025.02.14 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 프로세스와 프로그램의 차이는?
- [x] 프로세스와 스레드의 차이를 메모리 구조 관점에서 설명하면?
- [x] 멀티 프로세스와 멀티 스레드의 장단점은? 어떤 경우에 무엇을 선택하는가?
- [x] 스레드가 스택을 독립적으로 가지는 이유는? 힙은 왜 공유하는가?
- [x] 프로세스 간 통신(IPC) 방법은? (파이프, 메시지 큐, 공유 메모리, 소켓)
- [x] Context Switching이 프로세스보다 스레드에서 더 빠른 이유는?

## 1. 프로세스와 프로그램

### 프로그램 (Program)

- 디스크에 저장된 실행 파일
- 수동적(Passive) 존재
- 예: `chrome.exe`, `a.out`

### 프로세스 (Process)

- 프로그램이 **메모리에 로드되어 실행 중인 상태**
- 능동적(Active) 존재
- CPU, 메모리, 파일 디스크립터 등 **자원을 할당받음**

---

## 2. 프로세스 vs 스레드

### 프로세스 메모리 구조

각 프로세스는 독립적인 메모리 공간을 가집니다.

```
┌─────────────┐
│ Code 영역   │  실행 코드 (읽기 전용)
├─────────────┤
│ Data 영역   │  전역 변수, static 변수
├─────────────┤
│ Heap 영역   │  동적 할당 (new, malloc)
├─────────────┤
│ Stack 영역  │  함수 호출, 지역 변수, 매개변수
└─────────────┘
```

**프로세스 간 메모리 격리**

```
프로세스 A  ──> Heap_A, Stack_A, Data_A
프로세스 B  ──> Heap_B, Stack_B, Data_B
```

- 서로 메모리 접근 불가
- 침범 불가 → 안정성 높음
- 대신 IPC 필요 (파이프, 소켓 등)

### 스레드 메모리 구조

같은 프로세스 내부의 스레드들은 일부 메모리를 공유합니다.

**스레드 간 메모리 공유**

```
하나의 프로세스
 ├─ Thread 1 (Stack 개별)
 ├─ Thread 2 (Stack 개별)
 └─ Thread 3 (Stack 개별)
      ↓
   Code, Data, Heap 공유
```

---

## 3. 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스 (Multi-Process)

### 장점

1. **안정성**: 하나의 프로세스가 종료되어도 다른 프로세스에 영향 없음
2. **보안성**: 프로세스 간 메모리 격리
3. **확장성**: 다른 머신으로 분산하기 쉬움

### 단점

1. **생성 비용 큼**: PCB, 주소 공간, 페이지 테이블 생성
2. **컨텍스트 스위칭 비용 큼**: MMU 주소 공간 교체, TLB flush 발생
3. **통신 비용 큼**: IPC 필요, 커널 모드 진입 발생

### 멀티 스레드 (Multi-Thread)

### 장점

1. **생성 비용 작음**: 주소 공간 공유, TCB만 생성
2. **컨텍스트 스위칭 빠름**: 주소 공간 교체 없음
3. **통신 비용 낮음**: 변수 공유 가능, IPC 불필요
4. **메모리 효율 좋음**: 공유 메모리 구조

### 단점

1. **안정성 낮음**: 하나의 스레드 오류가 전체 프로세스 종료로 이어짐
2. **Race Condition 발생 가능**: 동기화 문제
3. **동기화 비용 존재**: lock, mutex 오버헤드
4. **디버깅 어려움**: 복잡한 동시성 문제

### 언제 무엇을 선택하는가?

**멀티 프로세스를 선택하는 경우**

- 안정성이 중요한 경우 (금융 시스템, 브라우저, OS 서비스)
- 서로 완전히 독립적인 작업
- CPU 코어 활용 + 메모리 격리 필요
- 마이크로서비스 구조

**멀티 스레드를 선택하는 경우**

- 같은 데이터 기반 병렬 처리 (웹 서버 요청 처리, 게임 엔진, 영상 처리)
- 빠른 통신이 필요한 경우
- 공유 객체 기반 로직

---

## 4. 스레드의 메모리 구조

### 스레드가 Stack을 독립적으로 가지는 이유

**Stack의 역할**

- 함수 호출 정보
- 지역 변수
- 매개변수
- 리턴 주소
- 스택 프레임

**만약 Stack을 공유한다면?**

```
Thread A: functionA() → functionB()
Thread B: functionC() → functionD()
```

- A의 리턴 주소가 B에 의해 덮어씌워짐
- 지역 변수 충돌
- 실행 흐름 붕괴

→ **동시에 여러 실행 흐름을 유지할 수 없음**

### 힙은 왜 공유하는가?

**Heap의 역할**

- 객체
- 동적 할당 메모리
- new로 생성한 인스턴스

**스레드의 존재 이유**

- 메모리 공유를 통한 효율성
- 빠른 통신
- 가벼운 생성 비용

→ **따라서 Heap은 공유하는 것이 합리적**

---

## 5. 프로세스 간 통신 (IPC)

프로세스는 서로 독립된 가상 주소 공간을 가지므로 직접 메모리 접근이 불가능합니다. 따라서 **IPC (Inter-Process Communication)** 가 필요합니다.

### 파이프 (Pipe)

**개념**: 한 프로세스의 출력 → 다른 프로세스의 입력으로 연결

```
Process A → Kernel Buffer → Process B
```

**특징**

- 단방향 (기본 pipe)
- 부모-자식 관계에서 자주 사용
- 커널 버퍼를 통해 전달

**장점**

- 구현 단순
- 소규모 데이터에 적합

**단점**

- 양방향 통신 어려움 (2개 필요)
- 대량 데이터 비효율

### 메시지 큐 (Message Queue)

**개념**: 커널이 메시지를 저장하고, 프로세스가 읽고 쓰는 방식

```
Process A → Kernel Message Queue → Process B
```

**특징**

- 메시지 단위 통신
- 비동기 가능
- 우선순위 설정 가능

**장점**

- 구조화된 메시지 전달
- 프로세스 간 독립성 유지

**단점**

- 커널 공간 복사 발생
- 공유 메모리보다 느림

### 공유 메모리 (Shared Memory)

**개념**: 여러 프로세스가 같은 물리 메모리 영역을 매핑해서 사용

```
Process A
          ↘
            [Shared Memory]
          ↗
Process B
```

**특징**

- 가장 빠름
- 커널 개입 최소
- 직접 메모리 접근

**장점**

- 대용량 데이터에 적합
- 복사 비용 없음

**단점**

- 동기화 직접 구현 필요 (mutex, semaphore 등)

### 소켓 (Socket)

**개념**: 네트워크 기반 통신, 로컬/원격 통신 모두 가능

```
Process A ⇄ TCP/IP Stack ⇄ Process B
```

**특징**

- 다른 머신과 통신 가능
- 네트워크 프로토콜 사용 (TCP/UDP)

**장점**

- 확장성 뛰어남
- 분산 시스템에 적합

**단점**

- 오버헤드 큼
- 네트워크 비용 발생

### 속도 비교

```
공유 메모리 > 파이프 ≈ 메시지 큐 > 소켓
```

---

## 6. Context Switching

### Context Switching이란?

실행 중인 작업 A → 작업 B로 바꾸는 것. CPU는 이전 작업의 상태를 저장하고 새 작업의 상태를 복원해야 합니다.

### 프로세스 Context Switching에서 바뀌는 것

### 1. 레지스터 저장/복원 (스레드와 동일)

- PC (프로그램 카운터)
- SP (스택 포인터)
- 일반 레지스터

### 2. 페이지 테이블 교체 (프로세스만)

각 프로세스는 자기만의 페이지 테이블 보유

```
CR3 ← 새로운 페이지 테이블 주소로 변경
```

### 3. TLB Flush (프로세스만)

TLB는 가상주소 → 물리주소 변환 캐시입니다.

- 프로세스가 바뀌면 이전 프로세스의 매핑 정보는 무효
- TLB를 비워야 함
- 다음 메모리 접근 시 페이지 테이블을 다시 탐색 → 메모리 접근 속도 저하

### 스레드 Context Switching

스레드는 같은 프로세스 내부에 있으므로:

- 주소 공간 동일
- 페이지 테이블 동일
- CR3 변경 없음
- TLB flush 없음

**교체하는 것**: 레지스터, 스택 포인터만

### 비교 정리

| 항목 | 프로세스 | 스레드 |
| --- | --- | --- |
| 레지스터 교체 | O | O |
| 주소 공간 교체 | O | X |
| CR3 변경 | O | X |
| TLB flush | O | X |
| 페이지 테이블 변경 | O | X |

### 왜 스레드가 더 빠른가?

**TLB flush의 영향**

- TLB는 매우 빠른 CPU 캐시
- Flush 되면 다음 메모리 접근 때 페이지 테이블을 다시 탐색
- 메모리 접근 속도 저하

**결론**

- 프로세스 전환: 메모리 접근 비용까지 증가
- 스레드 전환: 이러한 비용 없음 → **훨씬 빠름**


## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

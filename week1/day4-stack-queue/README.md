# Day 4: 스택(Stack)과 큐(Queue)
> 📅 2025.02.16 | 📁 Week 1

---

## 🧠 학습 질문

- [ ] 재귀 함수 호출이 스택을 사용하는 이유는?
- [ ] 함수 호출 스택(Call Stack)은 어떻게 동작하는가?
- [ ] 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?
- [ ] 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?
- [ ] 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?
- [ ] 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

---

## Q1. 재귀 함수 호출이 스택을 사용하는 이유는?

재귀 함수는 자기 자신을 다시 호출하는 구조이다. 이때 각 함수 호출은 독립적인 실행 상태를 가져야 한다. 즉, 다음 정보들이 호출마다 따로 저장되어야 한다.

* 매개변수(Parameter)
* 지역 변수(Local Variables)
* 복귀 주소(Return Address)
* 이전 호출의 실행 상태

이 정보를 저장하는 공간이 바로 **호출 스택(Call Stack)** 이다.

재귀는 구조적으로 **후입선출(LIFO, Last In First Out)** 흐름을 가진다.

예시:

```
factorial(3)
 → factorial(2)
   → factorial(1)
```

실행은 위와 같이 내려가지만, 종료는 역순으로 진행된다.

```
factorial(1) 종료
 → factorial(2) 복귀
   → factorial(3) 복귀
```

가장 마지막에 호출된 함수가 가장 먼저 종료된다.

이 흐름이 스택의 push/pop 구조와 정확히 일치하기 때문에 재귀는 자동으로 스택을 사용한다.

---

## Q2. 함수 호출 스택(Call Stack)은 어떻게 동작하는가?

함수가 호출되면 시스템은 새로운 **스택 프레임(Stack Frame)** 을 생성한다.

### 스택 프레임에 저장되는 정보

* 매개변수
* 지역 변수
* 복귀 주소
* 이전 프레임 정보

### 동작 과정

1. 함수 호출 → 스택 프레임 생성(push)
2. 함수 실행
3. 함수 종료 → 스택 프레임 제거(pop)
4. 복귀 주소로 이동

예시:

```
main()
  → A()
    → B()
```

스택 구조:

```
| B |
| A |
| main |
```

B 종료 후:

```
| A |
| main |
```

이 구조 덕분에 프로그램은 중첩 호출을 정확히 관리할 수 있다.

---

## Q3. 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?

### 발생 원인

스택 메모리는 크기가 제한되어 있다.

다음 경우에 스택 오버플로우가 발생한다.

* 종료 조건이 없는 재귀
* 재귀 깊이가 지나치게 깊을 때
* 과도하게 큰 지역 변수를 선언했을 때

예시:

```
void f() {
    f();
}
```

종료 조건이 없으므로 무한히 스택이 쌓이다가 메모리 초과로 프로그램이 종료된다.

### 방지 방법

* 재귀 종료 조건 명확히 정의
* 반복문으로 대체 가능하면 반복문 사용
* Tail Recursion 최적화 활용
* 지역 변수 크기 최소화
* 시스템 스택 크기 조정

---

## Q4. 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?

선형 큐는 배열 기반으로 구현되며 front와 rear 포인터를 사용한다.

예시:

```
[ x ][ x ][ 3 ][ 4 ][   ]
  ↑
  front
```

앞부분이 비어 있어도 재사용되지 않는다.

결과적으로 rear가 배열 끝에 도달하면 더 이상 삽입할 수 없는데, 실제로는 앞쪽에 공간이 남아 있다.

이 문제를 **false overflow**라고 한다.

### 해결 방법

1. 원형 큐(Circular Queue) 사용 (권장)
2. dequeue 시 요소를 앞으로 당기는 방식 (비효율적, O(n))

실무에서는 원형 큐가 정석적인 해결 방법이다.

---

## Q5. 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?

원형 큐는 배열을 원형처럼 사용한다.

### 포인터 이동 공식

```
(next_index) = (current_index + 1) % size
```

예시:

배열 크기 = 5

```
rear = 4
(4 + 1) % 5 = 0
```

끝에 도달하면 다시 처음으로 이동한다.

### 상태 판별

Empty 조건:

```
front == rear
```

Full 조건 (한 칸 비워두는 방식):

```
front == (rear + 1) % size
```

### 시간복잡도

* enqueue: O(1)
* dequeue: O(1)

---

## Q6. 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

큐는 FIFO 구조이고, 스택은 LIFO 구조이다.

두 개의 스택을 사용하면 FIFO를 구현할 수 있다.

### 구조

* stack_in  → 삽입용
* stack_out → 삭제용

### enqueue(x)

```
stack_in.push(x)
```

### dequeue()

1. stack_out이 비어 있으면

   * stack_in의 모든 요소를 stack_out으로 이동
2. stack_out.pop()

### 동작 예시

```
enqueue(1)
enqueue(2)
enqueue(3)
```

stack_in:

```
3
2
1
```

stack_out으로 이동 후:

```
1
2
3
```

pop → 1 반환

FIFO가 유지된다.

### 시간복잡도 분석

* enqueue: O(1)
* dequeue: 최악 O(n)

하지만 각 원소는

* stack_in에 한 번 push
* stack_out으로 한 번 이동
* 한 번 pop

따라서 전체 평균(Amortized) 시간복잡도는 O(1)이다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

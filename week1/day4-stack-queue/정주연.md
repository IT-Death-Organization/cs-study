# Day 4: 스택(Stack)과 큐(Queue)

> 📅 2025.02.16 | 📁 Week 1
> 

---

## 🧠 학습 질문

- [x]  재귀 함수 호출이 스택을 사용하는 이유는?
- [x]  함수 호출 스택(Call Stack)은 어떻게 동작하는가?
- [x]  스택 오버플로우는 왜 발생하며 어떻게 방지하는가?
- [x]  선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?
- [x]  원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?
- [x]  스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

## 재귀 함수 호출이 스택을 사용하는 이유

- **복귀 주소 관리:** 함수가 호출되면 실행이 끝난 후 원래 호출된 지점으로 돌아가야 함. 호출 순서의 역순으로 복귀해야 하므로 LIFO(Last-In-First-Out) 구조인 스택이 가장 적합함.
- **독립적 문맥 유지:** 재귀는 동일한 함수를 호출하지만 각 호출은 서로 다른 지역 변수와 매개변수 값을 가짐. 이를 별도의 '스택 프레임'에 저장하여 서로 간섭하지 않도록 관리함.

### **함수 호출 스택(Call Stack)의 동작 방식**

- **스택 프레임(Stack Frame) 생성:** 함수 호출 시 해당 함수의 매개변수, 지역 변수, 복귀 주소 등을 포함하는 스택 프레임이 생성되어 메모리의 스택 영역에 **PUSH**됨.
- **실행 제어:** CPU는 항상 스택의 최상단(Top)에 있는 프레임을 현재 실행 중인 함수로 인식하고 처리함.
- **프레임 소멸:** 함수 실행이 완료되어 return되면, 해당 스택 프레임을 **POP**하여 메모리에서 제거하고, 저장된 복귀 주소로 돌아가 이전 함수의 실행을 이어감

### **스택 오버플로우 발생 원인 및 방지 대책**

- **발생 원인:** 스택 메모리는 크기가 제한적임. 탈출 조건이 없는 무한 재귀나 너무 깊은 재귀 호출로 인해 할당된 스택 영역을 초과할 때 발생함.

**방지 대책:**

- **기저 조건(Base Case) 명시:** 재귀가 멈추는 조건을 명확히 설정함.
- **반복문(Iteration) 전환:** 재귀 대신 for나 while문을 사용하여 스택 사용량을 줄임.
- **꼬리 재귀 최적화(TCO):** 컴파일러가 재귀 호출을 반복문 형태로 최적화할 수 있도록 함수 구조를 설계함.
- **스택 크기 조절:** 환경 설정을 통해 스택 메모리 크기를 늘림(근본적인 해결책은 아님)

### **선형 큐의 공간 낭비 문제 해결법**

- **문제점:** 선형 큐에서 데이터를 꺼내면(dequeue) front 포인터가 뒤로 이동하여 앞부분의 공간이 비게 되지만, rear가 끝에 도달하면 앞 공간을 사용하지 못함.
- **해결책:** * **데이터 시프팅:** 데이터를 앞으로 한 칸씩 당김. 하지만 $O(n)$의 비용이 발생하여 비효율적임.
- **원형 큐(Circular Queue) 사용:** 마지막 인덱스와 첫 번째 인덱스를 논리적으로 연결하여 남은 공간을 재사용함.

### **원형 큐의 포인터 이동 계산법**

- **나머지 연산자(%) 활용:** 인덱스가 배열의 끝에 도달했을 때 다시 0으로 돌아오도록 연산함.
- **공식:**
- Next Rear = (current_rear + 1) % capacity
- Next Front = (current_front + 1) % capacity
- **상태 구분:** 큐가 꽉 찬 상태와 비어 있는 상태를 구분하기 위해 보통 한 칸을 비워두는 전략을 사용함((rear + 1) % capacity == front 이면 Full).

### **스택 2개로 큐 구현 및 시간 복잡도**

- **구현 방법:**
    - **Stack In:** 데이터를 삽입(Enqueue)할 때 사용하는 스택.
    - **Stack Out:** 데이터를 추출(Dequeue)할 때 사용하는 스택.
    - **Enqueue:** Stack In에 PUSH 함.
    - **Dequeue:**
        - 1. Stack Out이 비어있다면, Stack In의 모든 요소를 POP 하여 Stack Out에 PUSH 함 (순서가 뒤집혀 큐의 형태가 됨).
        - 2. Stack Out의 최상단 요소를 POP 함.
    - 시간 복잡도
        - **Enqueue:** 항상 O(1)
        - **Dequeue:** Stack Out이 비어있을 때 옮기는 작업은 O(n)이지만, 전체적인 관점에서 데이터는 각각 한 번씩만 옮겨지므로 분할 상환(Amortized) O(1)임

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->
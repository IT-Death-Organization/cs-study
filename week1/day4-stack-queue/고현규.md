# Day 4: 스택(Stack)과 큐(Queue)
> 📅 2025.02.16 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 재귀 함수 호출이 스택을 사용하는 이유는?
- [x] 함수 호출 스택(Call Stack)은 어떻게 동작하는가?
- [x] 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?
- [x] 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?
- [x] 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?
- [x] 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

<br>

# 1. 재귀 함수 호출이 스택을 사용하는 이유는?

재귀 함수는 함수가 실행 도중 자기 자신을 다시 호출하는 구조입니다. 이때 원래 실행 중이던 함수는 작업을 멈추고, 새로 호출된 함수가 끝날 때까지 기다려야 합니다.

재귀 호출은 가장 나중에 호출된 함수가 가장 먼저 종료되어야 그 앞의 함수가 실행이 재개될 수 있습니다. 이는 스택의 LIFO 구조와 일치하기 때문에 재귀 함수는 스택을 사용하여 구현됩니다.

함수가 호출될 때마다 해당 함수의 지역 변수, 매개변수, 그리고 함수가 끝난 후 돌아갈 복귀 주소 정보를 스택에 저장해야 합니다. 그래야 나중에 호출된 함수가 끝난 후 이전 함수의 상태를 그대로 복원 가능합니다.

<br>

# 2. 함수 호출 스택(Call Stack)은 어떻게 동작하는가?

함수 호출 스택은 프로그램 내에서 현재 실행중인 서브루틴(함수)들에 대한 정보를 담고있는 메모리 영역입니다.

### 1. 함수 호출 (Push)
새로운 함수가 호출되면 해당 함수의 정보를 담은 스택 프레임(Stack Frame)이 생성되어 스택의 맨 위에 쌓입니다.
스택 프레임에는 매개변수, 지역 변수, 복귀 주소 등이 포함됩니다.

### 2. 함수 실행
CPU는 항상 스택의 맨 위에 있는 프레임의 함수를 실행중인 함수로 간주합니다.

### 3. 함수 종료 (Pop)
함수의 실행이 끝나면 해당 함수의 스택 프레임이 제거됩니다. 이때 프레임에 저장되어있던 복귀 주소를 확인해 이 함수를 호출한 이전 함수로 돌아가 작업을 이어갑니다.

<br>

# 3. 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?

### 스택 오버플로우 (Stack Overflow)

함수 호출 스택은 메모리 공간이 무한하지 않고 운영체제나 프로세스 설정에 의해 한정된 공간(메모리)을 가집니다.

재귀 함수에 탈출 조건이 없거나 잘못 설정되어있어 무한 호출이 발생하는 경우 스택 오버플로우가 발생할 수 있습니다. 또한 무한은 아니더라도 너무 과도한 호출이 발생하면 스택 오버플로우가 발생할 수 있습니다.

한 함수 내에서 너무 큰 용량의 지역 변수를 선언한 경우 스택 프레임이 스택의 한도를 넘어서서 스택 오버플로우가 발생할 수 있습니다.

### 스택 오버플로우 방지

기저 조건(Base Case)을 제대로 설정하고 재귀 호출을 할 때 탈출 조건을 확인하는 것이 중요합니다.

꼭 재귀가 필요한 경우가 아닐 때 for, while 등의 반복문을 사용하는 것은 스택 프레임을 쌓지 않아 메모리 효율이 좋은 괜찮은 선택지입니다.

너무 큰 데이터는 스택 대신 동적 할당을 이용해 힙 영역에 저장합니다. (malloc, new 등)

<br>

# 4. 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?

선형 큐(Linear Queue)는 데이터를 꺼낼 때마다 앞부분이 비게 되지면 포인터는 뒤로만 이동하기 때문에 앞쪽의 남는 공간이 낭비되게 됩니다.

### 해결 방법

1. 데이터 이동
    * 데이터를 꺼낼 때마다 뒤쪽의 데이터를 모두 한칸씩 앞으로 이동시킵니다.
    * O(n)의 시간복잡도가 발생하고 매우 비효율적입니다.

2. 원형 큐(Circular Queue) - 가장 정석적인 방법
    * 큐의 마지막 인덱스 뒤가 다시 큐의 첫 인덱스를 가리키도록 하는 논리적 원형 구조를 사용합니다.
    * 낭비되던 앞부분을 활용할 수 있습니다.

<br>

# 5. 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?

배열의 마지막 인덱스에서 다음 인덱스를 다시 처음(0)으로 되돌아오게끔 하는 방법은 나머지 연산(%)을 통해 간단하게 구할 수 있습니다.

배열의 크기를 Capacity라고 할 때,
$$Next\ Pointer = (Current\ Pointer + 1)\  \%\  Capacity$$

원형 큐에서 Front는 가장 앞의 인덱스(0)을, 배열의 마지막 요소의 바로 뒤를 가리킵니다. 이때 배열이 비어있는 경우에 Front == Rear이고, 배열이 가득 차있는 경우에도 Front == Rear이 됩니다. 따라서 원형 큐에서는 현재 큐가 공백인지 포화인지 구분하기 위해 한 칸을 비워둡니다.

<br>

# 6. 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

스택 2개로 큐를 구현하기 위해서는 In-Stack 과 Out-Stack 으로 역할을 나누어 구현합니다.

### Enqueue (데이터 추가)
Push가 일어나면 항상 In-Stack에 데이터를 추가합니다. `O(1)`

### Dequeue (데이터 추출)
1. 먼저 Out-Stack을 확인합니다. 만약 Out-Stack이 비어있다면 In-Stack의 모든 데이터를 Out-Stack으로 이동시킵니다. `O(n)`
2. Out-Stack의 Top을 Pop합니다. `O(1)`

### 시간복잡도
Dequequ에서 Out-Stack이 비어있는 경우 In-Stack에서 Out-Stack으로 데이터를 이동하는 과정은 `O(n)`이지만 한번 옮겨두면 Out-Stack이 빌 때까지는 `O(1)`입니다.
전체적으로 보면 데이터 하나당 In-Stack Push(1번), In -> Out 이동(1번), Out-Stack Pop(1번) 총 3번의 연산만 일어나므로 Amortized(분할 상환) `O(1)`이 됩니다.
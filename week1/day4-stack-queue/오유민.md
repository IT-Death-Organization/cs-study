# Day 4: 스택(Stack)과 큐(Queue)

> 📅 2025.02.16 | 📁 Week 1

---

## 🧠 학습 질문

- [ ] 재귀 함수 호출이 스택을 사용하는 이유는?
- [ ] 함수 호출 스택(Call Stack)은 어떻게 동작하는가?
- [ ] 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?
- [ ] 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?
- [ ] 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?
- [ ] 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

---

### 📌 [Q1] 재귀 함수 호출이 스택을 사용하는 이유는?

재귀 함수가 실행될 때 stack 메모리 구조를 사용하는 이유는 **함수의 호출 정보(context)를 저장하고, 작업이 끝난 뒤 원래 호출했던 지점으로 되돌아오기 위해서(복원)** 이다. 이는 프로그램의 함수 호출 매커니즘 자체가 LIFO 구조를 기반으로 설계되었기 때문이다.

따라서 재귀 함수는 각 호출의 실행 상태를 독립적으로 저장하고, 가장 나중에 호출된 함수부터 복귀해야 하기 때문에 LIFO 구조인 stack을 사용한다.

**1. LIFO 구조**

- 재귀 함수는 자기 자신을 계속 호출하는 함수이다. 이때 가장 마지막에 호출된 함수가 가장 먼저 완료되어야 한다. (함수 실행의 중첩 구조) -> LIFO

**2. Stack Frame 보존**

- **재귀 함수가 호출될 때마다 stack에는 stack frame이라는 독립적인 메모리 공간이 생성**된다.
- stack frame에는 다음과 같은 정보가 담긴다:
  - 지역 변수: 함수 내부에서 선언된 변수, 각 호출 단계에서 사용하는 고유한 데이터
  - 매개 변수: 함수에 전달된 인자 값
  - 리턴 주소: 함수 실행이 끝난 후 돌아가서 실행해야 할 코드의 위치 (부모)
- 재귀가 깊어질 때마다 새로운 스택 프레임이 계속 쌓이기 때문에, 각 호출은 서로의 변수 값을 침범하지 않고 독립적인 상태를 유지할 수 있다.

**3. Backtracking**

- 재귀의 핵심은 **탈출 조건(base case)에 도달**했을 때이다.
- 조건을 만족하면 함수는 값을 반환하며 종료되는데, 이때 **stack의 가장 위에 있는 프레임을 제거(pop)하면서 바로 아래에 저장된 리턴 주소를 확인**한다. 이 덕분에 수많은 함수 호출 속에서도 길을 잃지 않고 원래 위치로 돌아올 수 있게 된다.

\*Stack Overflow: 재귀가 너무 깊어지면(탈출 조건이 없거나 호출 횟수가 너무 많으면) 할당된 stack 메모리 용량을 초과하게 된다.

### 📌 [Q2] 함수 호출 스택(Call Stack)은 어떻게 동작하는가?

Call Stack은 프로그램이 함수를 실행할 때, **어떤 함수가 실행 중인지, 그 함수가 끝나면 어디로 돌아가야 하는지**를 기록하는 메모리 공간이다.
즉, **함수의 실행 컨텍스트(매개변수, 지역변수, 반환 주소 등)를 스택 프레임 단위의 LIFO 구조로 저장하고 관리하는 메모리 영역**이다. 함수 호출 시 반환 주소와 지역 변수가 push되고, 함수가 종료되면 pop되어 이전 실행 위치로 복귀한다.
동작은 크게 2단계로 나뉜다.

**1. 함수 호출(push)**

- 새로운 함수가 호출되면 현재 실행 중인 상태를 보존하고 그 위에 새로운 스택 프레임을 쌓는다.
  - ex) A() 안에서 B()를 호출하면 스택에는 A 위에 B가 놓이고, CPU는 가장 위에 있는 B()를 실행한다.

**2. 함수 종료(pop)**

- 함수가 return을 만나거나 실행이 완료되면 스택의 가장 위에 있는 프레임이 제거된다.
  - 제거되면서 프레임에 기록되어 있던 리턴 주소를 확인한다.

ex)

```
function greet() {
  sayHello();
  console.log("종료");
}

function sayHello() {
  console.log("안녕하세요!");
}

greet();
```

1. greet() 호출: 스택에 greet 프레임이 생성된다. (Push)
2. sayHello() 호출: greet 위에 sayHello 프레임이 쌓인다. (Push)
3. sayHello() 종료: 콘솔 출력 후 스택에서 제거된다. (Pop)
4. greet() 복귀: sayHello가 사라진 후, greet의 남은 부분(console.log("종료"))을 실행한다.
5. greet() 종료: 모든 작업이 끝나면 greet 프레임도 제거된다. (Pop)

\*왜 스택을 쓰는가?
: 재귀 함수는 호출 순서의 역순으로 종료되어야 하므로, 상태를 안전하게 저장 & 복구하기 위해서는 스택을 써야 안전하다.

### 📌 [Q3] 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?

스택 오버플로우는 **함수 호출 시 할당되는 스택 메모리의 한계치를 초과했을 때 발생하는 런타임 오류**이다.
**함수 호출이 과도하게 누적되어 제한된 스택 메모리를 초과할 때 발생**한다.
스택은 고정(제한)된 크기를 가지며, 무한히 확장되지 않는다. 함수가 호출될 때마다 실행 컨텍스트 정보가 스택에 push되는데, 이게 반복되면 스택 프레임이 계속 쌓여 제한 크기를 초과해 스택 오버플로우가 발생하는 것이다.

**발생하는 이유**

- 탈출(종료) 조건이 없는 재귀
- 너무 깊은 재귀 (탈출 조건은 있지만, 호출 횟수가 스택 메모리가 감당할 수 있는 수준을 초과한 경우)
- 너무 큰 지역 변수 (함수 내부에서 너무 큰 배열이나 객체 선언하면 하나의 스택 프레임이 너무 많은 공간을 차지해 금방 한계에 도달)
- 무한 루프

**스택 오버플로우가 위험한 이유**

- 프로그램 비정상 종료
- 세그멘테이션 오류(C/C++)
- Maximum call stack size exceeded (JS)

**방지하는 법**

- **재귀에 반드시 종료 조건(base case) 설정**
- **재귀 대신 반복문(iteration) 사용**
  - 대부분의 재귀 함수는 for나 while과 같은 반복문으로 변환이 가능하다. 반복문은 스택 메모리를 새로 할당하지 않고 동일한 메모리 공간 내에서 값만 변경하므로 스택 오버플로우로부터 안전하다.
- **꼬리 재귀 최적화(Tail Recurson / Tail Call Optimization, TCO)**
  - 함수의 마지막 동작이 자기 자신을 호출하는 것일 때, 컴파일러나 엔진이 새로운 스택 프레임을 쌓지 않고 기존 프레임을 재사용하도록 만드는 기법이다.
  - JS는 대부분의 엔진에서 이를 지원하지 않는다.

### 📌 [Q4] 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?

<details>
<summary>큐(Queue)</summary>
<div markdown="1">
• 삽입과 삭제가 한 곳(top)에서만 이루어지는 LIFO 구조의 스택과 달리, 배열의 양 끝에서 입력과 출력이 이루어진다. <br>
• 리스트의 앞에서는 삭제가, 뒤에서는 삽입이 이루어지는 FIFO 구조 <br>
• front: 데이터의 삭제 연산 (가장 먼저 들어온 데이터가 쌓이는 쪽) -> dequeue() 연산<br>
• rear: 데이터의 삽입 연산 (가장 나중에, 최근에 삽입된 데이터가 쌓이는 쪽) -> enqueue() 연산 <br>
</div>
</details>
<br />

<details>
<summary>선형 큐(Linear Queue)</summary>
<div markdown="1">
• 배열을 사용해 선형(일렬) 구조로 구현한 큐<br>
• front와 rear는 한 방향으로만 증가한다. <br>
• rear가 배열 끝에 도달하면 더 이상 삽입이 불가능하다.<br>
</div>
</details>
<br />

선형 큐는 배열 기반으로 구현할 때 다음과 같은 구조를 가진다.

```
[   ][   ][   ][   ][   ]
  ↑front          ↑rear
```

- enqueue -> rear 증가
- dequeue -> front 증가
  **! 문제는 dequeue를 하면 front만 이동하고 앞 공간은 재사용되지 않는다는 것이다. !**

```
[ x ][ x ][ x ][ 4 ][ 5 ]
          ↑front     ↑rear
```

앞의 공간은 비어있지만, rear가 배열 끝에 도달하면 더 이상 enqueue가 불가능하다. -> **공간 낭비**

이는 **원형 큐**를 통해 배열을 원형 구조로 사용하면 해결할 수 있다.
원형 큐는 배열의 마지막 인덱스 다음에 다시 첫 번째 인덱스로 연결되는 구조이다. (배열의 시작과 끝을 이어 붙여 원형처럼 관리)
만약 **rear가 배열 끝에 도달하면 `rear = (rear + 1) % size` 이렇게 나머지 연산자를 활용해서 앞 공간을 재사용**한다.

```
[ 4 ][ 5 ][   ][   ][   ]
  ↑rear
```

이렇게 원형 큐를 사용하면 dequeue로 인해 비워진 앞쪽 공간을 rear 포인터가 다시 돌아와 채울 수 있으므로 메모리 낭비를 해결하고, 시간복잡도도 O(1)로 유지할 수 있다.
(만약 dequeue 후 남은 요소를 앞으로 이동(shift)하는 방법을 쓴다면 O(N)의 시간복잡도를 가지므로 비효율적이다.)

**정리** <br>
선형 큐는 배열 기반으로 구현할 경우 dequeue 시 front만 증가하고 앞 공간은 재사용되지 않아 공간 낭비 문제가 발생한다. 이를 해결하기 위해 배열을 원형 구조로 사용하는 원형 큐를 적용하며, rear를 (rear + 1) % size 방식으로 순환시켜 앞 공간을 재사용한다. 이 방법은 시간 복잡도 O(1)을 유지하면서 공간을 효율적으로 활용할 수 있다.

### 📌 [Q5] 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?

**원형 큐에서 포인터(front, rear)의 이동은 모듈러 연산을 사용해 계산**한다.

공식: `(index + 1) % size` <br>
ex) size가 5이고 rear가 4에 있다면, [index: 0 1 2 3 4] -> (4 + 1) % 5 = 0

- enqueue 시 rear 이동
  - `rear = (rear + 1) % size`
  - rear 이동 후 해당 위치에 데이터 삽입

- dequeue 시 front 이동
  - `front = (front + 1) % size`
  - 현재 front 위치 데이터 제거 후 front 이동

- Empty 조건
  - `front == rear`

- Full 조건
  - `(rear + 1) % size == front`
  - rear의 다음 칸이 front일 때로, 한 칸을 제외하고 모두 채워진 상태

**정리** <br>
원형 큐는 배열을 원형처럼 사용하기 위해 포인터 이동 시 모듈러 연산을 사용한다.
rear와 front는 각각 `(index + 1) % size` 방식으로 이동하며, 이를 통해 배열 끝에 도달해도 처음으로 돌아가 공간을 재사용할 수 있다.
또한 `(rear + 1) % size == front`일 때 full로 판단한다.

### 📌 [Q6] 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

스택은 LIFO이고, 큐는 FIFO이다. 데이터를 한 스택에서 다른 스택으로 옮기면 순서가 뒤집히는데, 이를 활용하면 가능하다. (두 번 뒤집으면 원래 순서대로 돌아오는 원리 -> LIFO를 2번 뒤집으면 FIFO가 된다.) 즉, **스택 2개를 활용해서 순서를 2번 반전시키면 큐처럼 동작**하는 것이다.

2개의 스택을 각각 In-Stack(enqueue)과 Out-Stack(dequeue)으로 정의한다.

- 데이터 삽입(enqueue)
  - 새로운 데이터는 무조건 In-Stack에 push한다.
  - `inStack.push(x)`
  - 시간복잡도: O(1)

- 데이터 삭제(dequeue)
  - Out-Stack이 비어있는지 확인한다.
    - 만약 비어있다면, In-Stack에 있는 모든 요소를 하나씩 pop하여 Out-Stack에 push한다. (이 과정에서 순서가 뒤집혀 큐의 순서가 된다)
    ```
    while (!inStack.isEmpty()) {
    outStack.push(inStack.pop())
    }
    ```
  - Out-Stack의 최상단 요소를 pop한다. -> `outStack.pop()`
  - 시간복잡도:
    - 최악의 경우 (inStack의 모든 원소를 이동): O(N)
    - 하지만 각 원소는 (inStack -> outStack), (outStack -> pop) 딱 한 번씩만 이동하므로 **평균(amortized) 시간복잡도는 O(1)**
    - 왜냐하면 각 원소는 (inStack에 push 1번, outStack으로 이동 1번, outStack에서 pop 1번)으로 총 3번만 스택 연산을 거친다. n개의 연산 전체를 보면 총 비용은 O(N)이므로 평균적으로 한 연산 당 O(1)

**왜 FIFO가 되는가?** <br>
ex) enqueue 1, 2, 3

```
inStack: [1,2,3]
outStack: []
```

dequeue 시:

```
inStack → outStack로 이동
outStack: [3,2,1]
```

- 여기서 pop을 하면? stack이므로 1부터 반환된다. (가장 먼저 들어온 값이 나옴) => FIFO 완성!

**정리** <br>
스택 두 개를 사용하여 하나는 입력 전용, 다른 하나는 출력 전용으로 구성한다. enqueue는 입력 스택에 push하고, dequeue 시 출력 스택이 비어있으면 입력 스택의 모든 원소를 옮긴 뒤 pop한다. <br>
이 과정에서 각 원소는 최대 한 번만 이동하므로 dequeue의 최악의 시간복잡도는 O(N)이지만, 전체 연산을 기준으로 보면 amortized O(1)의 시간복잡도를 갖는다.

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

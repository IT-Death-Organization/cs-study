# Day 4: 스택(Stack)과 큐(Queue)
> 📅 2025.02.16 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 재귀 함수 호출이 스택을 사용하는 이유는?
- [x] 함수 호출 스택(Call Stack)은 어떻게 동작하는가?
- [x] 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?
- [x] 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?
- [x] 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?
- [x] 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

---

# 재귀 함수와 스택, 큐 자료구조 정리

## 1. 재귀 함수 호출이 스택을 사용하는 이유

### 핵심 이유
함수 호출은 **LIFO(Last In First Out)** 구조를 따르기 때문이다.

### 왜 LIFO인가?

재귀 예시:
```java
void f(int n) {
    if(n == 0) return;
    f(n-1);
}
```

호출 흐름:
```
f(3) → f(2) → f(1) → f(0)
```

복귀는 역순:
```
f(0) 종료 → f(1) 복귀 → f(2) 복귀 → f(3) 복귀
```

**마지막에 호출된 함수가 먼저 종료됨** → 정확히 스택 구조

---

### 스택에 저장되는 것

각 호출마다 **스택 프레임(Stack Frame)** 이 생성됨:
- 매개변수
- 지역 변수
- 반환 주소 (return address)
- 이전 프레임 포인터

---

## 2. 함수 호출 스택(Call Stack) 동작 방식

### ① 함수 호출 시
- 스택에 새로운 **스택 프레임 push**
- 프로그램 카운터(PC)는 호출된 함수로 이동

### ② 함수 종료 시
- 스택 프레임 pop
- return address로 복귀

---

### 실행 흐름 예시

```java
main() → A() → B()
```

스택 상태:
```
| B frame |
| A frame |
|  main   |
```

- B 종료 → pop
- A 종료 → pop
- main 종료

→ 항상 위에서 아래로 push / pop

---

## 3. 스택 오버플로우는 왜 발생하는가?

### 원인
스택 메모리는 **크기가 제한되어 있음**

재귀가 너무 깊어지면:
```
스택 프레임이 계속 push 됨
→ 스택 메모리 한계 초과
→ StackOverflowError
```

예시:
```java
void f() {
    f(); // 종료 조건 없음
}
```

무한 push → 터짐

---

### 언제 자주 발생?
- 종료 조건 없는 재귀
- 깊은 DFS (그래프 10만 depth)
- 큰 지역 배열 선언

---

### 방지 방법
1. 반드시 **base condition 작성**
2. 반복문으로 변경 (tail recursion 제거)
3. 스택 크기 증가 (실무에서는 비추천)
4. DFS → BFS로 전환

---

## 4. 선형 큐에서 dequeue 후 공간 낭비 문제

### 선형 큐 문제

배열 기반 큐:
```
[1][2][3][ ][ ]
 ↑
front
```

dequeue 하면:
```
[ ][2][3][ ][ ]
    ↑
   front
```

- 앞쪽 공간은 다시 못 씀
- 계속 enqueue하면 rear가 배열 끝에 도달 → overflow
- 실제로는 공간 남아있는데 못 씀

---

### 해결 방법: 원형 큐 (Circular Queue)

배열을 원형처럼 사용한다.

---

## 5. 원형 큐의 포인터 이동 공식

배열 크기 = N

### enqueue
```
rear = (rear + 1) % N
```

### dequeue
```
front = (front + 1) % N
```

---

### 왜 % N 인가?

배열 끝에서:
```
rear = N-1
```

enqueue 시:
```
rear = (N-1 + 1) % N = N % N = 0
```

→ 다시 맨 앞으로 이동

---

### Full 조건

**방법 1:**
```
(rear + 1) % N == front
```

**방법 2:** size 변수 따로 관리

---

## 6. 스택 2개로 큐 구현하기

### 1) 아이디어 한 줄
- 스택은 LIFO
- 큐는 FIFO
- → **스택 2개로 한 번 뒤집고(이동), 또 뒤집지 않고 그대로 꺼내면 FIFO가 된다**

---

### 2) 구성

- `inStack` : enqueue(삽입) 전용
- `outStack`: dequeue(삭제) 전용

**규칙:**
- **enqueue는 무조건 inStack에 push**
- **dequeue는 outStack에서 pop**
- outStack이 비었는데 dequeue해야 하면 inStack의 모든 원소를 outStack으로 옮긴다(=역순 뒤집기)

---

### 3) 동작 자세히

#### enqueue(x)
1. `inStack.push(x)`
   - 언제나 O(1)

---

#### dequeue()

케이스를 나눔.

**Case A: outStack이 비어있지 않다**
- `return outStack.pop()`
- O(1)

**Case B: outStack이 비어있다**
1. inStack이 비어있으면 → 큐도 비어있음 (underflow)
2. 아니면 `while(!inStack.empty()) outStack.push(inStack.pop())`
3. 그 다음 `return outStack.pop()`
   - 이 "이동"이 FIFO를 만드는 핵심

---

### 4) 왜 FIFO가 되냐? (직관 예시)

순서대로 enqueue: 1, 2, 3

#### (1) enqueue만 했을 때
- inStack(top이 오른쪽): `[1, 2, 3(top)]`
- outStack: `[]`

이 상태에서 dequeue를 하려면 outStack이 비어있으니까 이동:

#### (2) in → out로 전부 이동
- in에서 pop되는 순서: 3, 2, 1
- out에 push되면 out(top): 1이 됨
- outStack: `[3, 2, 1(top)]` (즉 top이 1)
- 이제 dequeue하면 outStack.pop() → 1 → **가장 먼저 들어온 1이 먼저 나감 (FIFO)**
- 그 다음 dequeue → 2 → 3

#### (3) 이후 enqueue가 더 들어오면?

예: 4, 5 enqueue하면
- inStack: `[4, 5(top)]`
- outStack에는 아직 남은 게 있으면 계속 out에서 pop만 한다
- out이 다 비면 그때 in의 것들을 한 번에 옮겨서 다시 FIFO 유지

---

### 5) 시간복잡도 (핵심: amortized)

#### 최악 시간 (Worst-case)
- outStack이 비었을 때 dequeue하면 inStack의 원소 n개를 한꺼번에 이동 → **O(n)**

#### 평균/분할상환 (Amortized)

중요한 관찰:
> 각 원소는 inStack에 **1번 push**되고,  
> outStack으로 **최대 1번 이동**되고,  
> outStack에서 **1번 pop**된다.

즉 원소 하나당 연산 수는 상수(대략 3번)로 제한됨.

그래서 m번 연산 전체로 보면 총 비용이 O(m)  
→ **연산 1번당 평균 O(1)**

**정리:**
- enqueue: O(1)
- dequeue: **amortized O(1)** (worst는 O(n))

---

### 6) peek(맨 앞 보기)도 같은 원리

- outStack이 비었으면 이동 수행
- 그 후 outStack.peek()

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 4: 스택(Stack)과 큐(Queue)
> 📅 2025.02.16 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 재귀 함수 호출이 스택을 사용하는 이유는?
- [x] 함수 호출 스택(Call Stack)은 어떻게 동작하는가?
- [x] 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?
- [x] 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?
- [x] 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?
- [x] 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

---

## Q1. 재귀 함수 호출이 스택을 사용하는 이유는?

[답변]
재귀 함수는 호출 당한 함수가 호출한 함수보다 먼저 반환되므로, 먼저 호출된 함수가 나중에 반환되는 전형적인 LIFO의 구조를 따르기 때문이다.

[정리]
각 호출의 반환 주소와 지역변수 상태를 저장 -> 더 깊은 호출이 먼저 반환될 때 역순으로 복원
=> LIFO 구조인 호출 스택을 사용

---

## Q2. 함수 호출 스택(Call Stack)은 어떻게 동작하는가?

[답변]
1. 함수 호출 -> 스택 프레임이 스택에 push
2. 해당 함수가 다른 함수를 호출하면 호출된 함수 프레임에 반환 주소/상태 저장
3. 호출된 함수 push 후 실행
4. 호출된 함수 return -> 해당 프레임 pop
5. 저장한 반환 주소로 돌아가 호출 지점 다음부터 실행 재개

[보완]
* 스택 프레임
    - 함수 호출 1회에 대해 생성되는 실행 정보 묶음
    - 반환 주소: 함수 종료 후 돌아갈 코드 위치. 호출 다음 줄 주소
    - 매개변수
    - 지역변수
    - 저장 레지스터
    - 이전 프레임 포인터

* 함수 호출 시 일어나는 일
    - 호출자
        - 전달할 인자 준비
        - call: 반환 주소 저장 및 점프
    - 제어 흐름 이동: 시작 지점으로 이동
    - 스택 프레임 생성(프롤로그)
        - 필요 시 FP(이전 스택 프레임 포인터) 저장: SP만으로 계산할 수도 있음
        - 지역 변수 공간 확보: SP(스택 포인터) 이동
    - 지역 변수 초기화: 메모리에 할당

* 함수 반환 시 일어나는 일
    - 반환 값 준비: 특정 레지스터/메모리 위치에 저장
    - 스택 프레임 제거(에필로그)
        - FP 사용 했을 시 복구
        - SP 복구: 지역 변수 해제
    - 제어 흐름 복귀: 반환 주소로 복귀
    - 반환 값 전달

* FP는 보통 cpu 레지스터에 저장하므로 '호출자 함수의 FP'를 스택에 저장해야 함

---

## Q3. 스택 오버플로우는 왜 발생하며 어떻게 방지하는가?

[답변]
* 발생 원인: 호출 스택이 한도를 넘음
    - 무한 재귀/종료 조건 오류: 프레임이 계속 push
    - 재귀/호출 깊이가 너무 깊음: 정상 종료가 있으나 입력 크기가 커 최대 깊이 초과
    - 스택 프레임이 너무 큼: 함수 내의 큰 지역 배열/구조체 또는 큰 객체 존재
    - 스레드 스택이 작은 환경: 스레드별 스택 크기 제한이 작음
* 방지
    - 재귀 종료 조건을 명확히 함
    - 반복문으로 변환
    - 큰 데이터는 힙에 할당
    - 스택 크기 조정: 스레드 생성 시 스택 크기 옵션 설정

[보완]
반복문은 '호출 스택'이 깊어지진 않으므로 스택 오버플로우보단 힙/메모리 부족, 시간초과/무한 루프의 원인이 될 가능성이 더 높음

---

## Q4. 선형 큐에서 dequeue 후 공간이 낭비되는 문제를 어떻게 해결하는가?

[답변]
1. 원형 큐: mod N 사용
    - front = (front + 1) % N
    - rear = (rear + 1) % N
2. 남은 원소 shift
    - dequeue 후 남은 원소를 앞으로 한 칸씩 이동 -> front 0으로 맞춤
    - 비효율적
3. 연결 리스트 큐
    - 배열 대신 연결 리스트로 큐 구현
    - 메모리 관리 필요

[보완]
* 선형 큐
    - 선형 메모리인 배열로 큐를 구현한 형태
    - front, rear가 한 방향으로만 증가하여 앞쪽 빈 공간을 재사용하지 못할 수 있는 큐
    - front, rear
    - enqueue, dequeue

---

## Q5. 원형 큐(Circular Queue)의 포인터 이동은 어떻게 계산하는가?

[답변]
* idx = (idx + 1) % N
    - front = (front + 1) % N
    - rear = (rear + 1) % N

---

## Q6. 스택 2개로 큐를 구현하려면 어떻게 해야 하는가? 시간복잡도는?

[답변]
입력 스택과 출력 스택을 분리하여, 출력이 필요한 경우 입력 스택에서 출력 스택으로 옮긴다. 이때 입력 스택에서 역순으로 pop되므로, 출력 스택으로 옮긴 후엔 순서대로 pop한다. 이후 push는 입력 스택으로 계속 받고, 출력 스택이 빈 후에 다시 옮기는 과정을 반복한다.

* 시간 복잡도
    - enqueue: O(1)
    - dequeue: O(N)
        - amortized: O(1)
        - 최악의 경우 원소를 모두 출력 스택으로 옮겨야 한다. 각 원소는 최대 1번만 이동한다.

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 5: 데이터베이스 기초 (RDBMS vs NoSQL)
> 📅 2025.02.17 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 데이터베이스가 파일 시스템보다 나은 이유는?
- [x] RDBMS와 NoSQL의 차이는? 각각의 장단점은?
- [x] RDBMS는 언제 사용하고, NoSQL은 언제 사용하는가?
- [x] CAP 이론이란 무엇인가? (일관성, 가용성, 분할 내성)
- [x] NoSQL의 종류(Key-Value, Document, Column-Family, Graph)와 차이는?
- [x] 스키마가 있는 것과 없는 것의 장단점은?

---

# 1. 데이터베이스가 파일 시스템보다 나은 이유

## 파일 시스템의 한계

- 데이터 중복 발생
- 동시성 제어 없음
- 무결성 보장 어려움
- 검색/조인 불편
- 트랜잭션 개념 없음
- 장애 복구 어려움

## DBMS가 제공하는 것

| 기능 | 설명 |
|------|------|
| 동시성 제어 | Lock, MVCC |
| 트랜잭션 | ACID 보장 |
| 무결성 | PK, FK, 제약조건 |
| 인덱스 | 빠른 검색 |
| 백업/복구 | WAL, Redo/Undo |
| 쿼리 최적화 | 실행 계획 수립 |

> **데이터의 일관성과 안정성을 보장해야 하면 DBMS가 필수**

---

# 2. RDBMS vs NoSQL

## RDBMS (관계형 DB)

예시: MySQL, PostgreSQL, Oracle Database

**특징**

- 테이블 기반
- 스키마 고정
- SQL 사용
- ACID 트랜잭션 보장
- JOIN 가능

## NoSQL

예시: MongoDB, Redis, Cassandra

**특징**

- 비정형 데이터
- 스키마 유연
- 수평 확장 용이
- JOIN 거의 없음
- BASE 모델

## 핵심 차이

| 구분 | RDBMS | NoSQL |
|------|-------|-------|
| 스키마 | 고정 | 유동적 |
| 트랜잭션 | 강한 ACID | 약하거나 없음 |
| 확장성 | 수직 확장 | 수평 확장 |
| 데이터 구조 | 정형 | 반정형/비정형 |
| JOIN | 가능 | 거의 없음 |

---

# 3. BASE 모델

> 분산 시스템에서 **가용성과 확장성을 우선**하기 위한 데이터 일관성 모델

BASE = **B**asically Available + **S**oft State + **E**ventually Consistent

## 등장 배경

RDBMS는 ACID 기반으로 강한 일관성과 트랜잭션을 보장하지만, 대규모 분산 환경에서는 네트워크 분할 발생, 노드 수십~수백 대, 트래픽 폭증 등의 상황으로 인해 ACID를 그대로 유지하면 성능이 급격히 저하된다.

대표 예시: Cassandra, MongoDB (설정에 따라)

## BASE 구성 요소

### Basically Available

시스템은 항상 응답한다. 일부 노드가 죽어도 서비스는 계속 동작한다.

- 예: 3개 노드 중 1개 죽어도 읽기/쓰기 가능
- 가용성 우선

### Soft State

데이터 상태가 일시적으로 일관되지 않을 수 있다. 잠깐 서로 다른 값이 보일 수 있으며, 동기화 과정 중일 수 있다.

### Eventually Consistent

시간이 지나면 결국 일관성이 맞춰진다.

- 예: A 서버에 데이터 쓰기 → B 서버에는 아직 반영 안됨 → 잠시 후 동기화 완료

## ACID vs BASE 비교

| 항목 | ACID | BASE |
|------|------|------|
| 일관성 | 즉시 일관성 | 최종 일관성 |
| 가용성 | 일부 제한 가능 | 항상 응답 |
| 확장성 | 상대적으로 낮음 | 매우 높음 |
| 트랜잭션 | 강함 | 약함 |

---

# 4. 언제 RDBMS? 언제 NoSQL?

## RDBMS 사용하는 경우

- 금융 시스템
- 주문/결제
- 재고 관리
- 강한 일관성 필요
- 복잡한 JOIN 많음

> 예: 은행 계좌 이체

## NoSQL 사용하는 경우

- 로그 저장
- 채팅 시스템
- 세션 저장
- 캐시
- 대규모 트래픽

> 예: 실시간 피드, 대규모 이벤트 로그

---

# 5. CAP 이론

CAP = 분산 시스템의 세 가지 특성

| 항목 | 의미 |
|------|------|
| C (Consistency) | 모든 노드가 같은 데이터 |
| A (Availability) | 항상 응답 가능 |
| P (Partition Tolerance) | 네트워크 분할 상황에서도 동작 |

- **C (Consistency, 일관성)**: 어떤 노드에서 읽어도 방금 커밋된 최신 값을 보게 함
- **A (Availability, 가용성)**: 요청을 받으면 항상 정상 응답을 돌려줌 (대신 최신이 아닐 수도 있음)
- **P (Partition Tolerance, 분할 내성)**: 네트워크가 갈라져도 시스템이 계속 동작하도록 설계됨

> **Partition(네트워크 분할)이 발생하면, C와 A를 동시에 100% 보장할 수 없다.**

## CP vs AP (분할 발생 시)

### CP 시스템 (Consistency + Partition Tolerance)

분할이 나면 일관성을 지키기 위해 일부 요청을 실패/대기시킨다.

- "최신이 보장되지 않으면 차라리 에러(또는 대기)"
- 결과: 가용성 희생(일부 요청 타임아웃/에러), 대신 데이터 불일치 최소화
- 패턴: 리더(Primary)와 다수(majority) 합의를 못 하면 쓰기/읽기를 제한함

### AP 시스템 (Availability + Partition Tolerance)

분할이 나도 일단 응답을 계속한다.

- "최신이 아닐 수 있어도 일단 서비스는 살아있게"
- 결과: 가용성 확보, 대신 일시적 불일치 발생 가능
- 이후 분할이 회복되면 동기화/충돌 해결로 맞춤 (최종 일관성)

| 구분 | 우선순위 | 예시 |
|------|----------|------|
| CP 시스템 | 일관성 우선 | MongoDB (일부 설정) |
| AP 시스템 | 가용성 우선 | Cassandra |

---

# 6. NoSQL 종류와 차이

## Key-Value

예시: Redis

```
key → value
```

- 매우 빠름
- 캐시/세션 저장에 적합
- 복잡한 조회 불가

## Document

예시: MongoDB

```
JSON 문서 단위 저장
```

- 유연한 스키마
- 객체 저장에 적합
- JOIN 약함

## Column-Family

예시: Cassandra

- 대규모 분산 처리
- 쓰기 성능 좋음
- 복잡한 트랜잭션 어려움

### Column-Family 구조

관계형처럼 "행 중심"이 아니라 **컬럼 그룹(Column Family) 단위로 저장**하는 모델이다.

```
RowKey → { Column1, Column2, Column3... }
```

- Row Key 기반 접근
- 같은 Row Key에 속한 데이터는 물리적으로 함께 저장

### 대규모 분산 처리에 강한 이유

**Shared-Nothing 구조**

각 노드는 독립 CPU, 독립 메모리, 독립 디스크를 가진다. 중앙 병목이 없다.

**Key 기반 파티셔닝**

데이터는 해시 기반으로 분산된다.

```
partition_key → hash → 노드 결정
```

노드를 추가하면 자동 재분산된다. 수평 확장이 매우 쉽다.

**JOIN 없음**

RDB처럼 `users JOIN orders` 방식 대신, 주문 데이터를 사용자 기준으로 함께 저장한다(비정규화 전략). 네트워크 JOIN 비용이 제거된다.

### 쓰기 성능이 좋은 이유

Cassandra는 **LSM-Tree 기반** 저장 구조를 사용한다.

**쓰기 과정:**

1. Commit Log 기록
2. MemTable(메모리)에 기록
3. 나중에 SSTable로 flush

랜덤 디스크 쓰기가 거의 없고 대부분 append-only 방식이다.

> 디스크에 "덮어쓰기" 대신 "추가 기록"

### 복잡한 트랜잭션이 어려운 이유

- JOIN이 없어 테이블 간 관계 기반 트랜잭션이 어렵다.
- 여러 노드에 데이터가 분산되어 있어 강한 ACID 트랜잭션을 위해서는 분산 락, 2PC가 필요하고 성능이 급락한다.

## Graph

예시: Neo4j

- 관계 중심 데이터에 최적
- SNS, 추천 시스템 적합
- 대규모 단순 조회엔 비효율

---

# 7. 스키마 있는 것 vs 없는 것

## 스키마 있음 (RDBMS)

**장점**

- 데이터 구조 명확
- 무결성 보장
- 협업 시 안정적

**단점**

- 변경 어려움
- 유연성 낮음

## 스키마 없음 (NoSQL)

**장점**

- 빠른 개발
- 유연한 구조
- 다양한 형태 저장 가능

**단점**

- 데이터 품질 불균형 가능
- 구조 관리 어려움

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

# Day 5: 데이터베이스 기초 (RDBMS vs NoSQL)
> 📅 2025.02.17 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 데이터베이스가 파일 시스템보다 나은 이유는?
- [x] RDBMS와 NoSQL의 차이는? 각각의 장단점은?
- [x] RDBMS는 언제 사용하고, NoSQL은 언제 사용하는가?
- [x] CAP 이론이란 무엇인가? (일관성, 가용성, 분할 내성)
- [x] NoSQL의 종류(Key-Value, Document, Column-Family, Graph)와 차이는?
- [x] 스키마가 있는 것과 없는 것의 장단점은?

---

## Q1. 데이터베이스가 파일 시스템보다 나은 이유는?

[답변]
1. 데이터 무결성 보장
    - 제약 조건 제공: PK, FK, NOT NULL 등
    - 규칙 위반하는 데이터의 입력/수정 차단
2. 데이터 독립성
    - 응용 프로그램이 데이터의 물리적 저장 방식이나 논리적 구조에 덜 의존함
    - 파일 시스템에선 파싱/직렬화를 직접하기 때문에, 데이터 구조에 변경이 생기면 코드 변경이 많음
3. 데이터 중복 최소화
    - 파생 파일(분석, 로그용)와 같이 같은 데이터에 대한 파일이 여러 개 있을 시, 동기화 부담과 불일치 위험이 커짐
4. 보안
    - 파일 시스템은 파일 자체에 대한 권한만 관리할 수 있는 반면, DBMS는 사용자/역할 기반 권한, 객체(테이블/뷰/프로시저) 단위 권한 등 다양한 보안 기능을 제공
    - ex. 특정 테이블은 읽기 전용, 특정 역할은 조회(SELECT)만 가능 등
5. 동시성 제어
    - 트랜잭션 격리 수준, 락, MVCC 등 제공
6. 트랜젝션 지원
    - ACID(원자성/일관성/격리성/지속성)를 보장하는 트랜잭션 지원해 데이터 손상 위험을 줄임

[보완]
* 무결성: 데이터가 정해진 규칙을 항상 만족해 정확하고 일관된 상태로 유지되는 성질
* 트랜잭션 격리 수준: 여러 트랜잭션이 동시에 실행될 때, 서로의 '중간 처리 결과'를 노출할지 정하는 규칙
    - 동시성과 일관성 사이의 타협
    - 세 가지 문제점
        1. 더티 리드: 트랜잭션 A가 아직 커밋하지 않은 값을 트랜잭션 B가 읽음 -> A가 롤백하면 B는 존재하지 않은 값을 읽은 게. ㅚㅁ
        2. 반복 불가능 읽기: B가 같은 행을 두 번 읽었는데, 그 사이 A가 커밋 -> 같은 조회를 다시 했는데 결과가 달라짐
        3. 팬텀 리드: B가 조건으로 여러 행 조회했는데 그 사이에 A가 새 행 삽입/삭제 후 커밋 -> 같은 조건으로 조회 다시 하면 행 개수 바뀜
    - 격리 수준
        1. READ UNCOMMITTED: 커밋 안 된 것도 읽을 수 있음
            - 빠르지만 더티 리드 발생 가능
        2. READ COMMITTED: 커밋된 것만 읽을 수 있음
            - 더티 리드 방지하지만, 반복 불가능 읽기, 팬텀 리드는 발생 가능
            - 많은 db의 기본값
        3. REPEATABLE READ: 한 트랜잭션 안에서 같은 행을 다시 읽으면 항상 같은 값이 보이도록 보장
            - 더티 리드 방지 + 반복 불가능 읽기 방지
            - 팬텀 리드는 db 구현에 따라 가능/불가능
        4. SERIALIZABLE: 동시에 실행되는 트랜잭션을 '순서대로 하나씩 실행'한 것처럼 보이게 함
            - 가장 안전
            - 충돌/대기/실패 가능성이 커져 성능 비용이 큼라
* 락: 여러 트랜잭션이 동시에 같은 데이터에 접근할 때 충돌을 막기 위해 dbms가 거는 '잠금'. 락이 걸리면 다른 트랜잭션의 읽기/쓰기 방식이 제한됨
    1. 공유 락: 읽기용 락. 동시 읽기 허용
    2. 배타 락: 쓰기용 락. 읽기 제한 가능
* MVCC: Multi-Version Concurrency Control. 한 데이터에 대한 여러 버전 관리. 락과 달리, 한 트랜잭션이 수정 중이면 기다리지 않고 이전 버전을 읽음
* ACID
 - Atomicity: 원자성. 트랜잭션은 전부 성공하거나 전부 실패
 - Consistency: 일관성. 트랜잭션 전후의 데이터가 무결성 규칙을 만족
 - Isolation: 격리성. 동시 실행 트랜잭션들이 서로 간섭하지 않음. 정도는 격리 수준으로 조절
 - Durability: 지속성. 트랜잭션이 커밋되면, 결과는 장애가 나도 유지됨

---

## Q2. RDBMS와 NoSQL의 차이는? 각각의 장단점은?

[답변]
* RDBMS: 데이터를 테이블 구조로 저장. 테이블 간의 '관계'를 PK/FK로 표현하며, SQL로 질의함.
    - 장점
        1. 강한 일관성과 트랜잭션
        2. 정교한 질의와 표준 SQL
        3. 데이터 품질 관리: 무결성 제약으로 잘못된 데이터 입력 차단 용이
    - 단점
        1. 스키마 변경 비용
        2. 초대규모 수평 확장 난이도: 가능은 하나, 설계/운영 난도가 증가함
* NoSQL: 정해진 스키마에 덜 얽매이며 Scale-out에 유리하도록 설계됨.
    - 장점
        1. 유연한 스키마: 같은 테이블 내에서도 필드가 다를 수 있어 요구사항 변경에 빠르게 대응 가능
        2. 수평 확장, 고성능 처리에 유리: 분산 환경에 유리
        3. 데이터 모델 선택 폭
    - 단점
        1. 질의가 제한적 -> 중복 저장 발생 가능
        2. 표준이 분산: 단일 표준이 약해 제품별 학습 비용 발생

[보완]
* NoSQL이 Scale-oout에 유리한 이유: 조인에 덜 얽매이기 때문에, 노드 간 통신을 줄일 수 있음

---

## Q3. RDBMS는 언제 사용하고, NoSQL은 언제 사용하는가?

[답변]
* RDBMS 사용
    - 데이터 간의 관걔가 많고, 복잡한 조회가 필요할 떄
    - 정확한 트랜잭션이 중요할 때
    - 데이터 품질이 강하게 보장돼야 할 때
* NoSQL 사용
    - 데이터 구조가 자주 바뀔 때 (유연한 스키마 필요)
    - 대규모 트래픽을 여러 서버로 수평 확장해야 할 때
    - 조인보다 단일 키 단위 조회가 대부분일 때

---

## Q4. CAP 이론이란 무엇인가? (일관성, 가용성, 분할 내성)

[답변]
분산 시스템에서 Consistency, Availability, Partion 세 가지 특성을 동시에 모두 완벽히 만족할 수 없음 -> 두 가지를 선택
    - 특히 Partition이 발생하면 Consistency와 Availability 중 하나를 선택해야 함
* Consistency: 일관성. 어떤 노드에 읽기 요청을 하더라도 항상 최신(같은) 값을 읽는 성질
* Availability: 가용성. 일부 노드에 장애가 있더라도 시스템이 항상 응답을 반환하는 성질
* Partion Tolerance: 분할 내성. 노드 간 네트워크가 끊겨 서로 통신이 불가능한 분할 상황에서도 시스템이 동작을 계속하는 성질

---

## Q5. NoSQL의 종류(Key-Value, Document, Column-Family, Graph)와 차이는?

[답변]
1. Key-Value DB
    - 구조: key → value (값은 문자열/바이너리/JSON 등 덩어리)
    - 장점: 단순하고 매우 빠름(캐시/세션에 강함), 수평 확장 용이
    - 단점: key 기반 조회 외에 복잡한 검색/조인이 약함
    - 주용도 ex. 세션 저장, 캐시, 토큰/인증 정보, 랭킹/카운터(제품 기능에 따라)
2. Document DB
    - 구조: JSON/BSON 같은 문서(document) 단위로 저장(필드가 유연)
    - 장점: 애플리케이션 객체(JSON)와 구조가 잘 맞고 스키마 변경에 유연, 문서 단위 조회/갱신에 강함
    - 단점: 관계형 조인/다중 테이블 조합 질의가 제한적이어서 중복 저장(denormalization) 설계가 흔함
    - 주용도 ex. 사용자 프로필/설정, 콘텐츠(게시글 등), 이벤트 데이터
3. Column-Family(Wide-Column) DB
    - 구조: “행(row)”이 있지만, 컬럼이 고정되지 않고 컬럼 패밀리 중심으로 매우 넓게 확장 가능
    - 장점: 대규모 분산 저장에 강하고, 쓰기/대량 데이터 처리(로그 등)에 유리한 경우가 많음
    - 단점: 쿼리 패턴을 미리 고려한 설계가 필요(모델링 난도↑), 즉흥적 조인/임의 질의에 약함
    - 주용도 ex. 로그/타임시리즈성 데이터, 대규모 이벤트/분석 전 단계 저장
4. Graph DB
    - 구조: 노드(정점)와 엣지(관계)로 저장
    - 장점: 친구 관계, 추천, 경로 탐색처럼 관계 탐색(Traversal)이 빠르고 직관적
    - 단점: 단순 키 조회나 대량 집계에 최적이 아닐 수 있고, 용도 특화 성격이 강함
    - 주용도 ex. SNS 관계, 추천 시스템, 지식 그래프, 사기 탐지(연결 관계 분석)

---

## Q6. 스키마가 있는 것과 없는 것의 장단점은?

[답변]
* 스키마 O
    - 장점
        1. 무결성/품질 관리 용이
        2. 구조가 명확 -> 협업/운영에 유리
        3. 복잡한 질의를 일관된 모델로 처리 가능
    - 단점
        1. 요구사항 변경 -> 스키마 변경 필요: 변경 비용 발생
        2. 초기 설계 부정확 -> 변경 부담
* 스키마 X
    - 장점
        1. 필드 추가/변경 자유로움 -> 빠른 개발 유리
        2. 데이터가 다양하거나 불규칙할 때 저장이 쉬움
    - 단점
        1. 데이터 품질 관리 어려움: 데이터 형태가 제각각이 될 수 있음
        2. 어떤 문서가 어떤 필드를 가질지 불명확해져 유지보수 비용이 증가
        3. 검증 로직이 DB가 아닌 애플리케이션 쪽에 집중되기 쉬움

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

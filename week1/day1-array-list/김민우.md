# Day 1: 배열(Array)과 리스트(List)
> 📅 2025.02.13 | 📁 Week 1

---

## 🧠 학습 질문

- [x] 배열의 접근이 O(1)인 이유를 메모리 주소 계산 관점에서 설명하면?
- [x] 배열의 중간 삽입/삭제가 O(n)인 이유는?
- [x] 동적 배열이 크기가 가득 찼을 때 2배로 확장하는 이유는?
- [x] 재할당 시 기존 요소들을 복사하는데 왜 amortized O(1)이 되는가?
- [x] Cache locality 관점에서 배열이 연결 리스트보다 유리한 이유는?
- [x] 연결 리스트와 배열 중 어떤 상황에서 무엇을 선택해야 하는가?

<br>

# 1. 배열의 접근이 O(1)인 이유 (메모리 주소 계산 관점)

배열은 **연속된 메모리 공간(contiguous memory)** 에 저장된다.

### 핵심 공식

배열의 i번째 원소 주소

```sql
address=base address+(i×element size)
```

예시)

- base address = 1000
- int = 4 bytes
- arr[3]

→ 1000 + (3 × 4) = 1012

### 왜 O(1)인가?

CPU는

1. base 주소를 알고
2. 인덱스 i만 있으면
3. 곱셈 1번 + 덧셈 1번으로 바로 계산 가능

**탐색 과정이 없다.**

앞에서부터 순회하지 않는다. 주소를 계산한다.

그래서 시간복잡도는 O(1), 연산 횟수가 데이터 크기 n과 무관하다.

---

# 2. 배열의 중간 삽입/삭제가 O(n)인 이유

배열은 빈 공간이 중간에 존재할 수 없다. 항상 연속되어 있어야 한다.

예시

```
[1, 2, 3, 4, 5]
```

3을 삭제하면

```
[1, 2, 4, 5, ?]
```

이때 4, 5를 한 칸씩 앞으로 당겨야 한다.

### 이동 횟수

최악의 경우는 n-1개 이동 즉, O(n)이다.

삽입도 동일하다. 중간에 넣으려면 뒤 원소들을 전부 한 칸씩 밀어야 한다.

---

# 3. 동적 배열이 가득 찼을 때 2배 확장하는 이유

예시)

capacity = 8

size = 8

이제 하나 더 넣으면?

→ 새 배열 생성

→ 기존 8개 복사

### 왜 2배로 늘리는가?

만약 1칸씩 늘린다면?

```sql
1 → 2 → 3 → 4 → … → n
```

복사 횟수

```sql
1 + 2 + 3 + … + n -> 확장 횟수가 n, 등차 수열 합 공식으로 n(n+1)/2 -> O(n^2)
```

### 2배로 늘리면

```sql
1 → 2 → 4 → 8 → 16 → 32 … -> 확장 횟수가 log n, 등비 수열 합 공식으로 1*(2^logn -1)/(2-1) -> O(n)
```

그래서 총 비용이 선형으로 줄어든다. 2배 확장은 시간-공간 trade-off의 최적 지점이다.

---

# 4. 재할당 시 복사하는데 왜 amortized O(1)?

**amortized = 평균 비용을 여러 연산에 나눠서 계산한 시간복잡도**

왜 append는 amortized O(1) 인가?

```sql
총 n번의 연산을 수행했고 전체 비용이 T(n)이라면 amortized cost =  𝑇(𝑛) / 𝑛
```

### 평소

```sql
arr.add(x) -> O(1)
```

### 최악의 경우(복사가 발생된다면)

```sql
2배 확장이라면, 1 → 2 → 4 → 8 → 16 → 32 -> 발생 비용 O(n)
전체 비용 = n*O(1) + O(n) = O(n)
```

### 평균 비용

```sql
O(n)/n=O(1)
```

---

# 5. Cache locality 관점에서 배열이 연결 리스트보다 유리한 이유

CPU는 메모리를 한 번에 블록 단위로 가져온다. 이를 **cache line**이라 한다. (보통 64 bytes)

### 배열

연속 저장

```
[1][2][3][4][5][6][7][8]
```

1을 읽으면 2~8도 같이 캐시에 올라온다.

→ 다음 접근은 캐시 히트

### 연결 리스트

```
1 → 7 → 2 → 9 → 3 → ...
```

각 노드는 메모리 여기저기 흩어져 있음

→ 매번 메모리 접근해서, cache miss 발생

그래서 실제 성능은 배열 > 연결 리스트

**(이론적 시간복잡도 같아도 실제는 다름)**

---

# 6. 언제 배열 vs 연결 리스트 선택?

### 배열이 좋은 경우

- 랜덤 접근 많을 때 → 인덱스만 있으면 바로 주소 계산 가능
- 순회가 많을 때 → 배열은 메모리 연속 저장이기 때문에 캐시 히트됨.
- cache 효율 중요할 때
- 메모리 오버헤드 줄이고 싶을 때

**왜 메모리 오버헤드가 적은가**

**배열**

```
[데이터][데이터][데이터][데이터] -> 4bytes
```

**연결 리스트**

각 노드 구조

```
[데이터 | next 포인터] -> 4bytes data + 8bytes pointer = 12 bytes
```

예: 그래프 인접 행렬, DP, 슬라이딩 윈도우, 정렬

### 연결 리스트가 좋은 경우

- 삽입/삭제가 매우 빈번
- 특히 맨 앞에서 삽입 많을 때
- 크기를 예측하기 어려울 때

하지만 현실적으로는 Java, C++ STL에서는 대부분 배열 기반 컨테이너(vector, ArrayList)가 더 빠르다.

왜냐하면 CPU cache 영향이 훨씬 크기 때문.


---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

# Java 객체 메모리 구조

Java에서 객체 하나는 메모리에서 이렇게 생겼다

```
[ Object Header | Instance Data | Padding ]
```

---

### 1. Object Header (객체 헤더)

모든 Java 객체는 **무조건** 헤더가 붙는다.

보통 12~16 bytes 정도 (JVM 옵션에 따라 다름)

헤더에는 이런 정보가 들어있다.

| 구성 | 설명 |
| --- | --- |
| Mark Word | hashcode, GC 정보, lock 상태 |
| Class Pointer | 어떤 클래스 객체인지 |

즉 JVM이 객체를 관리하기 위한 메타데이터다.

### 2. Instance Data (실제 필드 값)

예:

```java
class Node {
    int value;
    Node next;
}
```

필드 메모리:

```
int value → 4 bytes
Node next → 8 bytes (64bit JVM 기준)
```

→ 총 12 bytes

---

### 3. Pointer (참조 변수)

Java에서 객체 변수는 **값이 아니라 주소**를 저장한다.

```
Node a = new Node();
-> a 변수 안에는 Node 객체의 주소값(포인터)
```

---

### 4.Padding (정렬 맞추기용)

JVM은 객체 크기를 **8바이트 배수**로 맞춘다.

그래서 남는 공간 있으면 채운다.

예시

```
총 28 bytes → 32 bytes로 패딩
```

---

### 실제 LinkedList Node 메모리 계산

Node 구조:

```
class Node {
    int value;
    Node next;
}
```

64bit JVM 기준:

| 구성 | 크기 |
| --- | --- |
| Object Header | 16 bytes |
| int | 4 bytes |
| pointer | 8 bytes |
| padding | 4 bytes |
| 합계 | **32 bytes** |

---

## int 하나를 저장하려고 32 bytes 사용

배열이면?

```
int[] arr -> 4bytes 
Node[] arr -> 32 bytes
```

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

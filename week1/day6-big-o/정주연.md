# 시간복잡도와 공간복잡도 (Big-O)

> 📅 2025.02.18 | 📁 Week 1
> 

---

## 🧠 학습 질문

- [x]  Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?
- [x]  O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?
- [x]  O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?
- [x]  최선/평균/최악의 경우를 각각 언제 고려하는가?
- [x]  Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?
- [x]  시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

## Big-O, Big-Θ, Big-Ω의 차이 & 언제 사용하는가

### 시간 복잡도란?

- 알고리즘의 효율성은 **알고리즘의 수행 시간** 또는 알고리즘이 수행하는 동안 사용되는 메모리 공간의 크기로 나타낼 수 있다. → 시간 복잡도 & 공간 복잡도
- 시간 복잡도는 알고리즘이 수행하는 기본적인 **연산 횟수**를 입력 크기에 비례한 함수로 표현하는 것
- 시간 복잡도의 점근적 표기 : 입력 크기 **n이 무한대로 커질 때**의 복잡도를 간단히 표현하기 위해 사용하는 표기법

### Big-O (상한선)

- 최악의 경우에도 이 효율보다는 나쁘지 않다는 의미
- 알고리즘의 성능 보장치를 제시할 때 사용
- 최악의 성능을 보장하는 지표로, 실무에서 가장 널리 쓰임

### Big-Θ(동일 차수)

- 상한과 하한이 일치하는 경우
- 알고리즘의 **본질적인 복잡도**를 가장 정확하게 묘사
- 해당 알고리즘의 **정확한 성격**을 규정할 때 사용

### Big-Ω(하한선)

- 아무리 빨라도 이 시간보다는 더 걸린다는 의미
- 알고리즘의 **효율성 하한선**을 증명할 때 사용

## O(n)과 O(2n)이 같은 이유 & 상수를 무시하는 이유

Big-O  표기법은 정확한 연산 횟수가 아니라 데이터 규모에 따른 복잡도의 등급을 분류하는 것이 목적이다.

O(2n)→ O(n) 

- n이 10억, 100억으로 증가할 때 2배, 3배의 차이는 그래프의 기울기만 바꿀 뿐, 증가하는 형태(직선형)를 바꾸지 못한다.
- 고성능 CPU에서 2n인 알고리즘이 저성능 CPU의 n보다 빠를 수 있으므로, 기기 독립적인 분석을 위해 상수를 제외한다.

## O(n²)과 O(n² + n)이 같은 이유 & 하위 차수를 무시하는 이유

O(n^2+n) → O(n^2)

- n이 커질수록 최고차항의 영향력이 절대적이 됨
- n=1,000,000일 때 n^2은 1조이며 n은 백만에 불과
- 전체 실행 시간에서 n이 차지하는 비중은 0.0001% 미만으로 수렴하므로 지배적 항만 남김

## 최선/평균/최악의 경우를 각각 언제 고려하는지

- **최악의 경우 (Worst Case)**
    - 어떤 입력이 들어와도 이 시간 안에는 끝난다는 것을 보장
    - 시스템의 안정성과 신뢰성을 평가하는 가장 중요한 척도
- **평균의 경우 (Average Case)**
    - 모든 가능한 입력의 확률 분포를 고려하여 평균적인 성능을 계산
    - 퀵 정렬처럼 최악의 상황이 발생할 확률이 매우 낮을 때 알고리즘의 실제 가치를 판단하는 근거가 됨
- **최선의 경우 (Best Case)**
    - 알고리즘이 가장 유리한 데이터를 만났을 때의 성능
    - 실제 성능 지표로 쓰기엔 부적절하나, 특정 상황에서의 최적화 가능성을 확인할 때 참고

## Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가

- 단순한 평균, 확률적인 개념이 아님
- 비싼 연산 뒤에는 반드시 저렴한 연산이 보장됨을 수학적으로 계산
- e.g.) 동적 배열(ArrayList)의 삽입
    - 대부분의 삽입은 빈칸에 넣기만 하면 되므로 O(1)
    - 배열이 꽉 차면 2n 크기의 새 배열을 만들고 복사하는 O(n) 작업 발생
    - 하지만 이 O(n) 작업은 한 번 발생하면, 이후 다음 n번의 삽입은 다시 O(1)임이 보장됨
    - 총 비용을 n+1번의 연산으로 나누면 결과적으로 각 연산은 상수 시간 O(1)이 됨

## 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가

현재 우리 시스템의 병목(Bottleneck)이 CPU인가, RAM인가?를 먼저 파악하고 선택

- 시복 > 공복
    - 사용자 인터렉션이 중요한 서비스
    - 캐싱(Redis), 다이나믹 프로그래밍(Memoization) 등이 대표적
    
- 공복 > 시복
    - 임베디드, IoT, 대규모 데이터 압축
    - 메모리가 부족하면 프로그램 자체가 크래시(Crash)되므로, 느리더라도 메모리를 아끼는 알고리즘을 사용

---

## 📎 참고 자료

<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트

<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->
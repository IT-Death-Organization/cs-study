# Day 6: 시간복잡도와 공간복잡도 (Big-O)
> 📅 2025.02.18 | 📁 Week 1

---

## 🧠 학습 질문

- [x] Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?
- [x] O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?
- [x] O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?
- [x] 최선/평균/최악의 경우를 각각 언제 고려하는가?
- [x] Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?
- [x] 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

---

# 알고리즘 복잡도 정리

## 1. Big-O, Big-Θ, Big-Ω 차이

### Big-O (O) — 상한 (Upper Bound)

최악의 경우 이 이상은 안 걸린다는 보장.

**수학적 정의:**

```
f(n) ∈ O(g(n))
⇔ ∃ c > 0, n₀ s.t.
   0 ≤ f(n) ≤ c·g(n)  for all n ≥ n₀
```

g(n)이 f(n)의 상한 함수이며, 보통 Worst-case 분석에 사용된다.

- 삽입정렬 최악 → O(n²)
- 이진탐색 → O(log n)

---

### Big-Ω (Ω) — 하한 (Lower Bound)

최소한 이 정도는 걸린다.

**수학적 정의:**

```
f(n) ∈ Ω(g(n))
⇔ ∃ c > 0, n₀ s.t.
   0 ≤ c·g(n) ≤ f(n) for all n ≥ n₀
```

g(n)이 f(n)의 하한이며, Best-case 분석에 자주 등장한다.

- 비교 기반 정렬은 Ω(n log n) (이론적 하한)

---

### Big-Θ (Θ) — 정확한 차수 (Tight Bound)

상한과 하한이 동시에 성립.

```
f(n) ∈ Θ(g(n))
⇔ f(n) ∈ O(g(n)) AND f(n) ∈ Ω(g(n))
```

정확히 같은 차수를 의미한다.

- 병합정렬 → Θ(n log n)

---

### 정리

| 표기 | 의미 | 언제 사용? |
|------|------|-----------|
| O | 최악 상한 | 구현 분석 |
| Ω | 하한 | 이론적 최소 |
| Θ | 정확한 성장률 | 정확한 성능 표현 |

---

## 2. O(n)과 O(2n)이 같은 이유

수학적으로 `2n ≤ 2·n`이므로, Big-O 정의에서 상수 c가 존재하면 충분하다.

```
2n ∈ O(n)
```

알고리즘 복잡도는 n → ∞ 일 때의 성장률을 비교하기 때문에, 상수는 증가율에 영향을 주지 않는다.

예를 들어 n = 1,000,000 일 때:

```
n  = 1,000,000
2n = 2,000,000
n² = 10¹²
```

2배 차이는 의미 없고, 차수 차이가 핵심이다.

---

## 3. O(n²) vs O(n² + n)

지배항(Dominant Term) 개념으로 설명된다.

```
n² + n = n²(1 + 1/n)
```

n → ∞ 이면 1/n → 0이므로:

```
n² + n ≈ n²
```

극한 비교:

```
lim (n² + n) / n² = 1
```

비율이 상수이므로 같은 차수다. 따라서 하위 차수 항은 무시한다.

---

## 4. 최선 / 평균 / 최악 언제 고려?

### 최악 (Worst-case)

- 보장된 성능이 필요할 때
- 시스템, 서버, 실시간 시스템, 라이브러리 설계
- 예: 퀵정렬 → O(n²) worst

### 평균 (Average-case)

- 일반 사용자 환경
- 확률 모델이 명확할 때
- 예: 해시테이블 → 평균 O(1)

### 최선 (Best-case)

- 거의 의미 없으나, 적응형 알고리즘에서는 중요
- 예: 삽입정렬 → 이미 정렬된 경우 O(n)

---

## 5. Amortized 시간복잡도

### 정의

여러 연산을 묶어서 평균 낸 비용. 한 번은 비싸도 전체적으로 보면 싸다.

### 대표 예: Dynamic Array (vector push_back)

| 연산 | 비용 |
|------|------|
| 일반 push_back | O(1) |
| resize | O(n) |

n번 push를 수행하면 총 비용 ≈ 2n이므로:

```
Amortized = O(1)
```

### 일반 시간복잡도와 차이

| | 일반 | Amortized |
|--|------|-----------|
| 분석 단위 | 개별 연산 | 연속 연산 평균 |
| 기준 | 최악 중심 | 총 비용 중심 |

---

## 6. 시간 vs 공간 트레이드오프

핵심 질문: 메모리를 더 써서 시간을 줄일 것인가?

### 대표 예

**해시테이블:** 공간을 더 사용하는 대신 시간 O(1) 달성.

**메모이제이션:** 중간 결과를 저장하여 재귀 시간 감소.

### 판단 기준

- **입력 크기:** n이 매우 크면 공간 제한이 중요
- **실행 환경:** 서버는 메모리 충분, 임베디드는 공간 중요
- **실시간 요구:** 실시간 시스템이면 시간 우선
- **캐시 친화성:** 메모리 locality도 고려


## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

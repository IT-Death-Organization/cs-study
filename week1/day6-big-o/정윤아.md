# Day 6: 시간복잡도와 공간복잡도 (Big-O)
> 📅 2025.02.18 | 📁 Week 1

---

## 🧠 학습 질문

- [x] Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?
- [x] O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?
- [x] O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?
- [x] 최선/평균/최악의 경우를 각각 언제 고려하는가?
- [x] Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?
- [x] 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

---

## Q1. Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?

[답변]
* Big-O(빅 오): 점근적 상한(upper bound)
    - 충분히 큰 n에 대해, f(n)이 g(n)의 상수배 이하로 자란다. ("최대 이 정도")
    - 알고리즘 성능의 최악 시간복잡도
* Big-Ω(빅 오메가): 점근적 하한(lower bound)
    - 충분히 큰 n에 대해, f(n)이 g(n)의 상수배 이상으로 자란다. ("최소 이 정도")
    - 알고리즘의 최소 필요 비용
* Big-Θ(빅 세타): 점근적 정확한 차수(tight bound)
    - f(n)이 g(n)와 같은 차수로 자란다. ("정확히 이 정도")
    - 알고리즘 복잡도를 정확한 차수로 말할 때

---

## Q2. O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?

[답변]
* Big-O가 상수 배 차이를 구분하지 않음
    - Big-O는 '입력 크기에 따라 런타임이 얼마나 빠르게 증가하는가'
    - 실행시간 함수 T(n)의 '성장률'을 나타냄

* 상수를 '무시'하는 이유
    - N이 커질수록, 상수는 무시할 수 있을 정도로 영향이 적음
    - 상수배는 성장률을 바꾸지 않는다

[보완]
* Big-O의 정의: f(n)=O(g(n)) 라는 것은,
∃ c > 0, ∃ n0 ∈ N such that for all n ≥ n0, 0 ≤ f(n) ≤ c · g(n)
    - 어떤 양수 c에 대해, 충분히 큰 n에 대해 f(n)이 g(n)의 상수배보다 커지지 않는다.
    * 2n = O(n): 2n \le 2\cdot n (모든 n\ge 1) 이므로 성립
    * n = O(2n): n \le 1\cdot (2n) (모든 n\ge 1) 이므로 성립
    => 같은 '성장률 범주'

---

## Q3. O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?

[답변]
* Big-O가 지배항 중심의 점근적 상한을 나타냄
    - n이 충분히 커지면 n^2가 n보다 훨씬 빠르게 증가 => n^2 + n의 성장률은 n^2가 지배

* 하위 차수를 '무시'하는 이유
    - N이 커질수록, 하위 항의 상대적 영향이 매우 작아짐(지배항에 비해 0에 수렴)

[보완]
* n^2+n = O(n^2) 증명(상한으로 덮기)
: n ≥ 1이면 n ≤ n^2 이므로,
n^2+n ≤ 2n^2 (∀ n ≥ 1)
따라서 c=2, n_0=1을 택하면 n^2+n ≤ 2·n^2가 되어 n^2+n = O(n^2)

* n^2 = O(n^2+n)도 성립
: n^2 ≤ n^2+n (∀ n ≥ 1)

---

## Q4. 최선/평균/최악의 경우를 각각 언제 고려하는가?

[답변]
* 최선의 경우
    - 성능의 가장 최적한 상황을 고려할 때
    - 특정 조건이 충족된 상태에서 빠른 케이스를 활용할 때
* 평균의 경우
    - 입력 분포가 현실적으로 잘 정의됐을 때
    - 실제 기대 성능이 중요할 때
* 최악의 경우
    - 성능 보장이 필요할 때
    - 입력이 악의적으로 주어질 때

---

## Q5. Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?

[답변]
* Amortized 시간복잡도
    - 연산을 여러 번 수행했을 때의 평균 비용 -> 전체 비용 / 연산 횟수
    - 연산 시퀀스 전체에 대한 평균
    - 특정 연산이 매우 비싸더라도, 전체 시퀀스 관점에서 1회당 비용이 일정하게 제한됨
* 일반 시간복잡도와의 차이
    - 일반 시간복잡도: 단일 연산 1회의 최대 비용
    - Amortized: 연산들이 연속으로 수행될 때의 전체 비용을 연산 횟수를 고려한 1회 연산의 평균적인 비용

---

## Q6. 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

[답변]
1. 제약 조건 확인
    - 메모리 제한, 시간 제한 고려
2. 입력 규모 vs 성장률
    - 목료 입력 크기에 대해, 공간 비용을 늘림으로써 시간 절감이 효과적인지 고려
3. 캐시/메모리 접근 패턴 고려
    - 공간 늘리면 캐시 미스가 증가해 오히려 느려질 수도 있음
    - 연속 메모리 vs 포인터 구조의 실제 비용 차이 반영

---

## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->
https://djm03178.tistory.com/20

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->

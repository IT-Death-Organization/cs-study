# Day 6: 시간복잡도와 공간복잡도 (Big-O)
> 📅 2025.02.18 | 📁 Week 1

---

## 🧠 학습 질문

- [x] Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?
- [x] O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?
- [x] O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?
- [x] 최선/평균/최악의 경우를 각각 언제 고려하는가?
- [x] Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?
- [x] 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

<br>

# 1. Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?

점근적 표기법은 알고리즘의 효율성을 수학적으로 나타내는 방법입니다.


* Big-Ω (빅-오메가): 최선의 경우(Lower Bound). "아무리 빨라도 이 정도 시간은 걸린다."
* Big-Θ (빅-세타): 평균적인 경우(Tight Bound). "대략 이 정도 시간은 걸린다."
* Big-O (빅-오): 최악의 경우(Upper Bound). "아무리 느려도 이 시간 안에는 끝난다."

실무와 면접에서는 주로 Big-O를 사용합니다. 프로그램은 언제나 최악의 상황(데이터가 매우 많거나 찾고자 하는 값이 맨 끝에 있는 등)을 대비해야 안전하기 때문입니다.

<br>

# 2. O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?

Big-O 표기법은 데이터 양($n$)이 무한대로 커질 때 알고리즘의 증가 속도(Growth Rate)에 집중합니다.

$n$이 100만, 10억처럼 매우 커지면 앞에 곱해진 2나 3 같은 상수는 실행 시간에 큰 영향을 주지 못합니다. 예를 들어, $n$이 무한대라면 $n$이나 $2n$이나 똑같이 '직선'의 형태로 증가하는 성질은 변하지 않습니다. 따라서 복잡도를 계산할 때는 계수(Coefficient)를 과감히 생략하고 $O(n)$으로 표기합니다.

<br>

# 3. O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?

데이터 $n$이 커질수록 가장 높은 차수의 영향력이 나머지 하위 차수들을 압도하게 됩니다.

만약 $n = 10,000$일 때:
* $n^2 = 100,000,000$
* $n = 10,000$

여기서 $n$은 $n^2$에 비해 겨우 0.01%의 영향력밖에 가지지 못합니다. $n$이 더 커질수록 이 격차는 더욱 벌어집니다. 따라서 알고리즘의 전체적인 흐름을 결정짓는 항만 남기고 나머지는 무시합니다.

<br>

# 4. 최선/평균/최악의 경우를 각각 언제 고려하는가?

알고리즘을 분석할 때는 데이터의 분포에 따라 결과가 달라집니다.

1. 최악의 경우 (Worst Case): 가장 대중적으로 고려하는 기준입니다. 어떤 입력이 들어와도 이 성능은 보장한다는 '안전성'의 지표가 됩니다.
2. 평균의 경우 (Average Case): 알고리즘이 실제 환경에서 어느 정도의 성능을 보일지 예측할 때 사용합니다. 계산이 복잡하지만 가장 현실적인 지표입니다. (예: 퀵 정렬의 평균 시간복잡도)
3. 최선의 경우 (Best Case): 거의 고려하지 않습니다. 운이 좋아야만 나오는 성능 정보는 "이론상 가능" 일 뿐이지, 중요하지 않습니다.

<br>

# 5. Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?

'분할 상환' 복잡도라고도 부릅니다. 특정 연산이 가끔 매우 느리지만, 그 외 대다수의 연산이 매우 빠를 때 사용하는 개념입니다.

Day 1에서 다룬 동적 배열(ArrayList)의 삽입이 대표적인 예시입니다.
* 대부분의 삽입은 $O(1)$입니다.
* 가끔 배열이 가득 차서 크기를 늘리고 복사할 때만 $O(n)$이 걸립니다.
* 이 $O(n)$의 비용을 평소의 수많은 $O(1)$ 연산들이 나눠 가진다고 계산하면 평균적으로 $O(1)$이 됩니다.

단순히 "평균"을 내는 것이 아니라, 연속된 일련의 연산들에 대해 총비용을 계산한다는 점에서 일반적인 시간복잡도 분석과 차이가 있습니다.

<br>

# 6. 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

대부분의 알고리즘 설계에서는 "메모리를 더 써서 시간을 단축할 것인가(Space to Time)", 아니면 "시간을 더 써서 메모리를 아낄 것인가(Time to Space)"를 고민하게 됩니다.

### 시간 복잡도를 우선하는 경우
현대 시스템은 메모리 용량이 비교적 넉넉하므로, 빠른 응답 속도를 위해 메모리를 더 사용하는 방식을 선호합니다.
* 예시: 캐싱(Caching), 메모이제이션(Memoization), 해시 테이블(Hash Table)

### 공간 복잡도를 우선하는 경우
임베디드 시스템이나 작은 모바일 기기처럼 메모리 자원이 극도로 제한적인 환경에서는 조금 느리더라도 메모리 점유율을 최소화하는 설계를 선택합니다.
# Day 6: 시간복잡도와 공간복잡도 (Big-O)
> 📅 2025.02.18 | 📁 Week 1

---

## 🧠 학습 질문

- [ ] Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?
- [ ] O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?
- [ ] O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?
- [ ] 최선/평균/최악의 경우를 각각 언제 고려하는가?
- [ ] Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?
- [ ] 시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?

---

## Q1. "Big-O, Big-Θ, Big-Ω의 차이는 무엇이며 각각 언제 사용하는가?"

### 1) Big-O (O) — 상한(Upper Bound)

- 알고리즘 수행 시간의 **최대 증가율**을 의미한다.
- "최악의 경우 이 정도보다 더 나빠지지 않는다"를 보장한다.
- 실전 문제 풀이 및 시스템 설계에서 가장 많이 사용된다.

#### 예시

```cpp
for(int i = 0; i < n; i++){
    cout << i;
}
```

이 반복문은 n번 실행된다.  
최악의 경우에도 n번을 넘지 않으므로 **O(n)** 이다.

---

### 2) Big-Ω (Ω) — 하한(Lower Bound)

- 수행 시간의 **최소 증가율**을 의미한다.
- "최소한 이 정도는 걸린다"는 뜻이다.

#### 예시

선형 탐색:

```cpp
for(int i = 0; i < n; i++){
    if(arr[i] == target) return i;
}
```

- 최선의 경우: 첫 번째 원소에서 찾음 → 1번 비교 → Ω(1)

---

### 3) Big-Θ (Θ) — 정확한 증가율(Tight Bound)

- 상한과 하한이 동일할 때 사용
- 정확한 증가율을 표현

#### 예시

```cpp
for(int i = 0; i < n; i++){
    cout << i;
}
```

항상 n번 실행되므로:

- O(n)
- Ω(n)

따라서 **Θ(n)** 이다.

---

### 언제 사용하는가?

- 일반적인 분석: **Big-O**
- 정확한 증가율 명시: **Big-Θ**
- 최소 수행 시간 강조: **Big-Ω**

---

## Q2. "O(n)과 O(2n)이 같은 이유는? 상수를 무시하는 이유는?"

### 핵심 이유

Big-O는 **증가율(성장 속도)** 만 비교한다.  
상수는 입력이 커질수록 영향이 상대적으로 작아진다.

#### 예시

```cpp
for(int i = 0; i < n; i++) {}
```

→ O(n)

```cpp
for(int i = 0; i < 2*n; i++) {}
```

→ O(2n)

입력이 1,000,000이라면:

- n = 1,000,000
- 2n = 2,000,000

차이는 2배이지만,  
입력이 더 커질수록 **비율은 일정**하고 증가 형태는 동일하다.

따라서:

```
O(2n) = O(n)
```

### 상수를 무시하는 이유

1. 하드웨어 성능 차이에 따라 달라짐
2. 알고리즘의 구조적 차이를 분석하는 것이 목적
3. 성장률 비교가 핵심이기 때문

---

## Q3. "O(n²)과 O(n² + n)이 같은 이유는? 하위 차수를 무시하는 이유는?"

### 핵심 원리

입력이 충분히 커지면 **가장 높은 차수항이 지배한다.**

#### 예시

```cpp
for(int i = 0; i < n; i++){
    for(int j = 0; j < n; j++){
        cout << i << j;
    }
}

for(int k = 0; k < n; k++){
    cout << k;
}
```

연산 수:

- n² (이중 반복문)
- + n (단일 반복문)

총 연산: n² + n

입력이 커질수록:

- n² = 1,000,000
- n = 1,000

→ n²가 압도적으로 크다.

따라서:

```
O(n² + n) = O(n²)
```

### 하위 차수를 무시하는 이유

1. 큰 입력에서는 영향이 거의 없음
2. 지배항(dominant term)만이 성장률을 결정
3. 단순화하여 비교를 쉽게 하기 위함

---

## Q4. "최선/평균/최악의 경우를 각각 언제 고려하는가?"

### 1) 최선의 경우 (Best Case)

- 가장 빨리 끝나는 경우
- 드물게 사용
- 하한 분석(Ω)에서 주로 사용

예: 선형 탐색에서 첫 번째 원소에서 찾는 경우 → O(1)

---

### 2) 평균의 경우 (Average Case)

- 현실적인 기대 수행 시간
- 확률 분포가 필요
- 해시 테이블 분석 등에 사용

예: 해시 탐색 평균 O(1)

---

### 3) 최악의 경우 (Worst Case)

- 가장 오래 걸리는 경우
- 시스템 안정성 보장에 필수
- 일반적으로 Big-O는 최악 기준

예: 선형 탐색에서 마지막 원소에서 찾는 경우 → O(n)

---

### 언제 고려하는가?

- 안전성 보장 → 최악
- 실제 성능 추정 → 평균
- 이론적 최소 시간 → 최선

---

## Q5. "Amortized 시간복잡도란 무엇이며 일반 시간복잡도와 어떻게 다른가?"

### 정의

Amortized(분할 상환) 시간복잡도는  
**여러 번의 연산을 평균냈을 때의 수행 시간**을 의미한다.

---

### 예시: 동적 배열 push_back

```cpp
vector<int> v;

for(int i = 0; i < n; i++){
    v.push_back(i);
}
```

배열이 꽉 차면:

1. 기존 크기의 2배로 재할당
2. 기존 원소 복사 (O(n))

재할당은 O(n)이지만  
자주 발생하지 않는다.

전체 n번 삽입의 총 비용은 O(n)

따라서:

```
1회 평균 비용 = O(1)
```

이것이 Amortized O(1)

---

### 일반 시간복잡도와 차이

| 구분 | 일반 시간복잡도 | Amortized |
|------|----------------|-----------|
| 기준 | 단일 연산 | 여러 연산 평균 |
| 예 | push_back 재할당 시 O(n) | 전체 평균 O(1) |

---

## Q6. "시간복잡도와 공간복잡도를 트레이드오프 해야 할 때 어떻게 판단하는가?"

### 기본 원칙

> "메모리를 더 써서 시간을 줄일 것인가?"

---

### 예시 1: 중복 검사

#### 방법 1 — 이중 반복문

```cpp
for(int i = 0; i < n; i++)
    for(int j = i+1; j < n; j++)
        if(arr[i] == arr[j]) return true;
```

시간: O(n²)  
공간: O(1)

---

#### 방법 2 — 해시 사용

```cpp
unordered_set<int> s;
for(int i = 0; i < n; i++){
    if(s.count(arr[i])) return true;
    s.insert(arr[i]);
}
```

시간: O(n)  
공간: O(n)

---

### 판단 기준

1. 입력 크기 n이 매우 큰가?
2. 메모리가 제한적인 환경인가?
3. 실행 시간이 더 중요한가?

---

### 결론

- 서버/대용량 처리 → 시간 우선
- 임베디드/메모리 제한 → 공간 우선
- 일반적으로는 **시간 절약을 위해 공간을 사용하는 경우가 많다**

---


## 📎 참고 자료
<!-- 공부하면서 참고한 링크를 여기에 추가해주세요 -->

---

## 💬 토론 포인트
<!-- PR 리뷰 또는 스터디 중 나온 추가 질문이나 논의 사항을 기록해주세요 -->
